#+TITILE: Hydras
#+PROPERTY: header-args :comments link :mkdirp yes :noweb yes :hlines no

standalone org file containing hydra definitions.

#+BEGIN_SRC emacs-lisp :tangle yes
  (dolist (hydra '(hydra-eyebrowse
                   hydra-flycheck
                   hydra-ibuffer
                   hydra-indent
                   hydra-ein
                   hydra-flyspell
                   hydra-ivy-custom
                   hydra-org-navigate
                   hydra-org-link
                   hydra-org-agenda
                   hydra-visual-move
                   hydra-evil-multiedit
                   hydra-org-clock
                   hydra-persp
                   hydra-text-zoom
                   hydra-vdiff
                   hydra-vlc-rc
                   hydra-winman))
    (let ((hydra-func (intern (concat (symbol-name hydra) "/body")))
          (hydra-file (join-path mohkale-package-root "hydras"
                                 (concat (symbol-name hydra) ".el"))))
      (autoload hydra-func hydra-file nil t)))

  (general-define-key
    :keymaps 'mohkale-window-map
    "." 'hydra-winman/body
    "w" 'hydra-eyebrowse/body
    "C-w" 'hydra-winman/body)

  (general-define-key
    "C-x TAB" 'hydra-indent/body)

  (leader/set-keys
    "H" '("hydras" . "cut off one head, two more shall take it's place")

    "H TAB" '("hydra-indent"      . hydra-indent/body)
    "He"    '("hydra-flycheck"    . hydra-flycheck/body)
    "Hc"    '("hydra-org-clock"   . hydra-org-clock/body)
    "Hl"    '("hydra-persp"       . hydra-persp/body)
    "HL"    '("hydra-eyebrowse"   . hydra-eyebrowse/body)
    "Hx"    '("hydra-text-zoom"   . hydra-text-zoom/body)
    "Hv"    '("hydra-vlc"         . hydra-vlc-rc/body)
    "Hm"    '("hydra-visual-move" . hydra-visual-move/body)
    "Hh"    '("hydra-winman"      . hydra-winman/body)

    "x."    '("hydra-text-zoom" . hydra-text-zoom/body)
    "l"     '("hydra-layouts"   . hydra-persp/body))
#+END_SRC

* text-zoom
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-text-zoom.el

    ;;  _            _
    ;; | |_ _____  _| |_     _______   ___  _ __ ___
    ;; | __/ _ \ \/ / __|___|_  / _ \ / _ \| '_ ` _ \
    ;; | ||  __/>  <| ||_____/ / (_) | (_) | | | | | |
    ;;  \__\___/_/\_\\__|   /___\___/ \___/|_| |_| |_|
    ;;

    (defhydra hydra-text-zoom ()
      ("+" text-scale-increase "increase")
      ("-" text-scale-decrease "decrease")
      ("0" (text-scale-increase 0) "reset")
      ("a" text-scale-increase)
      ("x" text-scale-decrease)
      ("z" (text-scale-increase 0))
      ("q" nil nil :exit t)
      ("<escape>" nil nil :exit t))

  #+END_SRC

* window-management
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-winman.el

    ;;           _           _
    ;; __      _(_)_ __   __| | _____      __     _ __ ___   __ _ _ __   __ _  __ _  ___ _ __
    ;; \ \ /\ / / | '_ \ / _` |/ _ \ \ /\ / /____| '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
    ;;  \ V  V /| | | | | (_| | (_) \ V  V /_____| | | | | | (_| | | | | (_| | (_| |  __/ |
    ;;   \_/\_/ |_|_| |_|\__,_|\___/ \_/\_/      |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|
    ;;                                                                        |___/

    (defhydra hydra-winman (:exit nil :foreign-keys nil :hint nil)
      "
    ^create^               ^move^      ^shift^          ^numbers^               ^resize^
    ^-^------------------  ^-^-------  ^-^------------  ^-^--^-^--------------  ^-^----------------               (__)
    _c_ create             _h_ left    _H_ move-left    _1_.._9_ window-n       _>_ increase-width                (00)
    _d_ delete             _j_ down    _J_ move-down    _0_  ^ ^ window-by-num  _<_ decrease-width          /------\\/
    _s_ split              _k_ up      _K_ move-up      ^ ^  ^ ^                _+_ increase-height        / |    ||
    _v_ vsplit             _l_ right   _L_ move-right   ^ ^  ^ ^                _-_ decrease-height       *  /\\---/\\
    _S_ split-and-focus    _n_ next    ^ ^              ^ ^  ^ ^                ^ ^                          ~~   ~~
    _V_ vsplit-and-focus   _p_ prev

    "
      ("d" evil-window-delete)
      ("c" evil-window-create)
      ("s" evil-window-split)
      ("v" evil-window-vsplit)
      ("S" split-window-below-and-focus)
      ("V" split-window-right-and-focus)

      ("h" evil-window-left)
      ("k" evil-window-up)
      ("j" evil-window-down)
      ("l" evil-window-right)
      ("n" evil-window-next)
      ("p" evil-window-prev)

      ("H" buf-window-left)
      ("J" buf-window-up)
      ("K" buf-window-down)
      ("L" buf-window-right)

      ("0" window-select-window-by-number)
      ("1" winum-select-window nil)
      ("2" winum-select-window nil)
      ("3" winum-select-window nil)
      ("4" winum-select-window nil)
      ("5" winum-select-window nil)
      ("6" winum-select-window nil)
      ("7" winum-select-window nil)
      ("8" winum-select-window nil)
      ("9" winum-select-window nil)

      ("C-0" digit-argument)
      ("C-1" digit-argument)
      ("C-2" digit-argument)
      ("C-3" digit-argument)
      ("C-4" digit-argument)
      ("C-5" digit-argument)
      ("C-6" digit-argument)
      ("C-7" digit-argument)
      ("C-8" digit-argument)
      ("C-9" digit-argument)

      (">" evil-window-increase-width)
      ("<" evil-window-decrease-width)
      ("+" evil-window-increase-height)
      ("-" evil-window-decrease-height)
      ("_" evil-window-decrease-height)

      ("u" winner-undo "undo")
      ("r" winner-redo "redo" :exit t)

      ("w" hydra-eyebrowse/body "workgroups" :exit t)
      ("p" hydra-perspectives/body "perspective" :exit t)

      ("m" window-zen "zen" :exit t)
      ("q" nil "quit" :exit t)
      ("<escape>" nil "quit" :exit t)) ;; prevent evil-escape

  #+END_SRC

* eyebrowse
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-eyebrowse.el

    (require 'eyebrowse)

    ;;                  _
    ;;   ___ _   _  ___| |__  _ __ _____      _____  ___
    ;;  / _ \ | | |/ _ \ '_ \| '__/ _ \ \ /\ / / __|/ _ \
    ;; |  __/ |_| |  __/ |_) | | | (_) \ V  V /\__ \  __/
    ;;  \___|\__, |\___|_.__/|_|  \___/ \_/\_/ |___/\___|
    ;;       |___/

    (defhydra hydra-eyebrowse (:hint nil)
      ("0" eyebrowse-switch-to-window-config-0 :exit t)
      ("1" eyebrowse-switch-to-window-config-1 :exit t)
      ("2" eyebrowse-switch-to-window-config-2 :exit t)
      ("3" eyebrowse-switch-to-window-config-3 :exit t)
      ("4" eyebrowse-switch-to-window-config-4 :exit t)
      ("5" eyebrowse-switch-to-window-config-5 :exit t)
      ("6" eyebrowse-switch-to-window-config-6 :exit t)
      ("7" eyebrowse-switch-to-window-config-7 :exit t)
      ("8" eyebrowse-switch-to-window-config-8 :exit t)
      ("9" eyebrowse-switch-to-window-config-9 :exit t)

      ("M-0" eyebrowse-switch-to-window-config-0)
      ("M-1" eyebrowse-switch-to-window-config-1)
      ("M-2" eyebrowse-switch-to-window-config-2)
      ("M-3" eyebrowse-switch-to-window-config-3)
      ("M-4" eyebrowse-switch-to-window-config-4)
      ("M-5" eyebrowse-switch-to-window-config-5)
      ("M-6" eyebrowse-switch-to-window-config-6)
      ("M-7" eyebrowse-switch-to-window-config-7)
      ("M-8" eyebrowse-switch-to-window-config-8)
      ("M-9" eyebrowse-switch-to-window-config-9)

      ("c" eyebrowse-create-window-config)
      ("d" eyebrowse-close-window-config)
      ("r" eyebrowse-rename-window-config)
      ("n" eyebrowse-next-window-config)
      ("l" eyebrowse-next-window-config)
      ("N" eyebrowse-prev-window-config)
      ("h" eyebrowse-prev-window-config)
      ("TAB" eyebrowse-last-window-config)
      ("u" (progn (winner-undo) (setq this-command 'winner-undo)))
      ("U" winner-redo :exit t)
      ("?" (setq hydra-eyebrowse/verbose-p (not hydra-eyebrowse/verbose-p)))
      ("t" (setq hydra-eyebrowse/show-wconfig-names (not hydra-eyebrowse/show-wconfig-names)))
      ("m" hydra-winman/body :exit t)
      ("p" hydra-persp/body :exit t)

      ("q" nil :exit t))

    (defvar hydra-eyebrowse/verbose-p nil
      "when true, hydra hint doesn't show keybindings")

    (defvar hydra-eyebrowse/show-wconfig-names t
      "when true, wconfigs in the hydra header will includes names (when applicable)")

    (defmacro hydra-eyebrowse/generate-set-binding (kbd value)
      ;; `(unless (eq (lookup-key hydra-eyebrowse/keymap ,kbd)
      ;;              ,value)
      ;;    (define-key hydra-eyebrowse/keymap ,kbd ,value))
      `(define-key hydra-eyebrowse/keymap ,kbd ,value))
    (put 'hydra-eyebrowse/generate-set-binding 'lisp-indent-function 'defun)

    (defface hydra-eyebrowse/active-wconfig-face
      '((t :inherit mode-line))
      "face for inactive windows in the header string")

    (setq hydra-eyebrowse/complete-command-docstring
          "
    Jump                        Actions
    ^^^^—————————————————————  —^—^———————————————————————————^—^————————————————
    [_0_.._9_] nth wconfig     [_c_] create new wconfig      [_m_] window-manager
    [_TAB_] previous wconfig^^ [_d_] delete current wconfig  [_p_] perspectives
    ^^^^                       [_r_] rename current wconfig
    [_h_/_N_] wconfig left
    [_l_/_n_] wconfig right    [_u_/_U_] undo/redo wconfig
    ")

    (defmacro eyebrowse-window-list-to-title (window-list)
      "extract window config title from list.
    is either the title or a nil value."
      `(let ((title (car (cdr (cdr ,window-list)))))
         (unless (string-empty-p title)
           title)))

    (setq hydra-eyebrowse/hint
          ;; TODO break when too long
          '(let ((current-wconfig-num (eyebrowse--get 'current-slot))
                 header-s wconfig-item-s)
             (dolist (wconfig-counter (number-sequence 0 9))
               (let ((wconfig-item (eyebrowse--window-config-present-p wconfig-counter)))
                 (if (not wconfig-item)
                     ;; ;; disable binding for non existent wconfig
                     ;; (hydra-eyebrowse/generate-set-binding
                     ;;   (number-to-string wconfig-counter) nil)
                     nil

                   ;; ;; re-enable binding for existent wconfig
                   ;; (let* ((wconfig-counter-s (number-to-string wconfig-counter))
                   ;;        (invoking-function (intern (concat "hydra-eyebrowse/eyebrowse-switch-to-window-config-"
                   ;;                                           (number-to-string wconfig-counter)))))
                   ;;   ;; re-enable bindings for workgroups which do exist or have been created
                   ;;   (hydra-eyebrowse/generate-set-binding wconfig-counter-s invoking-function))

                   ;; include wconfig in header string
                   (let ((win-name (eyebrowse-window-list-to-title wconfig-item)))
                     (setq wconfig-item-s (if (and win-name
                                                   hydra-eyebrowse/show-wconfig-names)
                                              (format "[%d:%s]" wconfig-counter win-name)
                                            (format "[%d]" wconfig-counter)))

                     (when (eq wconfig-counter
                               current-wconfig-num)
                       (setq wconfig-item-s (propertize wconfig-item-s
                                                        'face 'hydra-eyebrowse/active-wconfig-face)))

                     (setq header-s (concat header-s wconfig-item-s " "))))))

             (setq header-s (format "\n%s %s (_?_ help)\n"
                                    (propertize "Window Configs"
                                                'face 'font-lock-string-face)
                                    (s-trim header-s)))
             (eval (hydra--format nil
                                  '(nil nil :hint nil)
                                  (if (not hydra-eyebrowse/verbose-p)
                                      header-s
                                    (concat header-s
                                            hydra-eyebrowse/complete-command-docstring))
                                  hydra-eyebrowse/heads))))
  #+END_SRC

* emacs-ipython-notebook
  sourced from [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%252Blang/ipython-notebook/packages.el][here]].

  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-ein.el
    (defhydra hydra-ein (:hint nil)
            "
     Operations on Cells^^^^^^            On Worksheets^^^^              Other
     ----------------------------^^^^^^   ------------------------^^^^   ----------------------------------^^^^
     [_k_/_j_]^^     select prev/next     [_h_/_l_]   select prev/next   [_t_]^^         toggle output
     [_K_/_J_]^^     move up/down         [_H_/_L_]   move left/right    [_C-l_/_C-S-l_] clear/clear all output
     [_C-k_/_C-j_]^^ merge above/below    [_1_.._9_]  open [1st..last]   [_C-o_]^^       open console
     [_O_/_o_]^^     insert above/below   [_+_/_-_]   create/delete      [_C-s_/_C-r_]   save/rename notebook
     [_y_/_p_/_d_]   copy/paste           ^^^^                           [_x_]^^         close notebook
     [_u_]^^^^       change type          ^^^^                           [_q_]^^         quit transient-state
     [_RET_]^^^^     execute"
            ("q" nil :exit t)
            ("?" spacemacs//ipython-notebook-ms-toggle-doc)
            ("h" ein:notebook-worksheet-open-prev-or-last)
            ("j" ein:worksheet-goto-next-input)
            ("k" ein:worksheet-goto-prev-input)
            ("l" ein:notebook-worksheet-open-next-or-first)
            ("H" ein:notebook-worksheet-move-prev)
            ("J" ein:worksheet-move-cell-down)
            ("K" ein:worksheet-move-cell-up)
            ("L" ein:notebook-worksheet-move-next)
            ("t" ein:worksheet-toggle-output)
            ("d" ein:worksheet-kill-cell)
            ("R" ein:worksheet-rename-sheet)
            ("y" ein:worksheet-copy-cell)
            ("p" ein:worksheet-yank-cell)
            ("o" ein:worksheet-insert-cell-below)
            ("O" ein:worksheet-insert-cell-above)
            ("u" ein:worksheet-change-cell-type)
            ("RET" ein:worksheet-execute-cell-and-goto-next)
            ;; Output
            ("C-l" ein:worksheet-clear-output)
            ("C-S-l" ein:worksheet-clear-all-output)
            ;;Console
            ("C-o" ein:console-open)
            ;; Merge cells
            ("C-k" ein:worksheet-merge-cell)
            ("C-j" spacemacs/ein:worksheet-merge-cell-next)
            ;; Notebook
            ("C-s" ein:notebook-save-notebook-command)
            ("C-r" ein:notebook-rename-command)
            ("1" ein:notebook-worksheet-open-1th)
            ("2" ein:notebook-worksheet-open-2th)
            ("3" ein:notebook-worksheet-open-3th)
            ("4" ein:notebook-worksheet-open-4th)
            ("5" ein:notebook-worksheet-open-5th)
            ("6" ein:notebook-worksheet-open-6th)
            ("7" ein:notebook-worksheet-open-7th)
            ("8" ein:notebook-worksheet-open-8th)
            ("9" ein:notebook-worksheet-open-last)
            ("+" ein:notebook-worksheet-insert-next)
            ("-" ein:notebook-worksheet-delete)
            ("x" ein:notebook-close))
  #+END_SRC

* persp-mode
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-persp.el
    (require 'persp-mode)

    (defhydra hydra-persp (:hint nil)
      ;; missing commands
      ;;   * last-layout
      ;;   * buffer in layout
      ;;   * layout with helm/ivy
      ;;   * add buffer
      ;;   * add all from layout

      ("1" (switch-to-persp-by-num 0) :exit t)
      ("2" (switch-to-persp-by-num 1) :exit t)
      ("3" (switch-to-persp-by-num 2) :exit t)
      ("4" (switch-to-persp-by-num 3) :exit t)
      ("5" (switch-to-persp-by-num 4) :exit t)
      ("6" (switch-to-persp-by-num 5) :exit t)
      ("7" (switch-to-persp-by-num 6) :exit t)
      ("8" (switch-to-persp-by-num 7) :exit t)
      ("9" (switch-to-persp-by-num 8) :exit t)
      ("0" (switch-to-persp-by-num (read-number "perspective: ")) :exit t)

      ("M-1" (switch-to-persp-by-num 0))
      ("M-2" (switch-to-persp-by-num 1))
      ("M-3" (switch-to-persp-by-num 2))
      ("M-4" (switch-to-persp-by-num 3))
      ("M-5" (switch-to-persp-by-num 4))
      ("M-6" (switch-to-persp-by-num 5))
      ("M-7" (switch-to-persp-by-num 6))
      ("M-8" (switch-to-persp-by-num 7))
      ("M-9" (switch-to-persp-by-num 8))
      ("M-0" (switch-to-persp-by-num (read-number "perspective: ")))

      ("c" persp-add-new) ;; create new perspective
      ("C" persp-copy) ;; copy current perspective
      ("k" persp-kill) ;; remove current perspective
      ("d" persp-kill-current) ;; remove current perspective
      ("r" persp-rename) ;; rename current perspective

      ("?" (setq hydra-persp/verbose-p (not hydra-persp/verbose-p)))
      ("t" (setq hydra-persp/show-perspective-names (not hydra-persp/show-perspective-names)))

      ("b" persp-switch-to-buffer :exit t) ;; switch to buffer in perspective
      ("B" persp-temporarily-display-buffer :exit t) ;; from outside of perspective

      ("h" persp-prev)
      ("l" persp-next)
      ("p" persp-prev)
      ("n" persp-next)

      ("i" persp-import-win-conf) ;; import window configuration from perspecive
      ("I" persp-import-buffers) ;; import buffers from perspective.

      ("[" persp-window-switch) ;; create/switch to perspective in a window
      ("]" persp-frame-switch) ;; create/switch to perspective

      ("s" persp-save-state-to-file) ;; save perspectives to file.
      ("S" persp-save-state-to-file-by-names) ;; save perspectives subset to file.
      ("f" persp-load-state-from-file) ;; load perspectives from file.
      ("F" persp-load-state-from-file-by-names) ;; load perspectives subset from file.

      ("H" persp-move-layout-left)
      ("<" persp-move-layout-left)
      ("L" persp-move-layout-right)
      (">" persp-move-layout-right)

      ("o" mohkale/switch-to-custom-perspective :exit t)
      ("w" hydra-eyebrowse/body :exit t)
      ("q"   nil :exit t)
      ("RET" nil :exit t))

    (defvar hydra-persp/verbose-p nil
      "when true, hydra hint doesn't show keybindings")

    (defvar hydra-persp/show-perspective-names t
      "when true, wconfigs in the hydra header will includes names (when applicable)")

    (setq hydra-persp/complete-command-docstring
      "
    Go To                  ^^^^  Layouts                  ^^^   Actions
    ^^^^———————————————————————  ^^^—————————————————————————   ^^^^^^—————————————————————————————————————
    [_1_.._9_] nth/new layout    [_c_]^ create new layout       ^^[_b_/_B_] persp/temporarily switch buffer
    [_0_] layout by number     ^^[_C_]^ clone current layout    ^^[_i_/_I_] import window-config/buffers
    [_RET_] quit-to-layout     ^^[_k_]^ kill layout             ^^[_s_/_S_] save state to file/by-name
    [_h_/_l_] layout left/right  [_d_]^ kill current layout     ^^[_f_/_F_] load state from file/by-name
    [_H_/_<_] move layout left   [_r_]^ rename layout
    [_L_/_>_] move layout right  [_[_/_]_]^ switch window/frame   [_o_]: custom [_w_]: workgroups [_q_]: quit
    ")

    (defface hydra-persp/active-perspective-face
      '((t :inherit mode-line))
      "face for inactive windows in the header string")

    (defmacro hydra-persp/safe-persp-name (persp)
      `(if ,persp (persp-name ,persp) "default"))

    (setq hydra-persp/hint
          '(let* ((persp-list (nreverse (persp-persps)))
                  (current-persp (get-current-persp))
                  (current-persp-name (hydra-persp/safe-persp-name current-persp))
                  (persp-counter 0)
                  header-s persp-item-s)
             (dolist (persp persp-list)
               (let* ((persp-name (hydra-persp/safe-persp-name persp))
                      (persp-is-current (string-equal persp-name
                                                      current-persp-name)))
                 (setq persp-item-s (if hydra-persp/show-perspective-names
                                        (format "[%d:%s]" (1+ persp-counter) persp-name)
                                      (format "[%d]" (1+ persp-counter))))
                 (setq header-s (concat header-s
                                        (if persp-is-current
                                            (propertize persp-item-s 'face 'hydra-persp/active-perspective-face)
                                          persp-item-s)
                                        " ")))

               (incf persp-counter))
             (setq header-s (format "\n%s %s (_?_ help)\n" (propertize "Layouts:" 'face 'font-lock-string-face) (s-trim header-s)))

             (eval (hydra--format nil
                                  '(nil nil :hint nil)
                                  (if hydra-persp/verbose-p
                                      (concat header-s hydra-persp/complete-command-docstring)
                                    header-s)
                                  hydra-persp/heads))))
  #+END_SRC

* flycheck
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-flycheck.el
    ;; source https://github.com/abo-abo/hydra/wiki/Flycheck

    (defhydra hydra-flycheck
      (:pre (let ((buffer-window (selected-window)))
              (flycheck-list-errors)
              (select-window buffer-window))
       :post (quit-windows-on "*Flycheck errors*")
       :hint nil)
      "Errors"
      ("f"  flycheck-error-list-set-filter "Filter")
      ("j"  flycheck-next-error "Next")
      ("k"  flycheck-previous-error "Previous")
      ("gg" flycheck-first-error "First")
      ("G"  flycheck-last-error "Last")
      ("q"  nil :exit t))
  #+END_SRC

* ibuffer
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-ibuffer.el
    ;; source: https://github.com/abo-abo/hydra/wiki/Ibuffer

    (defhydra hydra-ibuffer-main (:color pink :hint nil)
      "
     ^ ^ ^   ^ ^ ^ | Marks [_*_] | Actions [_a_]     | View       ^^| Select      ^^|
     _k_ ^ ↑ ^ _h_ +-^-^---------+-^-^---------------+-^-^----------+-^-^-----------+
     ^ ^ _RET_ ^ ^ | _m_ark      | _D_: delete       | _g_: refresh | _TAB_: toggle |
     _j_ ^ ↓ ^ _l_ | _u_nmark    | _s_: save marked  | _S_: sort    | _o_: open     |
     ^ ^ ^   ^ ^ ^ | _t_oggle    | _._: toggle hydra | _/_: filter  | _q_: quit     |
    "
      ("m" ibuffer-mark-forward)
      ("u" ibuffer-unmark-forward)
      ("*" hydra-ibuffer-mark/body :exit t)
      ("M" hydra-ibuffer-mark/body :exit t)
      ("t" ibuffer-toggle-marks)

      ("D" ibuffer-do-delete)
      ("s" ibuffer-do-save)
      ("a" hydra-ibuffer-action/body :exit t)

      ("g" ibuffer-update)
      ("S" hydra-ibuffer-sort/body :exit t)
      ("/" hydra-ibuffer-filter/body :exit t)
      ("H" describe-mode :exit t)

      ("h" ibuffer-backward-filter-group)
      ("k" ibuffer-backward-line)
      ("l" ibuffer-forward-filter-group)
      ("j" ibuffer-forward-line)
      ("RET" ibuffer-visit-buffer :exit t)

      ("TAB" ibuffer-toggle-filter-group)

      ("o" ibuffer-visit-buffer-other-window :exit t)
      ("Q" quit-window :exit t)
      ("q" nil :exit t)
      ("." nil :exit t))

    (defalias 'hydra-ibuffer/body #'hydra-ibuffer-main/body)

    (defhydra hydra-ibuffer-mark (:color teal :columns 5 :after-exit (hydra-ibuffer-main/body))
      "Mark"
      ("*" ibuffer-unmark-all "unmark all")
      ("M" ibuffer-mark-by-mode "mode")
      ("m" ibuffer-mark-modified-buffers "modified")
      ("u" ibuffer-mark-unsaved-buffers "unsaved")
      ("s" ibuffer-mark-special-buffers "special")
      ("r" ibuffer-mark-read-only-buffers "read-only")
      ("/" ibuffer-mark-dired-buffers "dired")
      ("e" ibuffer-mark-dissociated-buffers "dissociated")
      ("h" ibuffer-mark-help-buffers "help")
      ("z" ibuffer-mark-compressed-file-buffers "compressed")
      ("b" hydra-ibuffer-main/body "back" :exit t))

    (defhydra hydra-ibuffer-action (:color teal :columns 4
                                    :after-exit
                                    (if (eq major-mode 'ibuffer-mode)
                                        (hydra-ibuffer-main/body)))
      "Action"
      ("A" ibuffer-do-view "view")
      ("E" ibuffer-do-eval "eval")
      ("F" ibuffer-do-shell-command-file "shell-command-file")
      ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
      ("H" ibuffer-do-view-other-frame "view-other-frame")
      ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
      ("M" ibuffer-do-toggle-modified "toggle-modified")
      ("O" ibuffer-do-occur "occur")
      ("P" ibuffer-do-print "print")
      ("Q" ibuffer-do-query-replace "query-replace")
      ("R" ibuffer-do-rename-uniquely "rename-uniquely")
      ("T" ibuffer-do-toggle-read-only "toggle-read-only")
      ("U" ibuffer-do-replace-regexp "replace-regexp")
      ("V" ibuffer-do-revert "revert")
      ("W" ibuffer-do-view-and-eval "view-and-eval")
      ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
      ("b" nil "back"))

    (defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
      "Sort"
      ("i" ibuffer-invert-sorting "invert")
      ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
      ("v" ibuffer-do-sort-by-recency "recently used")
      ("s" ibuffer-do-sort-by-size "size")
      ("f" ibuffer-do-sort-by-filename/process "filename")
      ("m" ibuffer-do-sort-by-major-mode "mode")
      ("b" hydra-ibuffer-main/body "back" :exit t))

    (defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
      "Filter"
      ("m" ibuffer-filter-by-used-mode "mode")
      ("M" ibuffer-filter-by-derived-mode "derived mode")
      ("n" ibuffer-filter-by-name "name")
      ("c" ibuffer-filter-by-content "content")
      ("e" ibuffer-filter-by-predicate "predicate")
      ("f" ibuffer-filter-by-filename "filename")
      (">" ibuffer-filter-by-size-gt "size")
      ("<" ibuffer-filter-by-size-lt "size")
      ("/" ibuffer-filter-disable "disable")
      ("b" hydra-ibuffer-main/body "back" :exit t))
  #+END_SRC

* ivy
  the actual ivy hydra has trailing whitespace and is inseperably tied to C-o for both entry and exit, despite me not liking the former and changing the latter. This is my variant, much of the same functionality, just different display.

  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-ivy-custom.el
    (require 'ivy-hydra)

    (defhydra hydra-ivy (:foreign-keys run :hint nil)
      "
     ^ ^   ^ ^   ^ ^ | call        ^^^^| finish         ^^^^| Options | Action _n_/_p_: %s(ivy-action-name)
    -^-^---^-^---^-^-+^^^^-------------+----------------^^^^+---------+--------------------------^^^^^^^^^^^^^^^^^^^^^^^^|
     ^ ^   _J_   ^ ^ | _<_/_+_ grow    | _RET_/_d_ done     | _r_egex-switch:   %18s(ivy--matcher-desc) ^^^^^^^^^^^^^^^^^|
     ^ ^   _j_   ^ ^ | _>_/_-_ shrink  | _C-RET_ dispatch ^^| _c_alling:        %18s(if ivy-calling \"on\" \"off\") ^^^^^|
     _h_   ^+^   _l_ | _t_oggle-mark ^^| _M-RET_ call     ^^| _C_ase-fold:      %18s`ivy-case-fold-search ^^^^^^^^^^^^^^^|
     ^ ^   _k_   ^ ^ | _u_n/_m_ark     | _S-SPC_ restrict ^^| _T_runcate-lines: %18s(if truncate-lines \"on\" \"off\") ^^|
     ^ ^   _K_   ^ ^ | occ_U_r _q_uit  | ^   ^ ^ ^          | _f_ilter:         %18s(if ivy-use-ignore \"on\" \"off\") ^^|
    "
      ;; movement
      ("h" ivy-beginning-of-buffer)
      ("j" ivy-next-line)
      ("k" ivy-previous-line)
      ("l" ivy-end-of-buffer)
      ("J" ivy-scroll-up-command)
      ("K" ivy-scroll-down-command)

      ;; finish + marking
      ("RET"   ivy-alt-done :exit t)
      ("d"     ivy-alt-done :exit t)
      ("C-RET" ivy-dispatching-done :exit t)
      ("M-RET" ivy-call :exit t)
      ("S-SPC" ivy-restrict-to-matches)
      ("SPC"   ivy-mark)
      ("m"     ivy-mark)
      ("DEL"   ivy-unmark-backward)
      ("u"     ivy-unmark)
      ("t"     ivy-toggle-mark)
      ("T"     ivy-toggle-marks)

      ;; actions
      ("n" ivy-next-action)
      ("p" ivy-prev-action)
      ;; ("r" ivy-read-action) ;; poisons local bindings

      (">" ivy-minibuffer-grow)
      ("+" ivy-minibuffer-grow)
      ("<" ivy-minibuffer-shrink)
      ("-" ivy-minibuffer-shrink)

      ("U" ivy-occur :exit t)
      ("c" ivy-toggle-calling)
      ("C" ivy-toggle-case-fold)
      ("r" ivy-rotate-preferred-builders) ;; change regex
      ("f" ivy-toggle-ignore)
      ("T" (setq truncate-lines (not truncate-lines)))

      ;; hidden commands
      ("1" digit-argument)
      ("2" digit-argument)
      ("3" digit-argument)
      ("4" digit-argument)
      ("5" digit-argument)
      ("6" digit-argument)
      ("7" digit-argument)
      ("8" digit-argument)
      ("9" digit-argument)
      ("0" digit-argument)

      ("g" ivy-beginning-of-buffer)
      ("G" ivy-end-of-buffer)
      ("C-u" ivy-scroll-down-command) ;; overriden for uniarg

      ;; exit commands
      ;; nil                  means exit the hydra
      ;; keyboard-escape-quit means exit the ivy session
      ("q"        nil :exit t)
      ("i"        nil :exit t)
      ("<escape>" nil :exit t)
      ("C-."      nil :exit t)
      ("C-g" keyboard-escape-quit :exit t))

    ;; for some reason, can't be bound within hydra
    (general-define-key
      :keymaps 'hydra-ivy/keymap
      "M-o" 'ivy-beginning-of-buffer)

    ;; escape keys for ivy-dispatching-done-hydra
    (setq ivy-dispatching-done-hydra-exit-keys '(("ESC" nil) ("C-g" nil)))

    (defalias 'hydra-ivy-custom #'hydra-ivy)

    (advice-add 'ivy-read :after
                (defun hydra-ivy--auto-exit-with-ivy (&rest args)
                  (hydra-ivy/nil)))

    (provide 'hydra-ivy-custom)
  #+END_SRC

* org
** agenda
   sourced from [[https://github.com/abo-abo/hydra/wiki/Org-agenda][here]]

   #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-org-agenda.el
    (defhydra hydra-org-agenda (:pre  (setq which-key-inhibit t)
                                :post (setq which-key-inhibit nil)
                                :hint none
                                :foreign-keys run)
      "
    Org agenda (_q_uit)

    ^Clock^      ^Visit entry^              ^Date^             ^Other^
    ^-----^----  ^-----------^------------  ^----^-----------  ^-----^---------
    _ci_ in      _SPC_ in other window      _ds_ schedule      _gr_ reload
    _co_ out     _TAB_ & go to location     _dd_ set deadline  _._  go to today
    _cq_ cancel  _RET_ & del other windows  _dt_ timestamp     _gd_ go to date
    _cj_ jump    _o_   link                 _+_  do later
    ^^           ^^                         _-_  do earlier

    ^View^          ^Filter^                 ^Headline^         ^Toggle mode^
    ^----^--------  ^------^---------------  ^--------^-------  ^-----------^----
    _vd_ day        _ft_ by tag              _ht_ set status    _tf_ follow
    _vw_ week       _fr_ refine by tag       _hk_ kill          _tl_ log
    _vt_ fortnight  _fc_ by category         _hr_ refile        _ta_ archive trees
    _vm_ month      _fh_ by top headline     _hA_ archive       _tA_ archive files
    _vy_ year       _fx_ by regexp           _h:_ set tags      _tr_ clock report
    _vn_ next span  _fd_ delete all filters  _hp_ set priority  _td_ diaries
    _vp_ prev span
    _vr_ reset

    "
      ;; Entry
      ("hA" org-agenda-archive-default)
      ("hk" org-agenda-kill)
      ("hp" org-agenda-priority)
      ("hr" org-agenda-refile)
      ("h:" org-agenda-set-tags)
      ("ht" org-agenda-todo)
      ;; Visit entry
      ("o"   link-hint-open-link :exit t)
      ("<tab>" org-agenda-goto :exit t)
      ("TAB" org-agenda-goto :exit t)
      ("SPC" org-agenda-show-and-scroll-up)
      ("RET" org-agenda-switch-to :exit t)
      ;; Date
      ("dt" org-agenda-date-prompt)
      ("dd" org-agenda-deadline)
      ("+" org-agenda-do-date-later)
      ("-" org-agenda-do-date-earlier)
      ("ds" org-agenda-schedule)
      ;; View
      ("vd" org-agenda-day-view)
      ("vw" org-agenda-week-view)
      ("vt" org-agenda-fortnight-view)
      ("vm" org-agenda-month-view)
      ("vy" org-agenda-year-view)
      ("vn" org-agenda-later)
      ("vp" org-agenda-earlier)
      ("vr" org-agenda-reset-view)
      ;; Toggle mode
      ("ta" org-agenda-archives-mode)
      ("tA" (org-agenda-archives-mode 'files))
      ("tr" org-agenda-clockreport-mode)
      ("tf" org-agenda-follow-mode)
      ("tl" org-agenda-log-mode)
      ("td" org-agenda-toggle-diary)
      ;; Filter
      ("fc" org-agenda-filter-by-category)
      ("fx" org-agenda-filter-by-regexp)
      ("ft" org-agenda-filter-by-tag)
      ("fr" org-agenda-filter-by-tag-refine)
      ("fh" org-agenda-filter-by-top-headline)
      ("fd" org-agenda-filter-remove-all)
      ;; Clock
      ("cq" org-agenda-clock-cancel)
      ("cj" org-agenda-clock-goto :exit t)
      ("ci" org-agenda-clock-in :exit t)
      ("co" org-agenda-clock-out)
      ;; Other
      ("q" nil :exit t)
      ("gd" org-agenda-goto-date)
      ("." org-agenda-goto-today)
      ("gr" org-agenda-redo))
   #+END_SRC

** clock & timers
   sourced from [[https://github.com/abo-abo/hydra/wiki/Org-clock-and-timers][here]].

   #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-org-clock.el
    (defhydra hydra-org-clock (:color blue :hint nil)
      "
    ^Clock:^ ^In/out^     ^Edit^   ^Summary^    | ^Timers:^ ^Run^           ^Insert
    -^-^-----^-^----------^-^------^-^----------|--^-^------^-^-------------^------
    (_?_)    _i_n         _e_dit   _g_oto entry | (_z_)     _r_elative      ti_m_e
     ^ ^     _c_ontinue   _q_uit   _d_isplay    |  ^ ^      cou_n_tdown     i_t_em
     ^ ^     _o_ut        ^ ^      _R_eport     |  ^ ^      _p_ause toggle
     ^ ^     ^ ^          ^ ^      ^ ^          |  ^ ^      _s_top
    "
      ("i" org-clock-in)
      ("c" org-clock-in-last)
      ("o" org-clock-out)

      ("e" org-clock-modify-effort-estimate)
      ("q" org-clock-cance)

      ("g" org-clock-goto)
      ("d" org-clock-display)
      ("R" org-clock-report)
      ("?" (org-info "Clocking commands"))

      ("r" org-timer-start)
      ("n" org-timer-set-timer)
      ("p" org-timer-pause-or-continue)
      ("s" org-timer-stop)

      ("m" org-timer)
      ("t" org-timer-item)
      ("z" (org-info "Timers")))
   #+END_SRC

** links
   sourced from [[https://github.com/abo-abo/hydra/wiki/Org-mode-links][here]].

   #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-org-link.el
     (require 'org-link-edit)

     (defun org-link-unlinkify ()
       "Replace an org-link with the description, or if this is absent, the path."
       (interactive)
       (let ((eop (org-element-context)))
         (when (eq 'link (car eop))
           (message "%s" eop)
           (let* ((start (org-element-property :begin eop))
                  (end (org-element-property :end eop))
                  (contents-begin (org-element-property :contents-begin eop))
                  (contents-end (org-element-property :contents-end eop))
                  (path (org-element-property :path eop))
                  (desc (and contents-begin
                             contents-end
                             (buffer-substring contents-begin contents-end))))
             (setf (buffer-substring start end)
                   (concat (or desc path)
                           (make-string (org-element-property :post-blank eop) ?\s)))))))

     (defhydra hydra-org-link (:color red)
       "Org Link Edit"
       ("j" org-link-edit-forward-slurp  "forward slurp")
       ("k" org-link-edit-forward-barf   "forward barf")
       ("u" org-link-edit-backward-slurp "backward slurp")
       ("i" org-link-edit-backward-barf  "backward barf")
       ("r" org-link-unlinkify "remove link")
       ("q" nil "cancel" :exit t))
   #+END_SRC

** navigation
   #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-org-navigate.el
    (defun hydra-org-navigate--end-of-current-branch ()
      (interactive)
      (let ((last-point (point))
            current-point)
        (while (not (eq last-point
                        current-point))
          (setq last-point (point))
          (org-forward-heading-same-level nil)
          (setq current-point (point)))))

    (defun hydra-org-navigate--beginning-of-current-branch ()
      (interactive)
      (let ((last-point (point))
            current-point)
        (while (not (eq last-point
                        current-point))
          (setq last-point (point))
          (org-backward-heading-same-level nil)
          (setq current-point (point)))))

    (defun hydra-org-navigate--get-pretty-outline-path ()
      "like `org-display-outline-path' except returns
    the propertised string instead of displaying it."
      (interactive)
      (let ((separator nil)
            (current nil)
            (path (org-get-outline-path))
            (file (buffer-file-name (buffer-base-buffer))))
        (ignore-errors
            (setq path
                  (add-to-list 'path (save-excursion
                                       (org-back-to-heading t)
                                       (when (looking-at org-complex-heading-regexp)
                                         (let ((text (match-string 4)))
                                           (set-text-properties 0 (length text) nil text)
                                           text)))
                               t)))

        (if path
            (org-format-outline-path
             path
             (1- (frame-width))
             (and file (concat (file-name-nondirectory file) ": "))
             separator)
          (and file (concat (file-name-nondirectory file) ": /")))))

    (defvar hydra-org-navigate/verbose-p nil
      "display extended help message for hydra-org-navigate/body")

    (defhydra hydra-org-navigate (:hint nil :foreign-keys run)
      ;; ("h" org-previous-visible-heading)
      ;; ("p" org-previous-visible-heading)
      ("h" org-outline-smart-up-level)
      ("j" org-forward-heading-same-level)
      ("k" org-backward-heading-same-level)
      ("l" org-next-visible-heading)
      ("J" org-next-visible-heading)
      ("K" org-previous-visible-heading)
      ("?" (setq hydra-org-navigate/verbose-p (not hydra-org-navigate/verbose-p)))
      ("g" hydra-org-navigate--beginning-of-current-branch)
      ("G" hydra-org-navigate--end-of-current-branch)
      ("f" counsel-org-goto)
      ("F" counsel-org-goto-all)
      ("n" org-next-block)
      ("N" org-previous-block)
      ("b" org-previous-block)
      ("q" nil :exit t))

    (defvar hydra-org-navigate/header-hint
      "
      %s(hydra-org-navigate--get-pretty-outline-path) (_?_ help)")

    (setq
     hydra-org-navigate/complete-command-docstring
     "
    [_h_]: parent         [_g_]: first child    [_n_]: next block
    [_j_]: sibling down   [_G_]: last child     [_b_]: prev block
    [_k_]: sibling up     [_f_]: find node
    [_l_]: next           [_F_]: find any node
    ")

    (setq hydra-org-navigate/hint
          '(eval (hydra--format
                  nil
                  '(nil nil :hint nil)
                  (concat hydra-org-navigate/header-hint
                          (when hydra-org-navigate/verbose-p
                            hydra-org-navigate/complete-command-docstring))
                  hydra-org-navigate/heads)))
   #+END_SRC

* vlc-rc
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-vlc-rc.el
    (require 'vlc-rc)

    ;; NOTE comments with @ means add current value indicator

    (defhydra hydra-vlc-rc (:hint nil)
      "
    ^ ^             | media          ^^| general commands  ^^^^| toggle                          ^^^^^^|       *@*
    ^-^-------------+-^-^--------------+-------------------^^^^+---------------------------------^^^^^^|       :::
    _d_elete-socket | _f_ind-file      | _F_ull-screen       ^^| _tl_/_tr_/_ts_ loop/repeat/shuffle    |      .   .
    _k_ill-process  | _e_nqueue-file   | _v_olume-ctrl       ^^| _oa_/_od_ ^  ^ set audio track/device |     =@@@@@=
    _q_uit/exit     | _c_lear-playlist | stream-_p_osition   ^^| _or_ ^  ^ ^  ^ set aspect ratio       |     -*###*-
    ^ ^             | _n_ext-item      | _=_   ^ ^ reset speed | _os_ ^  ^ ^  ^ set subtitle track     |  :*:       :*:
    ^ ^             | _p_rev-item      | _S-+_/_+_ raise speed | _oz_ ^  ^ ^  ^ set video zoom         |  @@@/**+**\\@@@
    ^ ^             | _._ goto-item    | _S--_/_-_ lower speed | ^  ^ ^  ^ ^  ^                        | +@@@@@@@@@@@@@+
    "
      ("SPC" vlc/toggle-play)
      ("f" vlc/add-file)

      ;; speed
      ("+" vlc/increase-speed)
      ("=" vlc/reset-speed)
      ("-" vlc/decrease-speed)
      ("S-+" vlc/fast-forward)
      ("S--" vlc/rewind)

      ;; exit
      ("d" vlc/kill-connection)
      ("k" vlc/kill-process)

      ;; playlist
      ("c" vlc/clear)
      ("f" vlc/add-file)
      ("e" vlc/enqueue-file)
      ("n" vlc/next)
      ("p" vlc/previous)

      ;; commands
      ("F" vlc/toggle-fullscreen)
      ("v" vlc/volume-ctrl) ;; @
      ("s" vlc/screenshot)
      ("|" vlc/screenshot)
      ("p" vlc/set-stream-position)
      ("'" vlc/set-stream-position)
      ("." vlc/goto-playlist-item)

      ;; toggle/options
      ("tl" vlc/toggle-loop)    ;; @
      ("tr" vlc/toggle-repeat)  ;; @
      ("ts" vlc/toggle-shuffle) ;; @
      ("oa" vlc/set-audio-track)
      ("oc" vlc/set-video-crop)
      ("od" vlc/set-audio-device)
      ("or" vlc/set-aspect-ratio)
      ("os" vlc/set-subtitle-track)
      ("oz" vlc/set-zoom) ;; @

      ("q" nil :exit t))
  #+END_SRC


* visual-move
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-visual-move.el
    (defhydra hydra-visual-move (:foreign-keys run)
      ("gj" evil-next-line "next-line")
      ("gk" evil-previous-line "prev-line")
      ("j"  evil-next-visual-line "next-visual-line")
      ("k"  evil-previous-visual-line "prev-visual-line")
      ("q"  nil "quit" :exit t))
  #+END_SRC

* indentation
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-indent.el
    (defmacro hydra-indent--keep-visual-state-active (&rest body)
      "when body is invoked with evil-visual, restore the state after body"
      `(let ((visual-active (evil-visual-state-p)))
         ,@body
         (when visual-active
           (evil-normal-state)
           (evil-visual-restore))))
    (put 'hydra-indent--keep-visual-state-active 'elisp-indent-function 'defun)

    (defun hydra-indent--get-region ()
      "return the active region, or the current lines region"
      (if (region-active-p)
          (list (region-beginning) (region-end))
        (list (line-beginning-position) (line-end-position))))

    (defun hydra-indent--join-args-to-region (&rest args)
      (let ((region (hydra-indent--get-region)))
        (apply 'list
               (car   region)
               (nth 1 region)
               args)))

    (defun hydra-indent-set-column (&optional column)
      "set indentation of line or region such that it reaches COLUMN
    when a region is active, function works by moving from the start of the
    region downwards until a non-empty (whitespace does not count) line is
    encountered, and then calculates the offset required to make that lines
    indentation the same as the COLUMN and then applies that offset to every
    line in the region.

    Negative values for COLUMN will be coerced to be +ve and unless called
    interactively, COLUMN will default to 1 when not specified."
      (interactive "P")
      (or column (setq column
                       (if (not (called-interactively-p))
                           +1
                         (read-number "column: "))))

      (and (< column 0) (setq column 0)) ;; ensure +ve

      (save-excursion
        (let* ((region-boundary (hydra-indent--get-region))
               (start           (car   region-boundary))
               (end             (nth 1 region-boundary))
               indent-diff)
          (goto-char start) ;; start of indenting section

          (while (and (<= start end)
                      (line-empty-p)
                      (not (eobp)))
            ;; move forward until indent-able line encountered
            (next-line))

          (unless (or (eobp)
                      (> start end))
            (setq indent-diff (- column (current-indentation)))
            (indent-rigidly start end indent-diff)))))

    (defvar hydra-indent--ascii-art
      "
    "
      "cool ascii art, which can't be in docstring because it has ___")

    (defhydra hydra-indent (:foreign-keys run :hint nil)
      "
     ^ ^    ^ ^    ^ ^ |  ^ ^         |       dMP dMMMMb  dMMMMb  dMMMMMP dMMMMb dMMMMMMP .aMMMb dMMMMMMP dMP .aMMMb  dMMMMb
     _H_    ^ ^    ^ ^ | [_q_]: quit  |      amr dMP dMP dMP VMP dMP     dMP dMP   dMP   dMP\"dMP   dMP   amr dMP\"dMP dMP dMP
     _h_   _RET_   _l_ | [_s_]: break |     dMP dMP dMP dMP dMP dMMMP   dMP dMP   dMP   dMMMMMP   dMP   dMP dMP dMP dMP dMP
     ^ ^    ^ ^    _L_ |  ^ ^         |    dMP dMP dMP dMP.aMP dMP     dMP dMP   dMP   dMP dMP   dMP   dMP dMP.aMP dMP dMP
     ^ ^    ^ ^    ^ ^ |  ^ ^         |   dMP dMP dMP dMMMMP\" dMMMMMP dMP dMP   dMP   dMP dMP   dMP   dMP  VMMMP\" dMP dMP
    "
    ;;   "
    ;;  ^ ^    ^ ^    ^ ^ |  ^ ^         |           .         .       .             . . .
    ;;  _H_    ^ ^    ^ ^ | [_q_]: quit  |   o       |         |       |   o         | | |
    ;;  _h_   _RET_   _l_ | [_s_]: break |   . ;-. ,-| ,-. ;-. |-  ,-: |-  . ,-. ;-. | | |
    ;;  ^ ^    ^ ^    _L_ |  ^ ^         |   | | | | | |-' | | |   | | |   | | | | |
    ;;  ^ ^    ^ ^    ^ ^ |  ^ ^         |   ' ' ' `-' `-' ' ' `-' `-` `-' ' `-' ' ' o o o
    ;; "

      ("h" (hydra-indent--keep-visual-state-active
            (apply 'indent-rigidly
                   (hydra-indent--join-args-to-region
                    (or (and current-prefix-arg
                             (- current-prefix-arg))
                        -1)))))
      ("l" (hydra-indent--keep-visual-state-active
            (apply 'indent-rigidly
                   (hydra-indent--join-args-to-region
                    (or current-prefix-arg +1)))))
      ("H" (hydra-indent--keep-visual-state-active
            (apply 'evil-shift-left
                   (hydra-indent--join-args-to-region
                    (or current-prefix-arg +1)))))
      ("L" (hydra-indent--keep-visual-state-active
            (apply 'evil-shift-right
                   (hydra-indent--join-args-to-region
                    (or current-prefix-arg +1)))))
      ("s"   (hydra-indent--keep-visual-state-active
              (call-interactively 'split-line)))
      ("RET" (hydra-indent--keep-visual-state-active
              (call-interactively 'hydra-indent-set-column)))

      ("q" nil :exit t))

    (general-define-key
      :keymaps 'hydra-indent/keymap
      ;; that's scroll-up silly?
      ("C-u" . nil)
      (">" . hydra-indent/lambda-L)
      ("<" . hydra-indent/lambda-H))
  #+END_SRC

* vdiff
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-vdiff.el
    (defhydra vdiff-toggle-hydra (nil nil :hint nil)
      "
    Toggles
     _c_ ignore case: %s(vdiff--current-case)
     _w_ ignore whitespace: %s(vdiff--current-whitespace)
     _q_ back to main hydra"
      ("c" vdiff-toggle-case)
      ("w" vdiff-toggle-whitespace)
      ("q" vdiff-hydra/body :exit t))

    (defhydra vdiff-hydra (nil nil :hint nil :foreign-keys run)
      (concat (propertize
               "\
     Navigation^^^^          Refine^^   Transmit^^^^             Folds^^^^            Other"
               'face 'header-line)
              "
     _n_/_N_ next hunk/fold  _f_ this   _s_/_S_ send (+step)     _o_/_O_ open (all)   _i_ ^ ^ toggles
     _p_/_P_ prev hunk/fold  _F_ all    _r_/_R_ receive (+step)  _c_/_C_ close (all)  _u_ ^ ^ update diff
     _g_^ ^  switch buffers  _x_ clear  ^ ^ ^ ^                  _t_ ^ ^ close other  _w_ ^ ^ save buffers
     ^ ^^ ^                  ^ ^        ^ ^ ^ ^                  ^ ^ ^ ^              _q_/_Q_ quit hydra/vdiff
     ignore case: %s(vdiff--current-case) | ignore whitespace: %s(vdiff--current-whitespace)")
      ("j" vdiff-next-hunk)
      ("k" vdiff-previous-hunk)
      ("J" vdiff-next-fold)
      ("K" vdiff-previous-fold)
      ("g" vdiff-switch-buffer)
      ("s" vdiff-send-changes)
      ("S" vdiff-send-changes-and-step)
      ("r" vdiff-receive-changes)
      ("R" vdiff-receive-changes-and-step)
      ("o" vdiff-open-fold)
      ("O" vdiff-open-all-folds)
      ("c" vdiff-close-fold)
      ("C" vdiff-close-all-folds)
      ("t" vdiff-close-other-folds)
      ("u" vdiff-refresh)
      ("w" vdiff-save-buffers)
      ("f" vdiff-refine-this-hunk)
      ("F" vdiff-refine-all-hunks)
      ("x" vdiff-remove-refinements-in-hunk)
      ("i" vdiff-toggle-hydra/body :exit t)
      ("q" nil :exit t)
      ("Q" vdiff-quit :exit t))
  #+END_SRC

* iedit
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-evil-multiedit.el
    (defhydra hydra-evil-multiedit ()
      ("k" evil-multiedit-next "next")
      ("j" evil-multiedit-prev "prev")
      ("l" evil-multiedit-match-and-next "mark-next")
      ("h" evil-multiedit-match-and-prev "mark-prev")
      ("*" evil-multiedit-match-all "mark-all")

      ("q" nil nil)
      ("<escape>" nil nil))
  #+END_SRC

* flyspell
  #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/hydras/hydra-flyspell.el
    (defhydra hydra-flyspell (nil nil :hint nil :foreign-keys run)
      "
    | ^M^ove       | ^R^echeck   | ^C^orrect      |
    |-^-^----------|-^-^---------|-^-^------------|
    | _h_ fix-prev | _gr_ region | _TAB_ cycle    |
    | _j_ next     | _gb_ buffer | _c_   correct  |
    | _k_ prev     | _gw_ word   | _p_   at-point |
    | _l_ fix-next | ^  ^        | ^ ^            |
    "
      ("h" flyspell-correct-previous "fix-prev")
      ("j" evil-next-flyspell-error "next")
      ("k" evil-prev-flyspell-error "prev")
      ("l" flyspell-correct-next "fix-next")

      ("TAB" flyspell-auto-correct-word "cycle-suggestion")

      ("c" flyspell-correct-wrapper "correct")
      ("p" flyspell-correct-at-point "fix-at-point")

      ("gb" flyspell-buffer "check-buffer")
      ("gr" flyspell-region "check-region")
      ("gw" flyspell-word "check-word")

      ("q" nil nil)
      ("<escape>" nil nil))
  #+END_SRC

