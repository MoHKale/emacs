# -*- mode: org; encoding: utf-8 -*-
#+TITLE: mohkale.org

#+PROPERTY: header-args    :tangle yes

* Initial Config
** Pre Init
*** Optimisations
   lower startup times by raising the threshold of the emacs garbage collector and performing other optimisations.

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-

  ;; make garbage collector less invasive
  (setq gc-cons-threshold 402653184
	gc-cons-percentage 0.6)

  ;; not needed at startup
  (defvar default-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)

  (with-eval-after-load mohkale/mohkale-el-config-file
    (message "startup hook")
    ;; reset optimisation changes
    (setq gc-cons-threshold 16777216
	  gc-cons-percentage 0.1)

    (setq file-name-handler-alist default-file-name-handler-alist))
#+end_src
*** Initialisation Functions
#+begin_src emacs-lisp
(defun join-dirs (root &rest dirs)
  "Joins a series of directories together, like Python's os.path.join,
  (dotemacs-joindirs \"/tmp\" \"a\" \"b\" \"c\") => /tmp/a/b/c"

  (if (not dirs)
      root
    (apply 'join-dirs
          (expand-file-name (car dirs) root)
          (cdr dirs))))
#+end_src

** Mohkale
*sets up mohkale utility functions. This includes, but is not limited to:
- functions to jump to package files
- shortcuts to re-evaluate this file
- configure the root directory for package files

#+begin_src emacs-lisp
  (defvar mohkale-root "~/.emacs.d/mohkale"
    "root directory for mohkale package scripts")

  (defmacro mohkale/defun-mohkale-find-package-file (file-type file-path &optional root)
    "creates a function to visit a file, ideally under the mohkale directory
  file-type is a symbol, which is substituted into the string `\"mohkale/find-%s-file\"'
  and then set as the name of this function. file-path is the path of the file the function
  will open. root is the base directory from which file path can be found. If nil, it defaults 
  to `mohkale-root'. Pass a non string truthy value if `file-path' is an absolute path."
    (unless (stringp root)
      (if root
	  (setq root (file-name-directory (eval file-path)))
	(setq root mohkale-root)))

    `(defun ,(intern (concat "mohkale/find-" (symbol-name file-type) "-file")) ()
      (interactive)
      (if (not (file-directory-p ,root))
	  (error (format "mohkale::error() : mohkale find file > directory not found: %s" ,root))
	(find-file (join-dirs ,root ,file-path)))))

  (mohkale/defun-mohkale-find-package-file capture-notes "org/notes.org")
  (mohkale/defun-mohkale-find-package-file org-university "org/university.org")
  (mohkale/defun-mohkale-find-package-file configuration mohkale/mohkale-config-file t)

  (defun mohkale/eval-configuration-file ()
    (interactive)
    (org-babel-load-file mohkale/mohkale-config-file))

  (defun mohkale/build-configuration-file ()
    (interactive)
    (org-babel-tangle-file mohkale/mohkale-config-file))

  ;; (spacemacs/set-leader-keys
  ;;   "fec" 'mohkale/find-configuration-file
  ;;   "feb" 'mohkale/build-configuration-file
  ;;   "fer" 'mohkale/eval-configuration-file
  ;;   "oon" 'mohkale/find-capture-notes-file
  ;;   "oou" 'mohkale/find-org-university-file)
#+end_src

** Emacs Sanitize
   make emacs less like... emacs. use saner defaults and make emacs look nicer in general (IMHO).
#+begin_src emacs-lisp
  (setq delete-old-versions -1                                                  ; delete excess backup versions silently
        version-control t                                                       ; use version control
        vc-make-backup-files t                                                  ; make backups in vc as well
        backup-directory-alist '(("." . "~/.emacs.d/backups"))                  ; directory for backups
        auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)) ; set auto save file directory
        vc-follow-symlinks t                                                    ; no confirmation when opening symlinks
        ring-bell-function 'ignore                                              ; NO ANNOYING RINGS!!!
        sentence-end-double-space nil                                           ; sentence SHOULD end with only a fullstop
        default-fill-column 150                                                 ; toggle wrapping text at given character

        display-line-numbers 'relative

        ; Always Use UTF8
        coding-system-for-read  'utf-8
        coding-system-for-write 'utf-8

        frame-title-format
            ;; sets the title string displayed on the frame above. Format of the command is
            ;; a printf like string. Wrap any code you want evaluated conditionally into a list
            ;; and if the first value of that list is a string, it will be evaluated. You can
            ;; include variables anywhere in the string, including sublists, but no functions.
            ;;
            ;; See the format guide here: https://www.emacswiki.org/emacs/FrameTitle
            `(,(user-login-name) "@" ,(system-name) " [%*] %m" major-mode (buffer-file-name " : %f")))

  (set-face-attribute 'default nil
                      :family "Source Code Pro"
                      ;; height value is 1/10pt. so 100 = 10pt
                      :height (if (eq system-type 'gnu/linux)
                                  110
                                100)
                      :weight 'normal
                      :width 'normal)

  (setq-default indent-tabs-mode nil)

  ;; disable annoying GUI enhancements
  (menu-bar-mode -1) 
  (toggle-scroll-bar -1)
  (tool-bar-mode -1)

  (defun hook/after-find-file ()
    "enable line numbers and make relative"
    (display-line-numbers-mode)
    (setq display-line-numbers 'relative))

  (add-hook 'find-file-hook #'hook/after-find-file)
#+end_src
** Paths & Bookmarks
#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes" t)
#+end_src
** space-macs
#+begin_src emacs-lisp
  (general-create-definer mohkale/set-leader-keys
    :states '(normal insert visual emacs)
    :prefix "SPC"
    :non-normal-prefix "C-SPC")
#+end_src

*** Default Leader Keys
    replicate some +basically all+ the built in spacemacs leader keys... cause why fix whats not broken.
#+begin_src emacs-lisp
#+end_src
** Post Init
#+begin_src emacs-lisp
  (with-eval-after-load mohkale/mohkale-el-config-file
    (load-theme 'an-old-hope))
#+end_src
* Methods
** File Hooks/Handlers
carriage returns in files are EVIL!!! avoid them like the plague :P.

#+begin_src emacs-lisp
  (defun no-junk-please-were-unixish ()
    "auto convert found files to use unix EOL formats"
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
	(set-buffer-file-coding-system 'unix))))

  (add-hook 'find-file-hooks 'no-junk-please-were-unixish)
#+end_src
** Buffer Jumping
#+begin_src emacs-lisp
(defun goto-messages-buffer ()
  "switches to messages buffer"
  (interactive)
  (switch-to-buffer (messages-buffer)))
#+end_src
** Window Manipulation
#+begin_src emacs-lisp
(defun force-set-all-visible-windows-dedication (&optional dedicate)
  "allows you to set the dedication of all visible windows
dedicate if truthy, will result in all windows recieving a dedication.
if falsy, all windows will have their dedication removed"
  (interactive "P")
  ;; TODO require persp-mode here
  (and dedicate (setq dedicate t))   ; rationalise value as bool
  (or  dedicate (setq dedicate nil)) ; rationalise value as nil

  (dolist (window (window-list))
    (if (not (eq dedicate (window-dedicated-p window)))
        (with-selected-window window
          (set-window-dedicated-p window dedicate)))))
#+end_src
** Text
*** Querying
functions for querying information about the text at point or retrieve other relevent information.

#+begin_src emacs-lisp
(defun line-width (char-pos)
  "returns the number of columns on the line at char-pos"
  (interactive (if current-prefix-arg
                   (list current-prefix-arg)
                 (list (point))))
  (save-excursion
    (if (not (eql char-pos (point)))
      (goto-char char-pos))
    (let ((line-width (max (- (line-end-position) (line-beginning-position) 1) 0)))
      (if (called-interactively-p 'any)
          (message (format "Line Width: %03d" line-width)))

      line-width)))

(defun column-number (point)
  "returns the column number at point"
  (interactive "")
  (save-excursion
    (goto-char point)
    (current-column)))

(defun point-to-coordinates (&optional point)
  "convert a point to an XY coordinate alist"
  (or point (setq point (point)))
  `(,(line-number-at-pos point) . ,(column-number point)))

(defun line-empty-p (&optional point)
  (save-excursion
    (and point (goto-char point))
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))

(defun list-faces (&optional point)
  (interactive "d")
  (or point (setq point (point)))
  (let ((faces (remq nil
                     `(,(get-char-property point 'read-face-name)
                       ,(get-char-property point 'face)
                       ,(plist-get (text-properties-at point) 'face)))))
    (and (called-interactively-p 'any) (message (format "%s" faces)))
    faces))
#+end_src
*** Formatting
manipulate chunks of text, such as leading indentation or sequential padding.

#+begin_src emacs-lisp
(defun pad-line-with-char-to-length (desired-length char)
  "appends char as many times as required from cursor position"
  (interactive "Nline length: \nccharacter: \nd")
  (barf-if-buffer-read-only) ; can't pad read only buffer

  (save-excursion
    (let* ((line-char-count (line-width (point))))
      (if (>= line-char-count desired-length)
          (error (format "line of length %03d is already larger than desired: %03d" line-char-count desired-length))
        (insert (make-string (- desired-length line-char-count) char))))))

(defun pad-line-with-space-to-length (desired-length)
  "invokes pad-line-with-char-to-length with char as space"
  (interactive "Nline length: \n")
  (pad-line-with-char-to-length desired-length ?\s))

;; (defun remove-indentation-spaces ()
;;   "remove TAB-WIDTH spaces from the beginning of this line"
;;   (interactive)
;;   (if (save-excursion (re-search-backward "[^ \t]" (line-beginning-position) t))
;;       (delete-backward-char 1)
;;     (indent-rigidly (line-beginning-position) (line-end-position) (- tab-width))))

(defun remove-all-trailing-whitespace (start end)
  "removes all trailing whitespace from every line in buffer"
  (interactive (if (region-active-p)
                   (list (region-beginning) (region-end))
                 (list (point-min) (point-max))))

  (barf-if-buffer-read-only) ; can't remove from current buffer

  (save-excursion
    (goto-char end) ; start from end so delete can work forward

    (while (and (> (point) start)
                (re-search-backward " +$" nil t))
      (delete-region (point) (line-end-position)))))
#+end_src

comment regions of text or by default, the current line.

#+begin_src emacs-lisp
(defun toggle-comment-at-point (start end)
  "toggle comment on line or region
pass a prefix argument to bulk toggle across multiple lines.
This function will always comment the line your point is on,

Prefix Behaviour:
| Prefix Range | Behaviour                                       |
|--------------+-------------------------------------------------|
| 0            | current line only                               |
| >1           | current line and upto PREFIX lines after  point |
| <1           | current line and upto PREFIX lines before point |

This behaviour is exactly mapped to the relative lines numbers emacs
can display, ergo adjust howfar you wish to comment using the linum
fringe."
  (interactive (let ((prefix current-prefix-arg))
                 (if (region-active-p)
                     ;; always use region when region available
                     (list (region-beginning) (region-end))
                   (if (or (not prefix)
                           (listp prefix) ;; regular prefix
                           (zerop prefix))
                       ;; no prefix, comment current line only
                       (list (line-beginning-position) (line-end-position))
                     ;; prefix given, use it to determine comment region
                     (let* ((prefix-positive (> prefix 0))
                            (current-pos (if prefix-positive
                                             (line-beginning-position)
                                           (line-end-position))))
                       (save-excursion
                         (evil-next-line prefix)
                         (if prefix-positive
                             `(,current-pos ,(line-end-position))
                           `(,(line-beginning-position) ,current-pos))))))))
  (comment-or-uncomment-region start end))
#+end_src

line insertion and joining functions.

#+begin_src emacs-lisp
(defun custom-insert-line (&optional prefix)
  "inserts a line above or below point

if a prefix argument of 0 or more (or none) is given, the
line is inserted below the point. Otherwise its inserted
above the point.

The absolute value of the prefix determines how many lines
are inserted.

Eg: A prefix of:
  * nil - inserts a single line below the cursor
  * -1  - inserts a single line above the cursor
  * 0   - inserts a single line below the cursor
  * 1   - inserts a single line below the cursor
  * -10 - inserts 10 lines above the cursor
  * 10  - inserts 10 lines below the cursor"
  (interactive "P")

  (save-excursion
    (let ((move-arg (if (or (not prefix)
                            (>= prefix 0))
                        nil ; if prefix xor prefix >= 0
                      0)))
      (move-end-of-line move-arg)
      (open-line (max 1 (abs prefix))))))

(defun custom-insert-line-below (&optional prefix)
  (interactive "P")
  (custom-insert-line (abs (or prefix 1))))

(defun custom-insert-line-above (&optional prefix)
  (interactive "P")
  (custom-insert-line (- (abs (or prefix 1)))))

(defun evil-join-backwards (&optional prefix)
  "same as join line, except joins line immeadiately before point"
  (interactive "p")
  (let ((start nil)
        (end   nil))
    (if (evil-visual-state-p)
        (let ((range (evil-visual-range)))
          (setq start (nth 0 range))
          (setq end   (nth 1 range)))
      ;; not visual, calculate ranges
      (setq end (point))
        (save-excursion
          (forward-line (- (abs prefix)))
          (setq start (point))))
    ;; remove excursion block if you wan't to
    ;; reallign point to start of line on join
    (save-excursion
      (if (line-empty-p start)
          ;; when joining onto an empty line
          ;; maintain leading whitespace
          (evil-join-whitespace start end)
        ;; otherwise trim to single space
        (evil-join start end)))))
#+end_src
** Buffers, Windows & Frames
#+begin_src emacs-lisp
(defun kill-this-buffer-and-window-maybe ()
  "kills the currently open buffer and the window if another is open"
  (interactive)
  (let ((window-count (length (window-list))))
    (if (> window-count 1)
        (kill-buffer-and-window)
      (kill-this-buffer))))

(defun kill-all-windows-and-return-to-home ()
  "kills every other window and returns to spacemacs home"
  (interactive)
  (dolist (window (cdr (window-list)))
    ;; window-list starts with current window
    (delete-window window))
  (spacemacs/home))

(defun shell-command-on-buffer ()
  "Asks for a command and executes it in inferior shell with current buffer
as input."
  (interactive)
  (shell-command-on-region
   (point-min) (point-max)
   (read-shell-command "Shell command on buffer: ")))
#+end_src
** Layout & Perspective Interactions
   TODO reevaluate this
#+begin_src emacs-lisp
  ;; (defun spacemacs//layout-contains-buffer-p (buffer)
  ;;   "returns true if the given buffer is in the current layout"
  ;;   (not (spacemacs//layout-not-contains-buffer-p buffer)))

  ;; (defun get-buffers-in-current-layout ()
  ;;   "returns all buffers tied to the current spacemacs layout"
  ;;   (seq-filter #'spacemacs//layout-contains-buffer-p (buffer-list)))

  ;; ;; WARN this is insanely convoluted, turns out helm is tough :(
  ;; ;; (defun helm-toggle-buffers-in-layout ()
  ;; ;;   "use helm to select the buffers in your current layout"
  ;; ;;   (interactive)
  ;; ;;   (helm :sources helm-source-buffers-list
  ;; ;;         :buffer "*Toggle Perspective Buffers*")
  ;; ;;   )

  ;; (defun persp-add-current-buffer ()
  ;;   "adds current buffer to current perspective"
  ;;   (interactive)
  ;;   (persp-add-buffer (current-buffer)))

  ;; (defun persp-remove-current-buffer ()
  ;;   "removes current buffer from current persp"
  ;;   (interactive)
  ;;   (persp-remove-buffer (current-buffer)))
#+end_src
* Packages
** electric-pair
   electric pair is a built in module which lets auto insert matching pair. For example, inserting a ( will lead to emacs auto inserting ).
#+begin_src emacs-lisp
  (use-package elec-pair
    :ensure t
    :defer nil
    :config
    (setq electric-pair-preserve-balance nil)
    (electric-pair-mode 1))
#+end_src
** evil
#+begin_src emacs-lisp
  (use-package evil
    :defer nil
    :ensure t
    :config
    (evil-mode 1)
    (setq evil-cross-lines t))
#+end_src
** which-key
#+begin_src emacs-lisp
  (use-package which-key
    :defer nil
    :ensure t
    :config
    (which-key-mode 1))
#+end_src
