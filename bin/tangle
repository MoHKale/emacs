#!/usr/bin/env ruby
# TODO: Minimise file system lookups.

require 'rake'
require 'open3'
require 'logger'
require 'stringio'
require 'rbconfig'
require 'pathname'
require 'optparse'
require 'tempfile'
require 'fileutils'
require 'shellwords'
require 'io/console'

begin
  require 'colorize' # pretty strings
rescue LoadError
  # pretty printing unavailable :(
  # just define some dummy methods
  class String
    ignore = ->(*args) { self } # do nothing

    [
      :default,
      :colorize,
      :black,  :light_black,
      :red,    :light_red,
      :green,  :light_green,
      :yellow, :light_yellow,
      :blue,   :light_blue,
      :magenta,:light_magenta,
      :cyan,   :light_cyan,
      :white,  :light_white
    ].each { |name| define_method(name, ignore) }
  end
end

def devnull
  File.open(File::NULL, 'w')
end

def null_logger
  Logger.new devnull
end

options = {
  file: 'init.org',
  init_file: File.expand_path(File.join(File.dirname(__FILE__), '../init.el')), # used for byte-compilation
  compile: false,
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: tangle [options]"

  opts.on('-f', '--file=FILE', 'Tangle FILE')
  opts.on('-l', '--logfile=FILE', 'Log to FILE, defaults to null or STDERR') do |file|
    file == '-' ? STDERR : File.open(file, 'a')
  end

  opts.on('-i', '--[no-]interactive', 'Force treatment of STDOUT as terminal or not')
  opts.on('-c', '--[no-]compile', 'Force byte-compilation of tangled elisp files')

  opts.on('-v', '--[no-]verbose', 'Raise verbosity of program output')
  opts.on("-h", "--help", "Print this help message") { puts opts; exit 0 }
end.parse!(into: options)

# force interactive execution
unless options[:interactive].nil?
  STDOUT.sync = options[:interactive]
end

unless options[:logfile]
  options[:logfile] = (STDOUT.isatty || options[:interactive]) ? File.open(File::NULL, 'w') : STDERR
end

# only print indicator lines when stderr isn't active
options[:indicator] = options[:logfile] != STDERR

logger = Logger.new(options[:logfile])
logger.level = Logger::DEBUG if options[:verbose]
options[:logger] = logger

# what to show in messages.
display_file = options[:file]

# what to actually access
options[:file] = File.expand_path options[:file]
if %w[cygwin msys].include? RbConfig::CONFIG['host_os']
  options[:file] = `cygpath -wa #{Shellwords.escape options[:file]}`.strip
end

# provides an incremental iterator over chars using counter
ProgressIterator = Struct.new(:chars, :counter) do
  def get_char(increment=true)
    char = chars[counter] # current character in iteration
    self.counter = (counter + 1) % chars.length if increment

    char
  end
end

class Indicator
  # Indicator States
  DOING  = 0
  DONE   = 1
  FAILED = 2
  SETUP  = 3
  OK     = 4

  attr_writer :state

  def initialize(opts={})
    @logger = opts[:logger]
    @delay = opts.fetch :delay, 1
    @lock = Mutex.new
    @state = SETUP
    spinner_chars = opts.fetch :spinner, %w[| / - \\]
    @spinner = ProgressIterator.new spinner_chars, 0
    @stream = opts[:indicator] ? STDOUT : devnull

    # prevent long lines staying behind
    @last_output_length = 0
  end

  def stringify
    str = "[#{stringify_state}] #{@spinner.get_char}"
    str += ' ' + @message if @message
    str += ' ' * @last_output_length
    @last_output_length = @message.length if @message
    str
  end

  def logger
    @logger ||= null_logger
  end

  def wrap(leave_break=true, &block)
    running = true
    thread = Thread.new do
      while running
        print stringify + "\r"
        sleep(@delay)
      end

      @spinner.counter = 2
      print stringify
      print "\n" if leave_break
    end

    begin
      instance_exec(self, &block)
    ensure
      running = false
      thread.join
    end
  end

  def message=(value)
    @message = value
    logger.info(value)
  end

  private

  def stringify_state
    case @state
    when SETUP
      '    '
    when DONE
      'DONE'.green
    when FAILED
      'XXXX'.red
    when OK
      ' OK '.green
    when DOING
      str = if @spinner.counter % 2 == 0
              '<~<~'
            else
              '~<~<'
            end
      "#{str.light_blue}"
    end
  end

  # remove everything up to the end of the line
  # assumes you have the lock synchronised.
  def clear_stream
    @stream.print(' ' * IO.console.winsize[1])
  end

  ##
  # pass args to aliased puts method while
  # also synchronising with indicator output
  #
  def puts(*args)
    @lock.synchronize {
      # ensure no indicator line remains out
      clear_stream
      @stream.puts(*args)
    }
  end

  ##
  # pass args to STDOUT.print while also
  # synchronising the indicator output
  #
  def print(*args)
    @lock.synchronize { @stream.print(*args)}
  end
end

def tangle_dependencies(file, opts={}, &block)
  cmd = [
    File.join(File.dirname(__FILE__), 'tangle-targets'),
    file
  ]

  logger.info "Finding tangle targets for: #{file}"
  stream = opts[:indicator] ? devnull : STDOUT
  Open3.popen3(cmd) do |sin, sout, serr, wait|
    # process stderr first, then stdout cause it's going to be smaller
    serr.each_line { |line| stream.puts line }
    sout.each_line do |line|
      src, dest = line.chomp.split(':')
      block.call(Pathname.new(src), Pathname.new(dest)) if block
    end
    wait.value.success?
  end
end

TargetDateStatus = Struct.new(:tangled, :compiled)

def tangle_file(file, opts={})
  cmd = [
    # why not popen emacs directly... turns out emacs doesn't like
    # cygwin & displays errors due to missing linux character set
    # files only when not running from bash. DAMN YOU WINDOWS!

    "bash", "-c", [
      "yes", "yes", "|", "emacs", "--batch",
      "--eval", Shellwords.escape("(require (quote ob-tangle))"),
      "--eval", Shellwords.escape("(org-babel-tangle-file \"#{file}\")"),
      "2>&1"
    ].join(" ")
  ]

  stream = opts[:indicator] ? devnull : STDOUT
  IO.popen(cmd, "w+", :external_encoding=>"utf-8") do |io|
    io.each_line { |line| stream.puts line }
  end

  $?.success?
end

def compile_files(init_file, files, opts={})
  file = Tempfile.new('emacs-bytecomp')
  file.write <<EOF
;; -*- lexical-binding: t -*-
;;
;; Needed to make sure package locations and other settings needed for
;; byte-compilation are available. We essentially just spawn a headless
;; emacs instance to byte-compile all out of date files.

(setq load-prefer-newer t)

(load "#{Shellwords.escape(init_file)}")

;; (defvar tangle-byte-compile-failed nil)
;; (advice-add #'byte-compile-file :after
;;             (defun +finish (&rest _)
;;               (with-current-buffer \"*Compile-Log*\"
;;                 (when (and (bound-and-true-p compilation-num-errors-found)
;;                            (> compilation-num-errors-found 0))
;;                   (setq tangle-byte-compile-failed t)))))
EOF
  file.write("\n")
  files.each do |f|
    file.write <<EOF
(message "Byte compiling file: #{Shellwords.escape(f)}")
(byte-compile-file "#{Shellwords.escape(f)}")
EOF
  end
  file.write <<EOF
;; (message "Value is: %s" tangle-byte-compile-failed)
EOF
  file.flush

  logger.info "Running byte-compilation script at #{file.path}"
  cmd = [
    "bash", "-c", [
      "yes", "yes", "|", "emacs", "--batch", "--script", file.path, "2>&1"
    ].join(" ")
  ]

  stream = opts[:indicator] ? devnull : STDOUT
  IO.popen(cmd, "w+", :external_encoding=>"utf-8") do |io|
    io.each_line { |line| stream.puts line }
  end

  $?.success?
ensure
  file.close
  file.unlink
end

Indicator.new(options).wrap do |i|
  i.message = "Checking source file: #{display_file}"

  unless File.exist? options[:file]
    i.state = Indicator::FAILED
    i.message = "Failed to find source file: #{display_file}"
    exit 1
  end

  Dir.chdir File.dirname(options[:file])

  i.state = Indicator::DOING
  i.message = "Checking tangle targets"
  uptodate = TargetDateStatus.new(true, true)
  needs_compiling = []
  needs_tangling = []
  if !tangle_dependencies(options[:file], options) do |src, dest|
       logger.debug "Found tangle target from #{src}: #{dest}"
       if !FileUtils.uptodate?(dest, [src])
         logger.info("File #{dest} is out of date")
         needs_tangling << src
         uptodate.tangled &&= false
         if dest.extname == '.el' &&
            !dest.basename.to_s.start_with?('.')
           uptodate.compiled &&= false
           needs_compiling << dest
         end
       elsif options[:compile] &&
             dest.extname == '.el' &&
             !dest.basename.to_s.start_with?('.') &&
             !FileUtils.uptodate?(dest.dirname / (dest.basename('.el').to_s + '.elc'), [dest])
         logger.info("File #{dest} needs to be compiled")
         uptodate.compiled &&= false
         needs_compiling << dest
       end
     end
    i.state = Indicator::FAILED
    i.message = 'Failed to determine tangle targets'
    exit 1
  end

  if needs_tangling.include? Pathname.new(options[:file])
    needs_tangling = [Pathname.new(options[:file])]
  else
    needs_tangling = needs_tangling.uniq
  end

  if uptodate.tangled && uptodate.compiled
    i.state = Indicator::OK
    i.message = "Everything is up to date"
    return
  end

  if !uptodate.tangled
    needs_tangling.each do |file|
      i.state = Indicator::DOING
      i.message = "Tangling file #{file}"

      if !tangle_file(file, options)
        i.state = Indicator::FAILED
        i.message = "Failed to tangle file #{file}"
        exit 1
      end
    end
  end

  if !uptodate.compiled && options[:compile] && needs_compiling.length > 0
    i.state = Indicator::DOING
    i.message = "Byte-compiling files"
    if !compile_files(options[:init_file], needs_compiling, options)
      i.state = Indicator::FAILED
      i.message = "Failed to byte-compile files"
      exit 1
    end
  end

  i.state = Indicator::DONE
  i.message = "Tangled " + (options[:compile] ? "and compiled " : '') + display_file
end

logger.close
