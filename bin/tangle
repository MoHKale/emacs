#!/usr/bin/env ruby

require 'rake'
require 'logger'
require 'stringio'
require 'rbconfig'
require 'pathname'
require 'optparse'
require 'fileutils'
require 'shellwords'
require 'io/console'

begin
  require 'colorize' # pretty strings
rescue LoadError
  # pretty printing unavailable :(
  # just define some dummy methods
  class String
    ignore = ->(*args) { self } # do nothing

    [
      :default,
      :colorize,
      :black,  :light_black,
      :red,    :light_red,
      :green,  :light_green,
      :yellow, :light_yellow,
      :blue,   :light_blue,
      :magenta,:light_magenta,
      :cyan,   :light_cyan,
      :white,  :light_white
    ].each { |name| define_method(name, ignore) }
  end
end

def devnull
  File.open(File::NULL, 'w')
end

def null_logger
  Logger.new devnull
end

options = {
  file: 'init.org',
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: tangle [options]"

  opts.on('-f', '--file=FILE', 'tangle FILE')
  opts.on('-l', '--logfile=FILE', 'log to FILE. defaults to null or STDERR') do |file|
    file == '-' ? STDERR : File.open(file, 'a')
  end

  opts.on('-d', '--dependency=FILE', 'add FILE as a tangle dependency') do |file|
    if options[:dependency]
      [*options[:dependency], File.expand_path(file)]
    else
      [File.expand_path(file)]
    end
  end

  opts.on('-i', '--[no-]interactive', 'force treatment of STDOUT as terminal or not.')

  opts.on('-v', '--[no-]verbose', 'raise verbosity of program output')
  opts.on("-h", "--help", "print this help message") { puts opts; exit 0 }
end.parse!(into: options)

# force interactive execution
unless options[:interactive].nil?
  STDOUT.sync = options[:interactive]
end

unless options[:logfile]
  options[:logfile] = (STDOUT.isatty || options[:interactive]) ? File.open(File::NULL, 'w') : STDERR
end

# only print indicator lines when stderr isn't active
options[:indicator] = options[:logfile] != STDERR

logger = Logger.new(options[:logfile])
logger.level = Logger::DEBUG if options[:verbose]
options[:logger] = logger

# what to show in messages.
display_file = options[:file]

# what to actually access
options[:file] = File.expand_path options[:file]
if %w[cygwin msys].include? RbConfig::CONFIG['host_os']
  options[:file] = `cygpath -wa #{Shellwords.escape options[:file]}`.strip

  options[:dependency] = options[:dependency].map do |file|
    `cygpath -wa #{Shellwords.escape file}`.strip
  end
end
options[:files] = [options[:file], *options[:dependency]]

# provides an incremental iterator over chars using counter
ProgressIterator = Struct.new(:chars, :counter) do
  def get_char(increment=true)
    char = chars[counter] # current character in iteration
    self.counter = (counter + 1) % chars.length if increment

    char
  end
end

class Indicator
  # Indicator States
  DOING  = 0
  DONE   = 1
  FAILED = 2
  SETUP  = 3
  OK     = 4

  attr_writer :state

  def initialize(opts={})
    @logger = opts[:logger]
    @delay = opts.fetch :delay, 1
    @lock = Mutex.new
    @state = SETUP
    spinner_chars = opts.fetch :spinner, %w[| / - \\]
    @spinner = ProgressIterator.new spinner_chars, 0
    @stream = opts[:indicator] ? STDOUT : devnull

    # prevent long lines staying behind
    @last_output_length = 0
  end

  def stringify
    str = "[#{stringify_state}] #{@spinner.get_char}"
    str += ' ' + @message if @message
    str += ' ' * @last_output_length
    @last_output_length = @message.length if @message
    str
  end

  def logger
    @logger ||= null_logger
  end

  def wrap(leave_break=true, &block)
    running = true
    thread = Thread.new do
      while running
        print stringify + "\r"
        sleep(@delay)
      end

      @spinner.counter = 2
      print stringify
      print "\n" if leave_break
    end

    begin
      instance_exec(self, &block)
    ensure
      running = false
      thread.join
    end
  end

  def message=(value)
    @message = value
    logger.info(value)
  end

  private

  def stringify_state
    case @state
    when SETUP
      '    '
    when DONE
      'DONE'.green
    when FAILED
      'XXXX'.red
    when OK
      ' OK '.green
    when DOING
      str = if @spinner.counter % 2 == 0
              '<~<~'
            else
              '~<~<'
            end
      "#{str.light_blue}"
    end
  end

  # remove everything up to the end of the line
  # assumes you have the lock synchronised.
  def clear_stream
    @stream.print(' ' * IO.console.winsize[1])
  end

  ##
  # pass args to aliased puts method while
  # also synchronising with indicator output
  #
  def puts(*args)
    @lock.synchronize {
      # ensure no indicator line remains out
      clear_stream
      @stream.puts(*args)
    }
  end

  ##
  # pass args to STDOUT.print while also
  # synchronising the indicator output
  #
  def print(*args)
    @lock.synchronize { @stream.print(*args)}
  end
end

def tangle_targets(file)
  tangle_targets = []
  default_target = File.join(File.dirname(file), File.basename(file, '.*') + '.el')
  tangle_regexp = '.*:tangle "?([^ "]+)"?'

  ignore_files = %w[yes no]

  File.open(file, 'r') do |fd|
    fd.each do |line|
      line = line.strip.chomp

      if line =~ /^#\+PROPERTY: #{tangle_regexp}/i
        default_target = $1 unless ignore_files.include?($1)
      elsif line =~ /^#\+BEGIN_SRC #{tangle_regexp}/i || line =~ /:header-args\+: #{tangle_regexp}/i
        tangle_targets << $1 unless ignore_files.include?($1)
      end
    end
  end

  (tangle_targets << default_target).uniq
end

def targets_uptodate(source, targets)
  uptodate = true

  targets.each do |target|
    logger.debug("found tangle target: #{target}")
    unless FileUtils.uptodate?(target, [source])
      logger.info("file #{target} is out of date")
      uptodate = false
    end
  end

  uptodate
end

def _tangle_args(file)
  [
    # why not popen emacs directly... turns out emacs doesn't like
    # cygwin & displays errors due to missing linux character set
    # files only when not running from bash. DAMN YOU WINDOWS!

    "bash", "-c", [
      "yes", "yes", "|", "emacs", "--batch",
      "--eval", "'(require (quote ob-tangle))'",
      "--eval", "'(org-babel-tangle-file \"%s\")'" % [
        Shellwords.escape(file)
      ],
      "2>&1"
    ].join(" ")
  ]
end

def tangle_file(file, opts={})
  stream = opts[:indicator] ? devnull : STDOUT
  IO.popen(_tangle_args(file), "w+", :external_encoding=>"utf-8") do |io|
    io.each_line { |line| stream.puts line }
  end

  $?.success?
end

exit_code = 0

Indicator.new(options).wrap do |i|
  i.message = "checking source file: #{display_file}"

  unless File.exist? options[:file]
    i.state = Indicator::FAILED
    i.message = "failed to find source file: #{display_file}"
    exit_code = 1
    return
  end

  Dir.chdir File.dirname(options[:file])

  i.message = "checking tangle targets"
  all_uptodate = options[:files].reduce(true) do |acc, file|
    acc && targets_uptodate(file, tangle_targets(file))
  end

  if all_uptodate
    i.state = Indicator::OK
    i.message = "all tangle targets are up to date"
    return
  end

  i.state = Indicator::DOING
  i.message = "tangling file: #{display_file}"

  if !tangle_file(options[:file], options)
    i.state = Indicator::FAILED
    i.message = "failed to tangle file: #{display_file}"
    exit_code = 1
    return
  end

  i.state = Indicator::DONE
  i.message = "tangled #{display_file}"
end

logger.close
exit exit_code
