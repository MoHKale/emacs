#!/usr/bin/env ruby
# TODO: Minimise file system lookups.

require 'set'
require 'rake'
require 'open3'
require 'logger'
require 'stringio'
require 'rbconfig'
require 'optparse'
require 'tempfile'
require 'fileutils'
require 'shellwords'
require 'io/console'

begin
  require 'colorize' # pretty strings
rescue LoadError
  # pretty printing unavailable :(
  # just define some dummy methods
  class String
    ignore = ->(*args) { self } # do nothing

    [
      :default,
      :colorize,
      :black,  :light_black,
      :red,    :light_red,
      :green,  :light_green,
      :yellow, :light_yellow,
      :blue,   :light_blue,
      :magenta,:light_magenta,
      :cyan,   :light_cyan,
      :white,  :light_white
    ].each { |name| define_method(name, ignore) }
  end
end

def devnull
  File.open(File::NULL, 'w')
end

def null_logger
  Logger.new devnull
end

opts = {
  file: 'init.org',
  compile: false,
}

parser = OptionParser.new do |it|
  it.banner = "Usage: tangle [options]"

  it.on('-f', '--file=FILE', 'Tangle FILE')
  it.on('-l', '--logfile=FILE', 'Log to FILE, defaults to null or STDERR') do |file|
    file == '-' ? STDERR : File.open(file, 'a')
  end

  it.on('-d', '--dependency=FILE', 'add FILE as a tangle dependency') do |file|
    if opts[:dependency]
      [*opts[:dependency], File.expand_path(file)]
    else
      [File.expand_path(file)]
    end
  end

  it.on('-i', '--[no-]interactive', 'Force treatment of STDOUT as terminal or not')
  it.on('-c', '--[no-]compile', 'Force byte-compilation of tangled elisp files')

  it.on('-v', '--[no-]verbose', 'Raise verbosity of program output')
  it.on("-h", "--help", "Print this help message") { puts it; exit 0 }
end.parse!(into: opts)

# force interactive execution
unless opts[:interactive].nil?
  STDOUT.sync = opts[:interactive]
end

unless opts[:logfile]
  opts[:logfile] = (STDOUT.isatty || opts[:interactive]) ? File.open(File::NULL, 'w') : STDERR
end

# only print indicator lines when stderr isn't active
opts[:indicator] = opts[:logfile] != STDERR

logger = Logger.new(opts[:logfile])
logger.level = Logger::DEBUG if opts[:verbose]
opts[:logger] = logger

opts[:file] = File.expand_path opts[:file]
if %w[cygwin msys].include? RbConfig::CONFIG['host_os']
  opts[:file] = `cygpath -wa #{Shellwords.escape opts[:file]}`.strip

  options[:dependency] = options[:dependency].map do |file|
    `cygpath -wa #{Shellwords.escape file}`.strip
  end
end

# provides an incremental iterator over chars using counter
ProgressIterator = Struct.new(:chars, :counter) do
  def get_char(increment=true)
    char = chars[counter] # current character in iteration
    self.counter = (counter + 1) % chars.length if increment

    char
  end
end

class Indicator
  # Indicator States
  DOING  = 0
  DONE   = 1
  FAILED = 2
  SETUP  = 3
  OK     = 4

  attr_writer :state

  def initialize(opts={})
    @logger = opts[:logger]
    @delay = opts.fetch :delay, 1
    @lock = Mutex.new
    @state = SETUP
    spinner_chars = opts.fetch :spinner, %w[| / - \\]
    @spinner = ProgressIterator.new spinner_chars, 0
    @stream = opts[:indicator] ? STDOUT : devnull

    # prevent long lines staying behind
    @last_output_length = 0
  end

  def stringify
    str = "[#{stringify_state}] #{@spinner.get_char}"
    str += ' ' + @message if @message
    str += ' ' * @last_output_length
    @last_output_length = @message.length if @message
    str
  end

  def logger
    @logger ||= null_logger
  end

  def wrap(leave_break=true, &block)
    running = true
    thread = Thread.new do
      while running
        print stringify + "\r"
        sleep(@delay)
      end

      @spinner.counter = 2
      print stringify
      print "\n" if leave_break
    end

    begin
      instance_exec(self, &block)
    ensure
      running = false
      thread.join
    end
  end

  def message=(value)
    @message = value
    logger.info(value)
  end

  private

  def stringify_state
    case @state
    when SETUP
      '    '
    when DONE
      'DONE'.green
    when FAILED
      'XXXX'.red
    when OK
      ' OK '.green
    when DOING
      str = if @spinner.counter % 2 == 0
              '<~<~'
            else
              '~<~<'
            end
      "#{str.light_blue}"
    end
  end

  # remove everything up to the end of the line
  # assumes you have the lock synchronised.
  def clear_stream
    @stream.print(' ' * IO.console.winsize[1])
  end

  ##
  # pass args to aliased puts method while
  # also synchronising with indicator output
  #
  def puts(*args)
    @lock.synchronize {
      # ensure no indicator line remains out
      clear_stream
      @stream.puts(*args)
    }
  end

  ##
  # pass args to STDOUT.print while also
  # synchronising the indicator output
  #
  def print(*args)
    @lock.synchronize { @stream.print(*args)}
  end
end

def tangle_dependencies(file, opts={}, &block)
  cmd = [
    File.join(File.dirname(__FILE__), 'tangle-targets'),
    file
  ]

  logger.info "Finding tangle targets for: #{file}"
  stream = opts[:indicator] ? devnull : STDOUT
  Open3.popen3(cmd) do |sin, sout, serr, wait|
    # process stderr first, then stdout cause it's going to be smaller
    serr.each_line { |line| stream.puts line }
    sout.each_line do |line|
      src, dest = line.chomp.split(':')
      block.call(src, dest) if block
    end
    wait.value.success?
  end
end

def tangle_file(file, opts={})
  cmd = [
    # why not popen emacs directly... turns out emacs doesn't like
    # cygwin & displays errors due to missing linux character set
    # files only when not running from bash. DAMN YOU WINDOWS!

    "bash", "-c", [
      "yes", "yes", "|", "emacs", "--batch",
      "--eval", Shellwords.escape("(setq org-confirm-babel-evaluate nil
                                         tangling+ t
                                         create-lockfiles nil
                                         comp-eln-load-path (append (list (concat user-emacs-directory \"eln-cache\"))
                                                                    (bound-and-true-p comp-eln-load-path))
                                         make-backup-files nil)"),
      "--eval", Shellwords.escape("(require (quote ob-tangle))"),
      "--eval", Shellwords.escape("(org-babel-tangle-file \"#{file}\")"),
      "2>&1"
    ].join(" ")
  ]

  stream = opts[:indicator] ? devnull : STDOUT
  IO.popen(cmd, "w+", :external_encoding=>"utf-8") do |io|
    io.each_line { |line| stream.puts line }
  end

  $?.success?
end

def compile_files(init_file, files, opts={})
  file = Tempfile.new('emacs-bytecomp')
  file.write <<EOF
;; -*- lexical-binding: t -*-
;;
;; Needed to make sure package locations and other settings needed for
;; byte-compilation are available. We essentially just spawn a headless
;; emacs instance to byte-compile all out of date files.

(setq load-prefer-newer t
      comp-eln-load-path (append (list (concat user-emacs-directory \"eln-cache\"))
                                 (bound-and-true-p comp-eln-load-path)))

(load "#{Shellwords.escape(init_file)}")

;; (defvar tangle-byte-compile-failed nil)
;; (advice-add #'byte-compile-file :after
;;             (defun +finish (&rest _)
;;               (with-current-buffer \"*Compile-Log*\"
;;                 (when (and (bound-and-true-p compilation-num-errors-found)
;;                            (> compilation-num-errors-found 0))
;;                   (setq tangle-byte-compile-failed t)))))
EOF
  file.write("\n")
  files.each do |f|
    file.write <<EOF
(message "Byte compiling file: #{Shellwords.escape(f)}")
(byte-compile-file "#{Shellwords.escape(f)}")
EOF
  end
  file.write <<EOF
;; (message "Value is: %s" tangle-byte-compile-failed)
EOF
  file.flush

  logger.info "Running byte-compilation script at #{file.path}"
  cmd = [
    "bash", "-c", [
      "yes", "yes", "|", "emacs", "--batch", "--script", file.path, "2>&1"
    ].join(" ")
  ]

  stream = opts[:indicator] ? devnull : STDOUT
  IO.popen(cmd, "w+", :external_encoding=>"utf-8") do |io|
    io.each_line { |line| stream.puts line }
  end

  $?.success?
ensure
  file.close
  file.unlink
end

Indicator.new(opts).wrap do |it|
  it.message = "Checking source file: #{opts[:file]}"
  default_target = opts[:file].ext + '.el'

  unless File.exist? opts[:file]
    it.state = Indicator::FAILED
    it.message = "Failed to find source file: #{display_file}"
    exit 1
  end

  Dir.chdir File.dirname(opts[:file])

  it.state = Indicator::DOING
  it.message = "Checking tangle targets"

  all_compile = Set.new                                                         # List of compilation targets tied to the main tangle target
  to_compile, to_tangle = Set.new, Set.new
  opts.fetch(:dependency, []).each do |dep|
    if File.exist?(dep) && FileUtils.uptodate?(dep, [default_target])
      to_tangle  << opts[:file]
      to_compile << default_target
    end
  end

  if to_tangle.empty?
    tangle_res = tangle_dependencies(opts[:file], opts) do |src, dest|
      logger.debug "Found tangle target from #{src}: #{dest}"
      all_compile << dest if opts[:compile]
      if !FileUtils.uptodate?(dest, [src])
        logger.info("File #{dest} is out of date")
        to_tangle  << src
        to_compile << dest if opts[:compile] && File.extname(dest) == '.el'
      elsif opts[:compile] &&
            File.extname(dest) == '.el' &&
            !File.basename(dest).start_with?('.') &&
            !FileUtils.uptodate?(dest[0...-3] + '.elc', [dest])
        logger.info("File #{dest} needs to be compiled")
        to_compile << dest
      end
    end
    if !tangle_res
      it.state = Indicator::FAILED
      it.message = 'Failed to determine tangle targets'
      exit 1
    end
  end

  # Assume if the main tangle target is out of date, everything else needs to be
  # tangled as well, but just tangling the main file will make everything up to
  # date.
  if to_tangle.include?(opts[:file])
    to_tangle = [opts[:file]]
    to_compile = all_compile
  end

  if to_tangle.empty? && to_compile.empty?
    it.state = Indicator::OK
    it.message = "Everything is up to date"
    return
  end

  to_tangle.each do |file|
    it.state = Indicator::DOING
    it.message = "Tangling file #{file}"

    if !tangle_file(file, opts)
      it.state = Indicator::FAILED
      it.message = "Failed to tangle file #{file}"
      exit 1
    end
  end

  if to_compile.length > 0
    it.state = Indicator::DOING
    it.message = "Byte-compiling files"
    if !compile_files(default_target, to_compile, opts)
      it.state = Indicator::FAILED
      it.message = "Failed to byte-compile files"
      exit 1
    end
  end

  it.state = Indicator::DONE
  it.message = "Tangled " + (opts[:compile] ? "and compiled " : '') + opts[:file]
end

logger.close
