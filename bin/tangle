#!/usr/bin/env ruby
# TODO: Minimise file system lookups.

require 'rake'
require 'logger'
require 'stringio'
require 'rbconfig'
require 'pathname'
require 'optparse'
require 'fileutils'
require 'shellwords'
require 'io/console'

begin
  require 'colorize' # pretty strings
rescue LoadError
  # pretty printing unavailable :(
  # just define some dummy methods
  class String
    ignore = ->(*args) { self } # do nothing

    [
      :default,
      :colorize,
      :black,  :light_black,
      :red,    :light_red,
      :green,  :light_green,
      :yellow, :light_yellow,
      :blue,   :light_blue,
      :magenta,:light_magenta,
      :cyan,   :light_cyan,
      :white,  :light_white
    ].each { |name| define_method(name, ignore) }
  end
end

def devnull
  File.open(File::NULL, 'w')
end

def null_logger
  Logger.new devnull
end

options = {
  file: 'init.org',
  init_file: Dir.pwd + '/init.el',
  compile: true,
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: tangle [options]"

  opts.on('-f', '--file=FILE', 'Tangle FILE')
  opts.on('-l', '--logfile=FILE', 'Log to FILE, defaults to null or STDERR') do |file|
    file == '-' ? STDERR : File.open(file, 'a')
  end

  opts.on('-d', '--dependency=FILE', 'Add FILE as a tangle dependency') do |file|
    if options[:dependency]
      [*options[:dependency], File.expand_path(file)]
    else
      [File.expand_path(file)]
    end
  end

  opts.on('-i', '--[no-]interactive', 'Force treatment of STDOUT as terminal or not')
  opts.on('-c', '--[no-]compile', 'Force byte-compilation of tangled elisp files')

  opts.on('-v', '--[no-]verbose', 'Raise verbosity of program output')
  opts.on("-h", "--help", "Print this help message") { puts opts; exit 0 }
end.parse!(into: options)

# force interactive execution
unless options[:interactive].nil?
  STDOUT.sync = options[:interactive]
end

unless options[:logfile]
  options[:logfile] = (STDOUT.isatty || options[:interactive]) ? File.open(File::NULL, 'w') : STDERR
end

# only print indicator lines when stderr isn't active
options[:indicator] = options[:logfile] != STDERR

logger = Logger.new(options[:logfile])
logger.level = Logger::DEBUG if options[:verbose]
options[:logger] = logger

# what to show in messages.
display_file = options[:file]

# what to actually access
options[:file] = File.expand_path options[:file]
if %w[cygwin msys].include? RbConfig::CONFIG['host_os']
  options[:file] = `cygpath -wa #{Shellwords.escape options[:file]}`.strip

  options[:dependency] = options[:dependency].map do |file|
    `cygpath -wa #{Shellwords.escape file}`.strip
  end
end
options[:files] = [options[:file], *options[:dependency]]

# provides an incremental iterator over chars using counter
ProgressIterator = Struct.new(:chars, :counter) do
  def get_char(increment=true)
    char = chars[counter] # current character in iteration
    self.counter = (counter + 1) % chars.length if increment

    char
  end
end

class Indicator
  # Indicator States
  DOING  = 0
  DONE   = 1
  FAILED = 2
  SETUP  = 3
  OK     = 4

  attr_writer :state

  def initialize(opts={})
    @logger = opts[:logger]
    @delay = opts.fetch :delay, 1
    @lock = Mutex.new
    @state = SETUP
    spinner_chars = opts.fetch :spinner, %w[| / - \\]
    @spinner = ProgressIterator.new spinner_chars, 0
    @stream = opts[:indicator] ? STDOUT : devnull

    # prevent long lines staying behind
    @last_output_length = 0
  end

  def stringify
    str = "[#{stringify_state}] #{@spinner.get_char}"
    str += ' ' + @message if @message
    str += ' ' * @last_output_length
    @last_output_length = @message.length if @message
    str
  end

  def logger
    @logger ||= null_logger
  end

  def wrap(leave_break=true, &block)
    running = true
    thread = Thread.new do
      while running
        print stringify + "\r"
        sleep(@delay)
      end

      @spinner.counter = 2
      print stringify
      print "\n" if leave_break
    end

    begin
      instance_exec(self, &block)
    ensure
      running = false
      thread.join
    end
  end

  def message=(value)
    @message = value
    logger.info(value)
  end

  private

  def stringify_state
    case @state
    when SETUP
      '    '
    when DONE
      'DONE'.green
    when FAILED
      'XXXX'.red
    when OK
      ' OK '.green
    when DOING
      str = if @spinner.counter % 2 == 0
              '<~<~'
            else
              '~<~<'
            end
      "#{str.light_blue}"
    end
  end

  # remove everything up to the end of the line
  # assumes you have the lock synchronised.
  def clear_stream
    @stream.print(' ' * IO.console.winsize[1])
  end

  ##
  # pass args to aliased puts method while
  # also synchronising with indicator output
  #
  def puts(*args)
    @lock.synchronize {
      # ensure no indicator line remains out
      clear_stream
      @stream.puts(*args)
    }
  end

  ##
  # pass args to STDOUT.print while also
  # synchronising the indicator output
  #
  def print(*args)
    @lock.synchronize { @stream.print(*args)}
  end
end

def tangle_targets(file)
  tangle_targets = []
  default_dir = File.dirname(file)
  default_target = File.basename(file, '.*') + '.el'
  # default_target = File.join(default_dir, File.basename(file, '.*') + '.el')
  tangle_regexp = '.*:tangle "?([^ "]+)"?'

  ignore_files = %w[yes no]

  File.open(file, 'r') do |fd|
    fd.each do |line|
      line = line.strip.chomp

      if line =~ /^#\+PROPERTY: #{tangle_regexp}/i
        default_target = $1
      elsif line =~ /^#\+BEGIN_SRC #{tangle_regexp}/i || line =~ /:header-args\+: #{tangle_regexp}/i
        tangle_targets << $1 unless ignore_files.include?($1)
      end
    end
  end

  tangle_targets << default_target unless default_target == 'no'
  tangle_targets.uniq.map { |tar| File.join(default_dir, tar) }
end

TargetDateStatus = Struct.new(:tangled, :compiled)

def compile_uptodate(file)
  file.end_with?('.el') &&
    !File.basename(file).start_with?('.') &&
    !FileUtils.uptodate?(file[...-3]+'.elc', [file])
end

def targets_uptodate(source, targets, check_compiled=false)
  TargetDateStatus.new(true, true).tap do |res|
    targets.each do |target|
      logger.debug("Found tangle target: #{target}")
      logger.info "Comparing #{target} with #{source}"
      if !FileUtils.uptodate?(target, [source]) &&
        logger.info("File #{target} is out of date")
        res.tangled = false
        res.compiled = false
      elsif compile_uptodate(target)
        logger.info("File #{target[...-3]+'.elc'} is out of date")
        res.compiled = false
      end
    end
  end
end

def _tangle_args(file)
  [
    # why not popen emacs directly... turns out emacs doesn't like
    # cygwin & displays errors due to missing linux character set
    # files only when not running from bash. DAMN YOU WINDOWS!

    "bash", "-c", [
      "yes", "yes", "|", "emacs", "--batch",
      "--eval", Shellwords.escape("(require (quote ob-tangle))"),
      "--eval", Shellwords.escape("(org-babel-tangle-file \"#{file}\")"),
      "2>&1"
    ].join(" ")
  ]
end

def tangle_file(file, opts={})
  stream = opts[:indicator] ? devnull : STDOUT
  IO.popen(_tangle_args(file), "w+", :external_encoding=>"utf-8") do |io|
    io.each_line { |line| stream.puts line }
  end

  $?.success?
end

def _compile_args(init_file, files)
  [
    "bash", "-c", [
      "yes", "yes", "|", "emacs", "--batch",
      "--eval", Shellwords.escape("(load \"#{init_file}\")"),
      # I've tried literally everything I can think of but I can't figure out a way
      # to make emacs fail when a compilation has an error :/.
      # "--eval", Shellwords.escape("(progn (defvar tangle-byte-compile-failed nil)
      #                                     (advice-add #'byte-compile-file :after
      #                                                 (defun +finish (&rest _)
      #                                                   (with-current-buffer \"*Compile-Log*\"
      #                                                     (when (> compilation-num-errors-found 0)
      #                                                       (setq tangle-byte-compile-failed t))))))"),
      files.reduce("") do |sum, file|
        sum + '--eval ' + Shellwords.escape("(byte-compile-file \"#{file}\")") + " "
      end,
      # # make sure emacs has a non-0 exit code when ANY of the compiled files weren't compiled'
      # '--eval ' + Shellwords.escape("(and tangle-byte-compile-failed (kill-emacs 1))"),
      "2>&1"
    ].join(" ")
  ]
end

def compile_files(init_file, files, opts={})
  stream = opts[:indicator] ? devnull : STDOUT
  cmd = _compile_args(init_file, files)
  IO.popen(cmd, "w+", :external_encoding=>"utf-8") do |io|
    io.each_line { |line| stream.puts line }
  end

  $?.success?
end

exit_code = 0

Indicator.new(options).wrap do |i|
  i.message = "Checking source file: #{display_file}"

  unless File.exist? options[:file]
    i.state = Indicator::FAILED
    i.message = "Failed to find source file: #{display_file}"
    exit_code = 1
    return
  end

  Dir.chdir File.dirname(options[:file])

  i.state = Indicator::DOING
  i.message = "Checking tangle targets"
  targets = []
  all_uptodate = options[:files].reduce(TargetDateStatus.new(true, true)) do |acc, file|
    file_targets = tangle_targets(file)
    targets += file_targets
    current = targets_uptodate(file, file_targets, options[:compile])
    acc.compiled &&= current.compiled
    acc.tangled &&= current.tangled
    acc
  end

  if all_uptodate.tangled && all_uptodate.compiled
    i.state = Indicator::OK
    i.message = "Everything up to date"
    return
  end

  if !all_uptodate.tangled
    i.state = Indicator::DOING
    i.message = "Tangling file: #{display_file}"

    if !tangle_file(options[:file], options)
      i.state = Indicator::FAILED
      i.message = "Failed to tangle file: #{display_file}"
      exit_code = 1
      return
    end
  end

  if !all_uptodate.compiled && options[:compile]
    i.state = Indicator::DOING
    i.message = "Byte-compiling files"
    lisp_targets = targets.filter { |path| path.end_with? '.el' }
                     .filter(&(method :compile_uptodate))
    if lisp_targets.length > 0 &&
       !compile_files(options[:init_file], lisp_targets, options)
      i.state = Indicator::FAILED
      i.message = "Failed to byte-compile files"
      exit_code = 1
      return
    end
  end

  i.state = Indicator::DOING
  i.message = "Double checking everything is upto date"
  all_uptodate = options[:files].each do |file|
    current = targets_uptodate(file, tangle_targets(file), options[:compile])
    if !current.tangled
      i.state = Indicator::FAILED
      i.message = "Tangle targets missing"
      exit_code = 1
      return
    elsif options[:compile] && !current.compiled
      i.state = Indicator::FAILED
      i.message = "Compile targets missing"
      exit_code = 1
      return
    end
  end

  i.state = Indicator::DONE
  i.message = "Tangled " + (options[:compile] ? "and compiled " : '') + display_file
end

logger.close
exit exit_code
