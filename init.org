# -*- mode: org; coding: utf-8-unix -*-

#+TITLE: mohkale.org
#+STARTUP: content

#+PROPERTY: header-args :tangle init.el :comments link :mkdirp yes :noweb yes :hlines no

* Configuration
  :PROPERTIES:
  :header-args+: :shebang ";; -*- lexical-binding: t -*-"
  :END:

** init.el
*** Early Init
    #+BEGIN_SRC emacs-lisp
      (defvar default-gc-cons-threshold 16777216 ; 16mb
        "my default desired value of `gc-cons-threshold'
      during normal emacs operations.")
    #+END_SRC


    #+BEGIN_SRC emacs-lisp :tangle early-init.el
      ;; make garbage collector less invasive
      (setq gc-cons-threshold  most-positive-fixnum
            gc-cons-percentage 0.6)

      ;; not needed at startup
      (setq default-file-name-handler-alist file-name-handler-alist
            file-name-handler-alist nil)

      ;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
      (push '(menu-bar-lines . 0) default-frame-alist)
      (push '(tool-bar-lines . 0) default-frame-alist)
      (push '(vertical-scroll-bars) default-frame-alist)

      (add-hook 'emacs-startup-hook
                (defun post-init-restore-defaults+ (&rest _)
                  (setq gc-cons-threshold default-gc-cons-threshold
                        gc-cons-percentage 0.1
                        file-name-handler-alist default-file-name-handler-alist)

                  ;; delete no longer necessary startup variable
                  (makunbound 'default-file-name-handler-alist)))
    #+END_SRC

**** Macros
     Macros and functions I'm probably going to need at startup.

     #+BEGIN_SRC emacs-lisp
       (defmacro emacs= (version)
         `(version= emacs-version ,version))

       (defmacro emacs< (version)
         `(version< emacs-version ,version))

       (defmacro emacs<= (version)
         `(version<= emacs-version ,version))

       (defmacro emacs>= (version)
         `(not (emacs< ,version)))

       (defmacro emacs> (version)
         `(not (emacs<= ,version)))

       (defun windows-p ()
         (member system-type '(cygwin ms-dos windows-nt)))

       (defun macos-p ()
         (eq system-type 'darwin))

       (defun unix-p ()
         (member system-type '(gnu gnu/linux gnu/kfreebsd)))
     #+END_SRC

**** Optimisations
     Optimise emacs startup times as much as possible.

     #+BEGIN_SRC emacs-lisp
       ;; not needed at startup
       (setq default-file-name-handler-alist file-name-handler-alist
             file-name-handler-alist nil)

       (unless (emacs>= "27")
         (load (concat user-emacs-directory "early-init.el")))

       (add-hook 'emacs-startup-hook
                 (lambda (&rest _)
                   ;; switch focus to any error or compilation windows
                   (let* ((window-list  (window-list))
                          (window-count (length window-list))
                          (focus-list   '("*Warnings*"
                                          "*Compile-Log*"))
                          (kill-list    '()))
                     (when (> window-count 1)
                       (dolist (window (window-list))
                         (let ((buffer-name
                                (buffer-name (window-buffer window))))
                           (cond
                            ((member buffer-name focus-list)
                             (select-window window))
                            ((member buffer-name kill-list)
                             (delete-window window)))))))

                   ;; load my custom emacs theme
                   (load-theme 'an-old-hope t)))
     #+END_SRC

*** Emacs Sanitize
    make emacs less like... emacs. use saner defaults and make emacs look nicer in general

    #+BEGIN_SRC emacs-lisp
      (setq delete-old-versions t                                                  ; delete excess backup versions silently
            version-control t                                                      ; use version control
            vc-make-backup-files t                                                 ; make backups in vc as well
            vc-follow-symlinks t                                                   ; no confirmation when opening symlinks
            ring-bell-function 'ignore                                             ; NO ANNOYING RINGS!!!
            sentence-end-double-space nil                                          ; sentence SHOULD end with only a fullstop
            default-fill-column 150                                                ; toggle wrapping text at given character
            delete-by-moving-to-trash t                                            ; don't rm, trash my garbage please :)
            search-whitespace-regexp nil                                           ; SPC means SPC, not any amount of spaces
            enable-local-variables t                                               ; allow safe variables, even alongside unsafe ones
            hl-line-sticky-flag nil                                                ; only highlight line in active window
            auto-save-interval 50                                                  ; auto-save as frequently as possible
            backup-by-copying t                                                    ; don't clobber symlinks
            which-key-enable-extended-define-key t                                 ; let's you pass a cons to define-key
            kept-new-versions 15                                                   ; keep this many latest versions of file
            kept-old-versions 5                                                    ; keep this many early versions of file
            ;; NOTE kept-new-versions and kept-old-versions are both used to determine the allowed number of backups.
            ;;      there will be at most kept-new-versions + kept-old-versions backups made.
            recenter-positions '(top middle bottom)

            find-file-suppress-same-file-warnings t

            enable-recursive-minibuffers t
            kill-whole-line              t ; kill-line includes eol
            help-window-select           t ; always

            recentf-max-saved-items 2048)

      (setq-default indent-tabs-mode nil
                    show-trailing-whitespace nil
                    truncate-lines t ; don't split long lines onto next lines
                    scroll-conservatively 101 ; smooth... enough scrolling going line by line
                    scroll-preserve-screen-position t
                    major-mode 'text-mode
                    cursor-in-non-selected-windows nil
                    default-buffer-file-coding-system 'utf-8-unix
                    buffer-file-coding-system 'utf-8-unix
                    echo-keystrokes 0.02)

      (advice-add 'display-startup-echo-area-message :around #'ignore)

      (put 'narrow-to-region 'disabled nil) ;; re-enable
    #+END_SRC

    Set the string emacs shows at the title bar.

    #+BEGIN_SRC emacs-lisp
      (setq frame-title-format
            ;; sets the title string displayed on the frame above. Format of the command is
            ;; a printf like string. Wrap any code you want evaluated conditionally into a list
            ;; and if the first value of that list is a string, it will be evaluated. You can
            ;; include variables anywhere in the string, including sublists, but no functions.
            ;;
            ;; See the format guide here: https://www.emacswiki.org/emacs/FrameTitle
            `(,(user-login-name)
              "@"
              ,(system-name)
              " [%*] %m"
              (:eval (when (derived-mode-p 'pdf-view-mode)
                       (format "(%d/%d)"
                               (pdf-view-current-page)
                               (pdf-cache-number-of-pages))))
              (buffer-file-name " : %f")))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'default nil
                          :family "Source Code Pro"
                          ;; height value is 1/10pt. so 100 = 10pt
                          :height (if (unix-p) 110 100)
                          :weight 'normal
                          :width 'normal)

      ;; to make string based hash tables easier to make
      (define-hash-table-test 'string-hash-table-test
        'string-equal 'sxhash-equal)
    #+END_SRC

    Disable annoying GUI enhancemants. minimal emacs is *best* emacs.

    #+BEGIN_SRC emacs-lisp
      ;; this is now circumvented in early-init.el
      (unless (emacs>= "27")
        (menu-bar-mode -1)     ; dropdown menu list below frame title
        (tool-bar-mode -1)     ; short mini menu shown below the menu bar
        )

      ;; needs to always be called, or spaceline cuts off at the end :(
      (scroll-bar-mode -1)   ; scrolling bar shown on frames right side

      (blink-cursor-mode -1) ; cursor flashes annoyingly
    #+END_SRC

    Create some aliases for functions that're are hard to remember or
    weirdly named or just too long.

    #+BEGIN_SRC emacs-lisp
      (defalias 'yes-or-no-p 'y-or-n-p)
      (defalias 'regexp-string-match #'string-match)

      (defalias 'path-basename                   #'file-name-nondirectory)
      (defalias 'path-dirname                    #'file-name-directory)
      (defalias 'path-extension                  #'file-name-extension)
      (defalias 'path-without-extension          #'file-name-sans-extension)
      (defalias 'path-basename-without-extension #'file-name-base)

      (defalias 'gnu-debugger     #'gdb)
      (defalias 'gud-gnu-debugger #'gud-gdb)
      (defalias 'perl-debugger    #'perldb)
      (defalias 'java-debugger    #'jdb)
    #+END_SRC

*** Config Variables
    #+BEGIN_SRC emacs-lisp
      (defvar load-me-now-duration 120
        "ideal use-package defer duration.
      after you've been inactive for this long, safe to say you
      can load packages that you've deferred.

      This is used for packages which aren't need at startup, but
      more likely then not I'm going to end up requiring them quite
      soon afterwards.")

      (defvar mohkale-man-command (if (windows-p) 'woman 'man)
        "preferred command used for manuals")

      (defun host! (id)
        "check if current host matches ID
      if ID is a string it's matched against the currents hosts
      hostname. otherwise id is looked for in `mohkale-hosts-alist'
      and then compared against. "
        (unless (stringp id)
          (setq id (cdr (assoc id mohkale-hosts-alist))))

        (when id
          (string-equal id (system-name))))

      (setq mohkale-window-map (make-sparse-keymap))
    #+END_SRC

*** Paths Setup
    Set up some ease of use functions for defining paths within the dotemacs namespace.

    #+BEGIN_SRC emacs-lisp
      (if (version<= emacs-version "26.3")
          (require 'cl)
        (require 'cl-lib))

      (defun join-path (root path &rest rest)
        "like python' os.path.join, join a series of paths together."
        (setq path (if (file-name-absolute-p path)
                       path
                     (concat root
                             (unless (string-suffix-p "/" root)
                               "/")
                             path)))
        (if rest (apply 'join-path path rest) path))

      (cl-defmacro dotemacs-initialise-path
          (path-type path &optional &key
                     (alias (intern (concat (symbol-name path-type) "!"))))
        (let* ((path (eval path)) ;; path can be a variable or a string
               (path-type (symbol-name path-type))
               (path-sym (intern (concat "dotemacs-"      path-type "-path")))
               (join-sym (intern (concat "dotemacs-join-" path-type "-path"))))
          `(progn
             (defconst ,path-sym (concat user-emacs-directory ,path))

             (defun ,join-sym (path &rest args)
               ,(concat "join args onto the directory: " path)
               (apply 'join-path ,path-sym path args))

             (when (quote ,alias)
               (defalias (quote ,alias) (symbol-function (quote ,join-sym)))))))
      (put 'dotemacs-initialise-path 'lisp-indent-function 'defun)

      (dotemacs-initialise-path etc "etc")
      (dotemacs-initialise-path bin "bin")
      (dotemacs-initialise-path var "var")
      (dotemacs-initialise-path org "org")
    #+END_SRC

    paths related to the current org file and it's tangled representations.

    #+BEGIN_SRC emacs-lisp :var --mohkale-config-file=(buffer-file-name)
      (require 'bytecomp)

      (defconst mohkale-package-root (bin! "mohkale")
        "path to where any tangled executeable elisp files should reside")

      (defconst dotemacs-file --mohkale-config-file
        "path to my custom user config file.")

      (defconst dotemacs-el-file (concat (file-name-sans-extension dotemacs-file) ".el")
        "path to my emacs entry point after being compiled.")

      (defvar emacs-hosts-file (etc! "hosts")
        "file containing host informating for my hosts")

      (add-hook 'emacs-startup-hook
                (lambda ()
                  "warn me when my init.el file is out of date"
                  (when (file-newer-than-file-p dotemacs-file
                                                dotemacs-el-file)
                    (display-warning 'init
                                     (concat "your configuration file is out of date: "
                                             dotemacs-file)))))

      (defvar mohkale-hosts-alist
        (if (file-exists-p emacs-hosts-file)
            (with-temp-buffer
              (insert-file-contents emacs-hosts-file)
              (read (current-buffer)))
          (warn "hosts config file not found: %s" emacs-hosts-file))
        "list of devices I own.")
    #+END_SRC

    stop emacs from littering over my dotemacs directory by specifying alternative values for
    most paths in packages I've installed (at one point or another). This was inspired by
    [[https://github.com/emacscollective/no-littering/blob/master/no-littering.el][no-littering.el]].

    #+BEGIN_SRC emacs-lisp :results silent
      (with-no-warnings
        (setq
         ;;; Package Directories
         package-user-dir                                   (bin! "elpa/")
         external-packages-directory                        (bin! "misc")

         abbrev-file-name                                   (etc! "abbrev.el")
         auto-insert-directory                              (etc! "auto-insert")
         auto-save-list-file-prefix                         (var! "auto-save" "sessions/")
         bookmark-default-file                              (etc! "bookmarks.el")
         custom-file                                        (etc! "custom.el")
         custom-theme-directory                             (etc! "themes")
         desktop-path                                       `(,(var! "desktop/"))
         diary-file                                         (var! "diary")
         eshell-directory-name                              (var! "eshell")
         eshell-aliases-file                                (var! "eshell" "aliases")
         eshell-login-script                                (etc! "eshell" "loginrc")
         eshell-rc-script                                   (etc! "eshell" "eshrc")
         eww-bookmarks-directory                            (var! "eww/")
         gamegrid-user-score-file-directory                 (var! "gamegrid/")
         ido-save-directory-list-file                       (var! "ido-save-directory-list.el")
         image-dired-db-file                                (var! "image-dired" "db.el") ; tag associations
         image-dired-dir                                    (var! "image-dired/")
         image-dired-gallery-dir                            (var! "image-dired" "gallery/")
         image-dired-temp-image-file                        (var! "image-dired" "temp-image")
         image-dired-temp-rotate-image-file                 (var! "image-dired" "temp-rotate-image")
         kkc-init-file-name                                 (var! "kkc-init.el")
         message-auto-save-directory                        (var! "messages/")
         meghanada-server-install-dir                       (var! "meghanada")
         mohkale-dashboard-banners-directory                (etc! "banners/")
         newsticker-cache-filename                          (var! "newsticker/cache.el")
         newsticker-dir                                     (var! "newsticker/data/")
         nsm-settings-file                                  (var! "nsm-settings.el")
         omnisharp-cache-directory                          (var! "omnisharp/cache")
         org-directory                                      (org! "")
         org-clock-persist-file                             (var! "org/clock-persist.el")
         org-id-locations-file                              (var! "org/id-locations.el")
         org-publish-timestamp-directory                    (var! "org/timestamps/")
         org-registry-file                                  (var! "org/registry.el")
         org-default-notes-file                             (org! "notes.org")
         org-preview-latex-image-directory                  (var! "org/latex")
         package-quickstart-file                            (var! "package-qs.el")
         recentf-save-file                                  (var! "recentf.el")
         save-place-file                                    (var! "save-place.el")
         savehist-file                                      (var! "savehist.el")
         server-auth-dir                                    (var! "server/")
         server-socket-dir                                  server-auth-dir
         shared-game-score-directory                        (var! "gamescore/")
         tramp-auto-save-directory                          (var! "tramp/auto-save/")
         tramp-persistency-file-name                        (etc! "private/tramp/history.el")
         url-cache-directory                                (var! "url/cache/")
         url-configuration-directory                        (var! "url/configuration/")

         ;;; third party
         request-storage-directory                          (var! "requests")
         straight-base-dir                                  (bin! "") ;; weird way to configure it, but okay
         straight-bootstrap-file                            (bin! "straight/repos/straight.el/bootstrap.el")
         ))

    #+END_SRC

    For more complicated path based variables. The previous block let you specify them all on one
    line each... sometimes you may have to define it over multiple lines or give more detail. Thats
    what this is for.

    #+BEGIN_SRC emacs-lisp
      (with-no-warnings
        (setq
         ;;; where do autosave files get stored
         auto-save-file-name-transforms `((".*" ,(var! "auto-save" "sessions/") t))

         ;;; where do backup files get stored
         backup-directory-alist `(("." . ,(var! "backups/")))

         recentf-exclude '("/tmp/"
                           "/ssh:"
                           "/sudo:"
                           ;; ctags
                           "/TAGS$"
                           ;; global
                           "/GTAGS$"
                           "/GRAGS$"
                           "/GPATH$"
                           "COMMIT_EDITMSG"
                           "tmp\\.[^/\\]*$"
                           ;; binary
                           "\\.mkv$"
                           "\\.mp[34]$"
                           "\\.avi$"
                           "\\.docx?$"
                           ;; subtitles
                           "\\.sub$"
                           "\\.srt$"
                           "\\.ass$")))
    #+END_SRC

    Post path setup. Do some stuff with your newly cleaned emacs :smile:.

    #+BEGIN_SRC emacs-lisp
      (push mohkale-package-root load-path)

      (and (file-exists-p custom-file) (load custom-file))

      (setenv "EDITOR"
              (concat "emacsclient --no-wait --suppress-output --server-file '"
                      (expand-file-name server-auth-dir) "server'"))

    #+END_SRC

    Make sure some subset of useful directories exist at startup. This is mostly for crazy
    packages that don't check whether paths exist, before writing to them. **Shame! Shame!
    Shame!**.

    #+BEGIN_SRC emacs-lisp
      (dolist (ensured-path `(,@desktop-path
                              ,external-packages-directory
                              ,dotemacs-org-path
                              ,(var! "org/bin")
                              ,(var! "company/")
                              ,(var! "elfeed/")
                              ,(var! "projectile/")
                              ,(var! "emojify/")
                              ,(var! "lsp/")
                              ,(var! "pdf-tools/")))
        (mkdir ensured-path t))

    #+END_SRC

*** package-initialise
    initialise installed packages and ensure packages needed to setup configuration
    from scratch is installed.

    #+NAME: setup-packages-list
    - which-key
    - bind-map
    - use-package
    - general
    - dash

    #+BEGIN_SRC emacs-lisp :var startup-requires=setup-packages-list
      ;; disable both package.el autloads
      ;; and selected packages in custom.
      (setq package-enable-at-startup  nil
            package--init-file-ensured nil
            package-quickstart         nil)

      (setq
       package-check-signature nil ; 'allow-unsigned
       package-archives
       (append '(("melpa" . "https://melpa.org/packages/")
                 ;; ("org"       . "http://orgmode.org/elpa/")
                 ("gnu"       . "http://elpa.gnu.org/packages/"))))

      (package-initialize) ;; TODO find a way to remove this... without breaking everything
      (defalias 'package--save-selected-packages #'ignore) ;; stop messing with custom.el :P

      (let ((plist-refreshed nil))
        (dolist (package startup-requires)
          ;; iterate for all required packages
          (setq package (intern (car package)))
          (unless (package-installed-p package)
            (unless plist-refreshed
              (package-refresh-contents)
              (setq plist-refreshed t))

            (package-install package))
          (require package)))

      ;; install (then load) the straight package manager.
      ;; ideally I'd like to use straight exclusively, but
      ;; it's really slow when you have a lot of packages.
      (let ((bootstrap-file straight-bootstrap-file)
            (straight-install-dir straight-base-dir)
            (bootstrap-version 5))
        (unless (file-exists-p straight-bootstrap-file)
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp)))
        (load straight-bootstrap-file nil 'nomessage))

      (setq straight-use-package-by-default nil
            use-package-always-ensure       nil
            straight-allow-recipe-inheritance t)
    #+END_SRC

    make use-package evaluate the :defer argument see [[https://github.com/jwiegley/use-package/issues/815][#815]].

    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'use-package
        (advice-add 'use-package-handler/:defer :around
                    (defun use-package-:defer-eval-wait+ (func name keyword arg &rest args)
                      (apply func name keyword (eval arg) args))))
    #+END_SRC

*** External Packages
    Install the following the packages directly each of them are simple files with no
    effective dependencies; retrieve the files and then compare them against their hash
    value +when given+. If the simple hash check fails, cancel them.

    #+NAME: non-melpa-packages
    | name                | hash            | url                                                                                       |
    |---------------------+-----------------+-------------------------------------------------------------------------------------------|
    |                     | <15>            |                                                                                           |
    | hide-comnt          | 9668645eab1fd8d223967ab90d3d34fe6e98aa3af47516f45e18f094137d7c6c | https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/hide-comnt.el          |
    | imenu-tree          | c4b3ae0d8b5c3e5a50c9c4b3f96fd48e309c2fae9a8902a1d649063c7b3b611c | https://www.emacswiki.org/emacs/download/imenu-tree.el                                    |
    | help-fns+           | e12cc9a3c7bd41ffd5be61a6d7b3f01c4ef094241683f6004fcd5cc5b9b2e51d | https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/help-fns%2B.el         |
    | lorem-ipsum         | 54cb139d6c88632aaef6364a2a6c6cadbb9a5082eb5032e69b5139dcc7074d88 | https://www.emacswiki.org/emacs/download/lorem-ipsum.el                                   |
    | profile-dotemacs    | 1d903fc16d4ab4716cf8097ddb88a5cbb3746c9e49fa3421ae147b0c383c3e7f | http://www.randomsample.de/profile-dotemacs.el                                            |
    | open-junk-file      | c0b835b329758dced4ccae6c2f3fd5af16af929437110ddde00ea55dc7d47be3 | https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/open-junk-file.el      |
    | sqlite-dump         | 8277c32f3e9dad7f760b946609c918dd51f32990137f839a000fb6ff5a049939 | https://user42.tuxfamily.org/sqlite-dump/index.html                                       |
    | company-cmake       | 4d682308eb4f6a4be92a4b7dcb2d181b5c26b4337799de0a308969d8babef0a2 | https://raw.githubusercontent.com/purcell/company-cmake/master/company-cmake.el           |
    | transpose-frame     | a40264a07b25d2c1d8d1be341d42952329d1bbfab8c23100904627fef4f4c7b8 | https://www.emacswiki.org/emacs/download/transpose-frame.el                               |
    | hs-lint             | 61bf6d3cfd43f2729d85ed407a7de5fd6b025540229bc0b57c37785d0b6d7450 | https://raw.githubusercontent.com/ndmitchell/hlint/master/data/hs-lint.el                 |
    | hlint-refactor-mode | 55d5a9e99f0384b15eacfdf2b17ae313c6ddbb0343980ed324707fcaaf2b718a | https://raw.githubusercontent.com/mpickering/hlint-refactor-mode/master/hlint-refactor.el |
    | miniedit            | c632c33c099362b084d965c51ec4b933be1278c7064096ce3b97cc830436055b | https://raw.githubusercontent.com/emacsmirror/miniedit/master/miniedit.el                 |
    | ibuffer-persp       | 6395294e2dd368866d79a81d37c27961e0f871937ccd82cff317e5ad67c52652 | https://raw.githubusercontent.com/rakshasa/ibuffer-persp/master/ibuffer-persp.el          |
    | org-link-edit       | ac84061d951ef9ef82794ba7f4416afb6da4283a182490a11ae455077321814c | https://raw.githubusercontent.com/kyleam/org-link-edit/master/org-link-edit.el            |
    | hydra-posframe      | a828d588082f0f011459f13aecf04e8a610ab150c566b6a18cd279c006a881a3 | https://raw.githubusercontent.com/Ladicle/hydra-posframe/master/hydra-posframe.el         |
    | org-man             | 9a98ad950304cc2f195298d8a62a668365b8aedb98cfb45b2bfdb475f51239b9 | https://raw.githubusercontent.com/aspiers/orgmode/master/contrib/lisp/org-man.el          |

    #+BEGIN_SRC emacs-lisp :var package-list=non-melpa-packages
      (defun external-packages/download-external-package (url dest-path)
        (let* ((dest-buffer (get-buffer-create "*external-packages*"))
               (download-args `("curl"              ; program
                                nil                 ; input file
                                ,dest-buffer        ; output dest
                                nil                 ; redisplay?
                                ; args
                                "-L"
                                "-o" ,dest-path
                                ,url))
               exit-code)
          (with-current-buffer dest-buffer
            (insert (format "curl: %s\n"
                            (nthcdr 4 download-args)))
            (setq exit-code (apply 'call-process download-args))
            (insert "\n"))

          exit-code))

      (defun external-packages/validate-package-hash (file dest-path hash)
        (let (result)
          (if (string-equal "" hash)
              (progn
                (display-warning 'external-packages (format "package %s has no hash check given: %s"
                                                            file
                                                            url))
                (setq result t))
            (with-temp-buffer
              (insert-file-contents dest-path)
              (let ((hash-result (secure-hash 'sha256 (buffer-string))))
                (if (string-equal hash hash-result)
                    (setq result t)
                  (display-warning 'external-packages (format "package %s failed with hash: %s != %s"
                                                              file
                                                              hash
                                                              hash-result))
                  (delete-file dest-path)))))
          result))

      (let ((install-path external-packages-directory)
            failed-installs)
        (push install-path load-path)
        ;; include packages in load path

        (dolist (row package-list)
          (let* ((file (nth 0 row))
                 (hash (nth 1 row))
                 (url  (nth 2 row))
                 (dest-path (expand-file-name (join-path install-path (concat file ".el"))))
                 download-args exit-code)
            (unless (or (string-equal "" file)
                        (string-equal "" url))
              (unless (file-exists-p dest-path) ;; only download when doesn't already exist
                (unless (and (zerop (external-packages/download-external-package url dest-path))
                             (external-packages/validate-package-hash file dest-path hash))
                  (push file failed-installs))))))

        (if (eq failed-installs nil)
            (let ((buffer (get-buffer "*external-packages*")))
              (and buffer
                   (kill-buffer buffer))) ;; kill process buffer when nothing failed
          (display-warning :warning (format "external-package : failed to download packages: %s" failed-installs))
          ))
    #+END_SRC

** leader
   replicate some +basically all+ the built in spacemacs leader features &
   keys... cause why fix what's not broken.

   #+BEGIN_SRC emacs-lisp
     (use-package spaceleader
       :demand   t
       :straight (spaceleader :type git :host github :repo "mohkale/spaceleader")
       :config
       (require 'spaceleader-base)

       (general-define-key
         :keymaps 'override
         :states leader-norm-states
         "C-," (eval
                `(general-simulate-key
                   ,(concat leader-key " " leader-major-mode-prefix))))

       (general-define-key
         :keymaps 'override
         :states leader-nnorm-states
         "C-," (eval
                `(general-simulate-key
                   ,(concat leader-nnorm-key " " leader-major-mode-prefix))))

       (general-define-key
         :states leader-norm-states
         "C-SPC" (eval
                  `(general-simulate-key ,leader-key))))
   #+END_SRC

*** global-leaders
    #+BEGIN_SRC emacs-lisp
      (leader/set-keys
        "TAB" "last-buffer"
        "TAB" 'switch-to-last-buffer

        ;; "<C-tab>" 'indent-back-to-normal ;; C-TAB doesn't work
        "U" 'universal-argument
        "u" 'smart-universal-argument)

      (general-define-key
        :keymaps 'universal-argument-map
        "M-u" 'universal-argument-batch-increment
        "M-U" 'universal-argument-batch-decrement)

      (leader/set-keys
        "aE" 'package-list-packages)

      (leader/set-keys
        "be" 'safe-erase-buffer
        "bK" 'kill-this-buffer
        "bk" 'kill-this-buffer-and-window-maybe
        "bM" 'switch-to-messages-buffer
        "by" 'copy-whole-buffer-to-clipboard)

      (leader/set-keys
        "cd" 'close-compilation-window ;; WARN not yet implemented
        "cb" 'display-compilation-buffer
        "cy" 'yank-and-comment
        "cc" 'compile)

      (leader/set-keys
        "f~" 'write-backup
        "fa" 'write-autosave
        "fD" 'delete-buffer-file
        "fR" 'rename-buffer-file
        "fy" 'show-and-copy-buffer-file-name
        "f%" 'show-and-copy-buffer-file-basename
        ;; "fo" 'open-file-or-directory-in-external-app ;; TODO implement
      )

      (leader/set-keys
        "hdl" 'describe-last-keys ;; WARN not yet implemented
        )

      (leader/set-keys
        "i"  "insert"
        "ij" 'custom-insert-line-below
        "ik" 'custom-insert-line-above)

      (leader/set-keys "j" "jump")

      (leader/set-keys
        "Md" "dired"
        ;; TODO bind in dired
        "Mdd" 'toggle-editable-dired
        "Mde" 'invoke-editable-dired
        "Md <escape>" 'wdired-abort-changes
        "Mdq" 'wdired-abort-changes
        )

      (defvar mohkale-minor-mode-leader-key "q"
        "leader key for minor mode bindings.
      this leader prefix is expected to be muddled and unreliable...
      due to tonnes of different minor modes collabratively binding to it.
      That said... I need a place to put minor-mode keys and this was
      unoccupied.")

      (leader/set-keys
        "xf" 'list-faces
        "xc" 'evil-capitalize
        "xp" 'pad-line-with-space-to-length
        "xP" 'pad-line-with-char-to-length
        "xt" 'remove-all-trailing-whitespace
        )

      (leader/set-keys
        "t TAB" 'set-indent-offset
        "th" 'toggle-buffer-header
        "tL" 'toggle-lexical-binding
        "tr" 'toggle-relative-linum)

      (leader/set-keys
        "w" "windows"
        "w" mohkale-window-map)
    #+END_SRC

** Global Bindings
   #+BEGIN_SRC emacs-lisp
     (general-unbind
       "M-h" ;; was backward-kill-sentence
       "C-M-\\" ;; was indent-region
       "C-k")

     (general-define-key
       ;; "ESC" nil ;; WARN never do this... it broke everything

       ;; Control     for comamnd,
       ;; Meta        for command on region
       ;; Control-Alt for command on buffer
       "C-|"             'shell-command
       "M-|"             'shell-command-on-region
       "C-M-|"           'shell-command-on-buffer
       "C-&"             'async-shell-command
       "M-&"             'async-shell-command-on-region
       "C-M-&"           'async-shell-command-on-buffer

       "C-z" 'suspend-frame

       "C-@" (general-simulate-key "C-SPC") ;; C-SPC in terminal

       ;; rebound to default-indent-new-line in emacs>=27 and that's
       ;; bugged out in org mode.
       "C-M-j" 'indent-new-comment-line

       "M-l"             'recenter-top-bottom ;; was kill-sentence
       "M-L"             'downcase-word
       "M-H"             'upcase-word
       "C-M-a"           'mark-whole-buffer
       "C-/"             'toggle-comment-at-point
       "C-S-/"           'toggle-comment-at-point-alt
       "C-M--"           'indent-region
       "C-M-h"           'left-word
       "C-M-l"           'right-word
       "M-j"             'custom-insert-line-below
       "M-k"             'custom-insert-line-above
       "M-r"             'revert-buffer
       "C-q"             'quit-window
       "C-v"             'quoted-insert
       "C-j"             'newline-and-indent
       "C-<tab>"         'next-buffer
       "C-S-<tab>"       'previous-buffer
       "C-<iso-lefttab>" 'previous-buffer
       "RET"             'newline-and-indent
       "<C-M-return>"    'comment-indent-new-line
       "<C-backspace>"   'evil-delete-backward-word)

     (general-define-key
       :states 'motion
       "q" 'quit-window)

     (general-define-key
       :states leader-norm-states
       "gr"    'revert-buffer
       "gR"    'read-only-mode
       "gz"    'recenter-top-bottom)

     (general-define-key
       :states leader-nnorm-states
       ;; "S-SPC" 'insert-whitespace-after-point
       "M-DEL"   'delete-forward-char
       "<C-S-backspace>" 'kill-word)

     (general-define-key
       "C-w" '(:prefix-command mohkale-window-map
                               :which-key "windows"))

     (general-define-key
       :keymaps 'mohkale-window-map
       "m"   'window-zen
       "RET" 'window-zen
       ; "C-m" 'window-zen
       "M"   'window-zen-restore
       "M-m" 'window-zen-restore)

     (defmacro defun-save-excursion-insert-char (char-name char)
       (setq char (eval char))

       (let* ((char-name (symbol-name char-name))
              (func-name (intern (concat "save-excursion-insert-" char-name))))
         `(defun ,func-name (prefix)
            (interactive "P")
            (save-excursion
              (insert-char ,char (prefix-numeric-value prefix))))))

     (general-define-key
       :states leader-nnorm-states
       "S-M-SPC" (defun-save-excursion-insert-char space ? ))
   #+END_SRC

** Mohkale
*** Happy Birthday
    animate-birthday-present on your birthday... yippeee :)

    #+BEGIN_SRC emacs-lisp
      (when (string-equal (format-time-string "%d.%m" (current-time))
                          "08.12")
        (add-hook 'emacs-startup-hook 'animate-birthday-present))
    #+END_SRC

*** Syntax
    Adjust the syntax entries for the given modes so that functions like evil word
    skip over them.

    #+NAME: underscore-supported-modes
    - c++
    - c
    - markdown
    - lisp
    - shell
    - enh-ruby

    #+BEGIN_SRC emacs-lisp :var modes=underscore-supported-modes
      (defun mohkale//adjust-syntax-entry ()
        "includes underscores in the syntax entry"
        (modify-syntax-entry ?_ "w"))

      (dolist (mode modes)
        (let ((hook-name (concat (car mode) "-mode-hook")))
          (add-hook (intern hook-name) #'mohkale//adjust-syntax-entry)))
    #+END_SRC

** Setup/Methods
   Define methods for a bunch of purposes within the configuration here.

*** Lib
    basic syntax sugar functions, inspired by [[https://github.com/hlissner/doom-emacs/blob/develop/core/core-lib.el][doom]].

    #+BEGIN_SRC emacs-lisp
      (defmacro lambda! (&rest body)
        "Expands to (lambda () (interactive) ,@body).
      A factory for quickly producing interaction commands, particularly for keybinds
      or aliases."
        (declare (doc-string 1) (pure t) (side-effect-free t))
        `(lambda () (interactive) ,@body))

      (defmacro plist-pop! (list prop &optional default)
        "delete PROP from plist LIST, returning value of PROP.
      if PROP isn't in LIST, DEFAULT will be returned."
        `(prog1
             (or (plist-get ,list ,prop) ,default)
           (cl-remf ,list ,prop)))

      (defun keyword-sym-normalise! (sym)
        "convert a keyword symbol, SYM, to a non-keyword symbol.
      eg. (keyword-sym-normalise! :hello) ;; => 'hello"
        (let ((sym-string (symbol-name sym)))
          (if (string-prefix-p ":" sym-string)
              (intern (substring sym-string 1))
            sym)))

      (cl-defmacro plist-bind! ((list &rest props) &rest body)
        "declare local bindings in BODY using a property list LIST.
      This functions exists as an alternative to `cl-defmacro's very limited support
      for variable argument lists alongside keyword argument lists. A use case I've
      encountered so often, it merited creating this.

      This function accepts a LIST argument and then a bunch of property specifications.
      For every property in PROPS, that property is popped from LIST and then included
      in the local scope of BODY. A property can be specified as an ALIST, in which case
      the `car' of the list is the property name and the `cdr' is the default value for
      the property.

      WARN LIST should be an identifier for a list variable... not a LIST by itself.

      The remaining value of LIST is all the properties which were not provided in the
      spec.
      "
        `(let* ((,list (cl-copy-list ,list))
                ,@(cl-loop for prop in props
                           with default = nil
                             when (listp prop)
                               do (setq default (cdr prop) prop (car prop))
                             end
                             collect (list (keyword-sym-normalise! prop)
                                           `(plist-pop! ,list ,prop ,default))))
           ,@body))
      (put 'plist-bind! 'lisp-indent-function 'defun)

      ;; source [[https://www.emacswiki.org/emacs/DestructiveOperations#toc4][Destructive Operations]].
      (defun nconc-safe (ls1 ls2)
        "`nconc', but avoids creating circular lists."
        (let ((tail ls1))
          (while (and (cdr tail) (not (eq tail ls2)))
            (setq tail (cdr tail)))
          (unless (eq tail ls2)
            (if (null tail)
                (setq ls1 ls2)
              (setcdr tail ls2)))
          ls1))
    #+END_SRC

**** Misc
     #+BEGIN_SRC emacs-lisp
       (use-package mohkale-core
         :defer t
         :commands (with-no-write-messages))
     #+END_SRC

     Still core functions... just not so essential that they should be loaded at startup.

    #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale-core.el
      (defmacro with-no-write-messages (&rest body)
        "execute BODY while supressing \"Wrote: file\" messages"
        `(let ((save-silently t))
           ;; replace the VISIT argument of write-region with something
           ;; that'll supress the write message
           (cl-letf* (((symbol-function 'actual-write-region)
                       (symbol-function 'write-region))
                      ((symbol-function 'write-region)
                       (lambda (a b c &optional d &rest args)
                         (apply #'actual-write-region a b c d 'nomsg (cdr args)))))
             ,@body)))
      (put 'with-no-write-messages 'lisp-indent-function 'defun)

    #+END_SRC

*** Mohkale
    User related functions. Find users dot file or some specific org files.

   #+BEGIN_SRC emacs-lisp
     (use-package mohkale
       :straight (mohkale :type built-in)
       :defer load-me-now-duration
       :commands (mohkale/eval-dotfile-file
                  mohkale/find-dotfile-file
                  mohkale/find-tangled-dotfile-file)
       :init
       (setq mohkale--server-leader-key "y")

       (leader/set-keys
         "fec" '("find-dotfile" . mohkale/find-dotfile-file)
         "fel" '("eval-dotfile" . mohkale/eval-dotfile-file)
         "fet" '("find-tangled-dotfile" . mohkale/find-tangled-dotfile-file)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale.el
     (defmacro mohkale/defun-mohkale-find-package-file (file-type file-path &optional root)
       (setq file-path (eval file-path))

       (when root
         (setq file-path (concat (eval root) "/" file-path)))

       (let ((func-name (intern (concat "mohkale/find-" (symbol-name file-type) "-file"))))
         `(defun ,func-name (&optional prefix)
            (interactive "P")
            (if (not (file-exists-p ,file-path))
                (progn
                  (if (not prefix)
                      (error (concat "mohkale(error) : mohkale-find-file file not found: " ,file-path))
                    (make-directory (file-name-directory ,file-path))
                    (find-file ,file-path)))
              (find-file ,file-path)))))

     (mohkale/defun-mohkale-find-package-file dotfile         dotemacs-file)
     (mohkale/defun-mohkale-find-package-file tangled-dotfile dotemacs-el-file)

     (defun mohkale/eval-dotfile-file ()
       (interactive)
       (org-babel-load-file dotemacs-file))

     (provide 'mohkale)
   #+END_SRC

*** File
    #+BEGIN_SRC emacs-lisp
      (use-package mohkale-file
        :straight (mohkale-file :type built-in)
        :defer load-me-now-duration
        :commands (rename-buffer-file
                   delete-buffer-file
                   show-and-copy-buffer-file-name
                   show-and-copy-buffer-file-basename
                   write-kill-buffer
                   write-backup
                   write-autosave
                   jump-to-directory
                   jump-to-directory-other-window)
        :init
        (leader/set-keys
          "fj" 'jump-to-directory
          "jd" 'jump-to-directory
          "jD" 'jump-to-directory-other-window))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale-file.el
      (defun rename-buffer-file (buffer &optional new-name)
        "renames the file associated with the buffer BUFFER.
      if the buffer isn't visiting a file or the visited file
      doesn't exist on disk, this function is equivalent to
      simply changing the visited file name for BUFFER."
        (interactive (list (current-buffer)))

        (or new-name
            (setq new-name (read-file-name "new-name: ")))

        (let* ((buffer-file (buffer-file-name buffer))
               (modified-p (buffer-modified-p buffer))
               (directory (file-name-directory new-name))
               (src-exists (file-exists-p buffer-file))
               (dst-exists (file-exists-p new-name)))
          (with-current-buffer buffer
            ;; destination doesn't exist, so can write
            ;; or
            ;; user agrees to overwrite, so can write
            (when (or (not dst-exists)
                      (yes-or-no-p "file already exists, overwrite it:"))
              ;; only rename buffer file if it exists
              (when (and buffer-file src-exists)
                (unless (file-directory-p directory)
                  (mkdir directory t))
                (rename-file buffer-file new-name t)
                (message "moved file '%s' to '%s'" buffer-file new-name))

              (set-visited-file-name new-name)
              (set-buffer-modified-p modified-p)))))

      (defun delete-buffer-file ()
        (interactive)
        (let ((buffer (current-buffer))
              (filename (buffer-file-name))
              (name (buffer-name)))
          (if (not filename)
              (message "buffer %s is not visiting a file" name)
            (when (yes-or-no-p "Are you sure you want to delete this file? ")
              (when (file-exists-p filename)
                (delete-file filename t))

              (kill-buffer buffer)))))

      (defun smart-buffer-file-name ()
        (or (buffer-file-name)
            (cond
             ((derived-mode-p 'dired-mode)
              (string-trim-right (dired-current-directory) "/")))))

      (defun show-and-copy-buffer-file-basename (&optional prefix)
        (interactive "P")
        (let ((bufname (file-name-nondirectory (or (smart-buffer-file-name) ""))))
          (when (consp prefix)
            (if (eq (car prefix) 4)
                (insert bufname)
              (save-excursion
                (insert bufname))))
          (message bufname)
          (kill-new bufname)))

      (defun show-and-copy-buffer-file-name (&optional prefix)
        "Displays the current buffers name in the echo area & yanks it
      when a prefix arg is given, the buffer name is also inserted into
      the buffer. When a double prefix arg is given, the filename is
      inserted but the point is not moved. With a positive numerical
      prefix greater than 0, that many parent directories will be
      navigated to before yanking."
        (interactive "P")
        (let ((bufname (or (smart-buffer-file-name) "")))
          (cond
           ((consp prefix)
            (if (eq (car prefix) 4)
                (insert bufname)
              (save-excursion
                (insert bufname))))
           (prefix
            (while (and (> prefix 0)
                        bufname)
              (setq bufname (string-trim-right (file-name-directory bufname) "/")
                    prefix  (- prefix 1)))

            (or bufname (setq bufname ""))))

          (message bufname)
          (kill-new bufname)))

      (defalias 'jump-to-directory 'dired-jump)
      (defalias 'jump-to-directory-other-window 'dired-jump-other-window)

      (cl-defun write-backup (&optional prefix (silent t))
        "manually force emacs to backup the current buffer.
      By default doesn't do anything when the current buffer hasn't been modified.
      Pass a single-prefix `C-u` to force backing-up even if the buffer has not been
      modified. Pass two prefixes `C-u C-u`to backup the buffer and then save; this
      in affect backs up the last save and then saves the current buffer."
        (interactive "P")
        (let* ((modified (buffer-modified-p))
               (save-after (and (listp prefix)
                                (eq (car prefix) 8)))
               (save-before (and (not save-after)
                                 modified)))
          (if (and (not prefix)
                   (not modified))
              (or silent
                  (message "buffer not modified since last save"))
            (or save-before (save-buffer))

            ;; buffer-backed-up is permenently buffer-local so you have to account
            ;; for when it's already been backed up and when you first back it up.
            (if buffer-backed-up
                (let (buffer-backed-up)
                  (backup-buffer))
              (backup-buffer))

            (or save-after (save-buffer)))))

      (defalias 'write-autosave 'do-auto-save)

      (defun write-kill-buffer (&optional buffer-or-name confirm)
        "write buffer to file and then kill it"
        (interactive)
        (let ((buffer (get-buffer (or buffer-or-name (current-buffer)))))
          (when (buffer-modified-p)
            (write-file (or (buffer-file-name) (read-file-name "write file: "))
                        confirm))

          (when (or (not confirm)
                    (y-or-no-p (format "are you sure you want to kill this buffer (%s): " buffer)))
            (let ((window (get-buffer-window buffer)))
              (kill-buffer buffer)
              (when (and window (> (length (window-list)) 1))
                (delete-window window))))))

      (provide 'mohkale-file)
    #+END_SRC

*** Hooks/Handlers
    #+BEGIN_SRC emacs-lisp
      ;; (defun no-junk-please-were-unixish ()
      ;;   "auto convert found files to use unix EOL formats"
      ;;   (let ((coding-str (symbol-name buffer-file-coding-system)))
      ;;     (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
      ;;       (set-buffer-file-coding-system 'unix))))

      ;; (add-hook 'find-file-hook 'no-junk-please-were-unixish)
    #+END_SRC

    prevent annoying error messages when you try to go before the start of the buffer
    or off the end of the buffer.

    #+BEGIN_SRC emacs-lisp
      (setq command-error-function
            (defun mohkale--command-error-function (data context caller)
              "hide some error message"
              (when (not (memq (car data) '(;; buffer-read-only
                                            beginning-of-buffer
                                            end-of-buffer)))
                (command-error-default-function data context caller))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defun inhibit-messages-wrapper (func &rest args)
        (let ((inhibit-message t))
          (apply func args)))

      ;;; switch to buffer hook
      (defvar switch-to-buffer-hook nil
        "hook run when you switch to a buffer.")

      (advice-add 'switch-to-buffer
                  :after (defun switch-to-buffer--execute-hook (&rest args)
                           (apply 'run-hook-with-args 'switch-to-buffer-hook args)))

      ;;; theme loading hook
      (defvar after-load-theme-hook nil
        "hook which is executed after loading a theme")

      (advice-add 'load-theme
                  :after (defun load-theme-execute-hooks (&rest args)
                           (run-hooks 'after-load-theme-hook)))
    #+END_SRC

    Configure displaying of trailing whitespace. Now I personally am not a fan of source code
    with invisable trailing whitespace, it takes up meaningless space ([[https://www.youtube.com/watch?v=SsoOG6ZeyUI][insert completely unrelated
    video here]]) and probably annoys the hell out of other people with editors smart enough to
    see it.

    So I enable displaying of trailing whitespace by default in every mode. That way you can
    see and remove it. If you'd like to disable whitespace display, then you'll have to append
    to either of the following variables.

    #+BEGIN_SRC emacs-lisp
      (defvar whitespace-exempt-modes '(help-mode
                                        Buffer-menu-mode
                                        ibuffer-mode
                                        eshell-mode
                                        term-mode
                                        minibuffer-inactive-mode
                                        eshell-mode)
        "modes under which no trailing whitespace is shown")

      (defvar whitespace-exempt-buffers
        (list (rx "*Ibuffer confirmation*")
              (rx "*Org Export Dispatcher*"))
        "regular expressions matching buffer names under which no trailing
      whitespace is shown.")

      (defun chain-match-regexp (string &rest regexps)
        "checks for string-match against STRING using regexps
      returns true if any of the regexps match the string."
        (let (match-found regexp)
          (while (and (not match-found)
                      (setq regexp (car regexps)))
            (setq match-found (string-match-p regexp string)
                  regexps (cdr regexps)))
          (not (not match-found))))

      (defun set-trailing-whitespace--mode-based (&optional dont-set)
        "check the mode of the current buffer, to see whether trailing
      whitespace should be shown. with the optional parameter `dont-set'
      trailing whitespace will not be set.

      This function returns what the desired value of `show-trailing-whitespace'
      should be."
        (let ((show (not (and whitespace-exempt-modes
                              (apply 'derived-mode-p
                                     whitespace-exempt-modes)))))
          (prog1
              show
            (unless dont-set
              (setq show-trailing-whitespace show)))))

      (defun set-trailing-whitespace--name-based (&optional dont-set)
        "check the name of the current buffer, to see whether trailing
      whitespace should be shown. see `set-trailing-whitespace--mode-based'."
        (let ((show (not (and whitespace-exempt-buffers
                              (apply 'chain-match-regexp
                                     (buffer-name)
                                     whitespace-exempt-buffers)))))
          (prog1
              show
            (unless dont-set
              (setq show-trailing-whitespace show)))))

      (defun mohkale/set-trailing-whitespace (&rest args)
        (setq show-trailing-whitespace
              ;; when both name and mode decide you can show
              ;; whitespace, then show it. otherwise when at
              ;; least one says no, then hide it.
              (and (set-trailing-whitespace--mode-based t)
                   (set-trailing-whitespace--name-based t))))

      ;; add switch-to-buffer hook because some functions, such as ibuffers confirmation
      ;; popup use switch-to-buffer instead of display buffer and there's no easy way
      ;; to modify it.
      (add-hook 'switch-to-buffer-hook #'mohkale/set-trailing-whitespace)
      (add-hook 'after-change-major-mode-hook (lambda (&rest args)
                                                (set-trailing-whitespace--mode-based)))
    #+END_SRC

    Configure the preferred indentation for buffers. Emacs doesn't really have a nice builtin
    way to do this across multiple modes. I got tired of always having to remember special
    variables for each mode so I've defined the following alist to store indent configurations
    and a command ~set-indent-offset~ which automatically (or manually sets the desired
    indent).

    TODO no way to set indent in a directory local way.

    #+BEGIN_SRC emacs-lisp
      ;; indent configuration
      (defvar mohkale-indent-config '((t . 4))
        "alist configuring preferred indentation for buffers.
      the car of an entry is used to match which buffer it's applied to
      and cdr is used to determine the value of it.

      the car can be a symbol, a string, a function or some expression
      which evaluates to t. if it's a symbol, the major mode of the
      buffer is compared against it. if it's a string the name of the
      buffer is matched against it.

      the cons can be a number, a function or some expression which
      evaluates to a number.

      NOTE: indentation is set exclusively when a buffer-mode change
            occurs, changing the buffer name doesn't alter the indent.
      ")

      (defun set-indent-offset (&optional indent)
        "set the indentation level of the current buffer.
      this method uses `mohkale-indent-config' to determine what
      the indentation of the current buffer should be and then sets
      it. Also setting any mode dependent, specific indent bindings,
      alongside it.

      You can pass a specific value for the indent as an argument and
      the current buffers indentation will be set to that."
        (interactive "Nindent: ")
        (let* ((buffer (current-buffer))
               (buffer-name (buffer-name buffer)))
          (setq indent
                (or indent
                    (cl-loop
                     with matcher = nil
                     with indent  = nil
                     for cfg in mohkale-indent-config
                     do (setq matcher (car cfg))
                     if (cond
                         ((eq matcher t) t)
                         ((symbolp matcher)
                          (eq matcher major-mode))
                         ((stringp matcher)
                          (string-match-p matcher buffer-name))
                         ((functionp matcher)
                          (funcall matcher))
                         (t (eval matcher)))
                       do (setq indent (cdr cfg))
                       and return (if (functionp indent)
                                      (funcall indent)
                                    indent))))

          (if (not indent)
              (message "set-indent-offset::warn() unable to determine indent for current buffer.")
            (setq evil-shift-width indent)
            (setq-local tab-width indent)

            (when (= 0 (% indent 2))
              (setq-local tab-stop-list (number-sequence indent 40 indent)))

            (when (bound-and-true-p emmet-mode)
              (setq emmet-indentation indent))

            ;; major mode dependent configurations
            (cl-case major-mode
             ('python-mode
              (setq-local python-indent-offset indent))
             ('js-mode
              (setq-local js-indent-level indent))
             ('ruby-mode
              (setq-local ruby-indent-level indent))
             ('enh-ruby-mode
              (setq-local enh-ruby-indent-level indent))
             ('c-mode
              (setq-local c-basic-offset indent))
             ('plantum-mode
              (setq-local plantuml-indent-level indent))
             ('yaml-mode
              (setq-local yaml-indent-offset indent))
             ('latex-mode
              (setq-local LaTeX-indent-level indent))
             ('web-mode
              (setq-local css-indent-offset indent)
              (setq-local web-mode-markup-indent-offset indent)
              (setq-local web-mode-css-indent-offset indent)
              (setq-local web-mode-code-indent-offset indent))))))

      (add-hook 'after-change-major-mode-hook #'set-indent-offset)

    #+END_SRC

    Auto clear the echo area after a certain idle interval. Why? because emacs has a tendency
    to hang when doing a lot of tasks (eg. updating packages). When this package installation
    finished emacs keeps the last message in the minibuffer meaning the only way to tell if
    emacs is ready to carry on is to hit a key. I can't count the number of times I've just
    stood around for 2 minutes wondering when it'll be done, only to find it finished a while
    ago and I just didn't recieve any notification :angry:.

    A neat idea, but feels like more hassle than it's worth. Maybe recheck if I face any more
    issues where this would come in useful.

    #+BEGIN_SRC emacs-lisp :tangle no
      ;; auto clear echo area after given delay... when the echo area just
      ;; remains static for a while, I can't tell whether emacs is still
      ;; working or is active and just waiting for input. This should make
      ;; it clearer after a little while.
      (defun clear-echo-area ()
        (message nil))

      (defvar auto-clear-echo-area-interval 5
        "clear the echo area after this many seconds have elapsed.
      set to nil to not disable echo area auto clear.")

      (defvar auto-clear-echo-area--timer nil)

      (advice-add 'message :after
                  (defun auto-clear-echo-area (string &rest args)
                    (when (and string
                               auto-clear-echo-area-interval)
                      (when auto-clear-echo-area--timer
                        (cancel-timer auto-clear-echo-area--timer))

                      (setq auto-clear-echo-area--timer
                            (run-with-idle-timer
                             auto-clear-echo-area-interval
                             nil
                             #'clear-echo-area)))))

      ;; eldoc should't be removed after idle delay... it's designed to be looked at.
      (advice-add 'eldoc-message :around
                  (defun eldoc-message--disable-auto-clear-echo-area (func &rest args)
                    (when auto-clear-echo-area--timer
                      ;; cancel any existing timers beforehand.
                      (cancel-timer auto-clear-echo-area--timer)
                      (setq auto-clear-echo-area--timer nil))

                    (let (auto-clear-echo-area-interval) ;; disable interval
                      (apply func args))))
    #+END_SRC

*** Yank Indent Adjust
    adjust indentation of yanked text in some modes... because doing so manually is
    a pain :tongue:.

    #+BEGIN_SRC emacs-lisp
      ;; initially sourced from, the venerable, [[https://github.com/magnars/.emacs.d/blob/master/defuns/editing-defuns.el#L99-L124][magnars]]
      (require 'dash)

      (defvar yank-indent-modes '(prog-mode
                                  sgml-mode
                                  js2-mode)
        "Modes in which to automatically indent regions that are yanked (or yank-popped).")

      (defvar yank-advised-indent-threshold 1000
        "Threshold (# chars) over which indentation does not automatically occur.")

      (defun yank-advised-indent-function (beg end)
        "Do indentation, as long as the region isn't too large."
        (if (<= (- end beg) yank-advised-indent-threshold)
            (indent-region beg end nil)))

      (defmacro with-auto-indent-satisfied (prefix-var &rest body)
        `(when (and (not ,prefix-var)
                    (--any? (derived-mode-p it) yank-indent-modes))
           ,@body))
      (put 'with-auto-indent-satisfied 'lisp-indent-function 'defun)

      (defun yank--auto-indent (&optional arg)
        "if mode is in `yank-indent-modes' indent yanked text
      doesn't do anything if a prefix arg is given."
        (with-auto-indent-satisfied arg
          (let ((transient-mark-mode nil))
            (yank-advised-indent-function
             (region-beginning) (region-end)))))

      (advice-add 'yank     :after #'yank--auto-indent)
      (advice-add 'yank-pop :after #'yank--auto-indent)

      (defun evil-visual-paste--auto-indent (count &optional register yank-handler)
        ;; not sure what yank handler is for, leave it in, to avoid errors
        "same as `yank--auto-indent', but for evil visual yank replace."
        (with-auto-indent-satisfied register
          (let ((transient-mark-mode nil))
            (yank-advised-indent-function
             (region-beginning) (region-end)))))

      (advice-add 'evil-visual-paste :after #'evil-visual-paste--auto-indent)
      (advice-add 'evil-paste-after  :after #'evil-visual-paste--auto-indent)
      (advice-add 'evil-paste-before :after #'evil-visual-paste--auto-indent)

      (defun yank-unindented ()
        (interactive)
        (yank 1))
    #+END_SRC

*** Display Functions
    #+BEGIN_SRC emacs-lisp
      (use-package mohkale-display-buffer-functions
       :defer t
       :commands (display-buffer--maybe-same-window-and-focus
                  display-buffer--maybe-pop-up-frame-or-window-and-focus
                  display-buffer-reuse-window-and-focus
                  display-buffer-in-previous-window-and-focus
                  display-buffer-in-side-window-and-focus
                  display-buffer-use-some-window-and-focus
                  display-buffer-pop-up-frame-and-focus
                  display-buffer-below-selected-and-focus
                  display-buffer-left
                  display-buffer-right
                  display-buffer-left-and-focus
                  display-buffer-right-and-focus))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale-display-buffer-functions.el
      (defmacro display-buffer--create-focus-method (func)
        `(defun ,(intern (concat (symbol-name func) "-and-focus")) (buffer alist)
           (let ((window (,func buffer alist)))
             (when window
               (select-window window)))))

      (display-buffer--create-focus-method display-buffer--maybe-same-window)
      (display-buffer--create-focus-method display-buffer-reuse-window)
      (display-buffer--create-focus-method display-buffer--maybe-pop-up-frame-or-window)
      (display-buffer--create-focus-method display-buffer-in-previous-window)
      (display-buffer--create-focus-method display-buffer-in-side-window)
      (display-buffer--create-focus-method display-buffer-use-some-window)
      (display-buffer--create-focus-method display-buffer-pop-up-frame)
      (display-buffer--create-focus-method display-buffer-below-selected)

      ;; See also: https://stackoverflow.com/questions/21542914/make-buffer-list-always-appear-in-horizontal-split/21544307#21544307
      (defun display-buffer-left (buffer alist)
        "display a buffer to the left of the current buffer.
      (1) If `buffer` is already displayed, then display it again in the same window.
      (2) If `buffer` is not already displayed, and if there is a window to the left,
          then display that `buffer` in said window.
      (3) If `buffer` is not already displayed, and if there is a window to the right, then
          use the selected window.
      (4) If all else fails, then create a new window to the left and display `buffer` there.
      (5) Select the target window which displays `buffer`."
        (let ((window
               (cond
                ((get-buffer-window buffer (selected-frame)))
                ;; ((window-in-direction 'above))
                ((window-in-direction 'left))
                ((window-in-direction 'right)
                 (selected-window))
                (t
                 (split-window (selected-window) nil 'left)))))
          (window--display-buffer buffer window 'window alist)))

      (defun display-buffer-right (buffer alist)
        "display a buffer to the right of the current buffer.
      (1) If `buffer` is already displayed, then display it again in the same window.
      (2) If `buffer` is not already displayed, and if there is a window to the right,
          then display that `buffer` in said window.
      (3) If `buffer` is not already displayed, and if there is a window to the left, then
          use the selected window.
      (4) If all else fails, then create a new window to the right and display `buffer` there.
      (5) Select the target window which displays `buffer`."
        (let ((window
               (cond
                ((get-buffer-window buffer (selected-frame)))
                ;; ((window-in-direction 'above))
                ((window-in-direction 'right))
                ((window-in-direction 'left)
                 (selected-window))
                (t
                 (split-window (selected-window) nil 'right)))))
          (window--display-buffer buffer window 'window alist)))

      (display-buffer--create-focus-method display-buffer-left)
      (display-buffer--create-focus-method display-buffer-right)

      (provide 'mohkale-display-buffer-functions)
    #+END_SRC

*** Misc
    #+BEGIN_SRC emacs-lisp
      (use-package mohkale-misc
        :defer t
        :commands (toggle-lexical-binding
                   keymaps-at-point
                   show-prefix
                   toggle-relative-linum))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (defun toggle-lexical-binding (&optional prefix)
        (interactive "P")
        (if (not prefix)
            (setq lexical-binding (not lexical-binding))
          (cond
           ((or (listp prefix) (> prefix 0))
            (setq lexical-binding t))
           (t
            (setq lexical-binding nil))))

        (message "lexical binding: %s" (if lexical-binding
                                           (propertize "enabled" 'face 'compilation-info)
                                         (propertize "disabled" 'face 'compilation-error))))

      (defun show-prefix (&optional prefix)
        (interactive "P")
        (message "prefix is: %s" prefix))

      (defvar-local header-line-actual-format nil
        "value of `header-line-format' before being modified by `toggle-buffer-header'.")

      (defun toggle-buffer-header (&optional arg)
        (interactive "P")
        (let ((showing (if arg
                           (not (zerop (prefix-numeric-value arg)))
                         header-line-actual-format)))
          (if showing
              (if (not  header-line-actual-format)
                  (user-error "tried to restore header-line: nil")
                (setq header-line-format  header-line-actual-format
                      header-line-actual-format nil))
            (setq header-line-actual-format header-line-format
                  header-line-format nil))))

      (defun toggle-relative-linum (&optional arg)
        "toggle relative line numbers in the current buffer
      when ARG is given and is 0, then relative line numbers are disabled,
      otherwise if ARG is greater than 0 then they're enabled and if ARG is
      nil then relative line-numbers are toggled."
        (interactive "P")
        (setq display-line-numbers
              (cond
               ((and arg (zerop (prefix-numeric-value arg)))
                t)
               (arg 'relative)
               (t
                (if (eq display-line-numbers 'relative) t 'relative)))))

      (defun keymaps-at-point ()
        "List entire keymaps present at point."
        (interactive)
        (let ((map-list
               (list
                (mapcar (lambda (overlay)
                          (overlay-get overlay 'keymap))
                        (overlays-at (point)))
                (mapcar (lambda (overlay)
                          (overlay-get overlay 'local-map))
                        (overlays-at (point)))
                (get-text-property (point) 'keymap)
                (get-text-property (point) 'local-map))))
          (apply #'message
                 (concat
                  "Overlay keymap: %s\n"
                  "Overlay local-map: %s\n"
                  "Text-property keymap: %s\n"
                  "Text-property local-map: %s")
                 map-list)))

      (provide 'mohkale-misc)
    #+END_SRC

*** Text
    #+BEGIN_SRC emacs-lisp
      (use-package mohkale-text-query
        :defer t
        :straight (mohkale-text-query :type built-in)
        :commands (line-width
                   column-number
                   in-comment-p
                   in-font-lock-comment-p
                   line-beginning-column
                   yank-and-comment
                   point-to-coordinates
                   line-empty-p
                   list-faces))

      (use-package mohkale-text
        :defer t
        :straight (mohkale-text :type built-in)
        :commands (dos2unix
                   unix2dos
                   pad-line-with-char-to-length
                   insert-whitespace-after-point
                   pad-line-with-space-to-length
                   remove-all-trailing-whitespace
                   toggle-comment-at-point
                   tab-to-tab-stop-with-prefix
                   indent-back-to-normal
                   back-to-tab-stop
                   toggle-comment-at-point-alt
                   custom-insert-line
                   custom-insert-line-below
                   custom-insert-line-above
                   evil-join-backwards))
    #+END_SRC

**** Querying
     :PROPERTIES:
     :header-args+: :tangle bin/mohkale/mohkale-text-query.el
     :END:

     functions for querying information about the text at point or retrieve other relevent information.

     #+BEGIN_SRC emacs-lisp
       (defun line-width (char-pos)
         "returns the number of columns on the line at char-pos"
         (interactive (if current-prefix-arg
                          (list current-prefix-arg)
                        (list (point))))
         (save-excursion
           (if (not (eql char-pos (point)))
             (goto-char char-pos))
           (let ((line-width (max (- (line-end-position) (line-beginning-position) 1) 0)))
             (if (called-interactively-p 'any)
                 (message (format "Line Width: %03d" line-width)))

             line-width)))

       (defun column-number (point)
         "returns the column number at point"
         (interactive "")
         (save-excursion
           (goto-char point)
           (current-column)))

       (defun point-to-coordinates (&optional point)
         "convert a point to an XY coordinate alist"
         (or point (setq point (point)))
         `(,(line-number-at-pos point) . ,(column-number point)))

       (defun line-empty-p (&optional point)
         (save-excursion
           (and point (goto-char point))
           (beginning-of-line)
           (looking-at "[[:space:]]*$")))

       (defun list-faces (&optional point)
         (interactive "d")
         (or point (setq point (point)))
         (let ((faces (remq nil
                            `(,(get-char-property point 'read-face-name)
                              ,(get-char-property point 'face)
                              ,(plist-get (text-properties-at point) 'face)))))
           (and (called-interactively-p 'any) (message (format "%s" faces)))
           faces))

       (defun in-comment-p (&optional pos)
         (save-excursion
           (goto-char (or pos (point)))
           (nth 4 (syntax-ppss))))

       (defun in-font-lock-comment-p (&optional pos)
         "Test if character at POS is comment.
       If POS is nil, character at `(point)' is tested"
         (unless pos (setq pos (point)))
         (let* ((fontfaces (get-text-property pos 'face)))
           (when (not (listp fontfaces))
             (setf fontfaces (list fontfaces)))
           (delq nil
                 (mapcar #'(lambda (f)
                             ;; learn this trick from flyspell
                             (or (eq f 'font-lock-comment-face)
                                 (eq f 'font-lock-comment-delimiter-face)))
                         fontfaces))))

       (defun line-beginning-column (&optional point)
         (save-excursion
           (goto-char (or point (point)))
           (evil-first-non-blank)
           (current-column)))

       (provide 'mohkale-text-query)
     #+END_SRC

**** Formatting
     :PROPERTIES:
     :header-args+: :tangle bin/mohkale/mohkale-text.el
     :END:

***** Chunks
      manipulate chunks of text, such as leading indentation or sequential padding.

      #+BEGIN_SRC emacs-lisp
        (defun dos2unix ()
          "Not exactly but it's easier to remember"
          (interactive)
          (set-buffer-file-coding-system 'unix 't))

        (defun unix2dos ()
          (interactive)
          (set-buffer-file-coding-system 'dos 't))

        (defun pad-line-with-char-to-length (desired-length char)
          "appends char as many times as required from cursor position"
          (interactive "Nline length: \nccharacter: \nd")
          (barf-if-buffer-read-only) ; can't pad read only buffer

          (save-excursion
            (let* ((line-char-count (line-width (point))))
              (if (>= line-char-count desired-length)
                  (error (format "line of length %03d is already larger than desired: %03d" line-char-count desired-length))
                (insert (make-string (- desired-length line-char-count) char))))))

        (defun pad-line-with-space-to-length (desired-length)
          "invokes pad-line-with-char-to-length with char as space"
          (interactive "Nline length: \n")
          (pad-line-with-char-to-length desired-length ?\s))

        ;; (defun remove-indentation-spaces ()
        ;;   "remove TAB-WIDTH spaces from the beginning of this line"
        ;;   (interactive)
        ;;   (if (save-excursion (re-search-backward "[^ \t]" (line-beginning-position) t))
        ;;       (delete-backward-char 1)
        ;;     (indent-rigidly (line-beginning-position) (line-end-position) (- tab-width))))

        (defun remove-all-trailing-whitespace (start end)
          "removes all trailing whitespace from every line in buffer"
          (interactive (if (region-active-p)
                           (list (region-beginning) (region-end))
                         (list (point-min) (point-max))))

          (barf-if-buffer-read-only) ; can't remove from current buffer

          (save-excursion
            (goto-char end) ; start from end so delete can work forward

            (while (and (> (point) start)
                        (re-search-backward " +$" nil t))
              (delete-region (point) (line-end-position)))))

        (defun indent-back-to-normal (&optional column)
          "indents the current line using indent region.
        this'll either reset indentation to it's normal position, or
        bring you to the beginning of an empty line. Specify a column
        value to force that column to be used by indent region."
          (interactive "P")

          (let ((inhibit-message t))
            (indent-region (line-beginning-position) (1+ (line-end-position)) column)))

        (defun insert-whitespace-after-point (&optional count)
          "inserts whitespace from point upto COUNT times
        without moving point."
          (interactive "P")
          (or  count         (setq count 1))
          (and (listp count) (setq count (car count)))

          (save-excursion
            (insert (make-string count ? ))))

        ;; https://emacs.stackexchange.com/questions/32816/backwards-tab-to-tab-stop
        (defun tab-to-tab-stop-with-prefix (&optional prev)
          "Like `tab-to-tab-stop', but toggle direction with prefix."
          (interactive "P")
          (let ((nexttab (indent-next-tab-stop (current-column) prev)))
            (delete-horizontal-space t)
            (indent-to nexttab)))

        (defun back-to-tab-stop ()
          (interactive)
          (let ((current-prefix-arg 1))
            (call-interactively #'tab-to-tab-stop-with-prefix)))
      #+END_SRC

***** Commenting
      comment regions of text or by default, the current line.

      #+BEGIN_SRC emacs-lisp
        (defun toggle-comment-at-point (start end)
          "toggle comment on line or region
        pass a prefix argument to bulk toggle across multiple lines.
        This function will always comment the line your point is on,

        prefix behaviour:
        | prefix range | behaviour                                        |
        |--------------+--------------------------------------------------|
        | 0            | current line only                                |
        | >1           | current line and upto prefix-1 lines after point |
        | <1           | current line and upto prefix lines before point  |

        the behaviour is mapped to exactly replicate the vim dd command."
          (interactive (let ((prefix current-prefix-arg))
                         (if (region-active-p)
                             ;; always use region when region available
                             (list (region-beginning) (region-end))
                           (if (or (not prefix)
                                   (listp prefix) ;; regular prefix
                                   (zerop prefix))
                               ;; no prefix, comment current line only
                               (list (line-beginning-position) (line-end-position))
                             ;; prefix given, use it to determine comment region
                             (let* ((prefix-positive (> prefix 0))
                                    (current-pos (if prefix-positive
                                                     (line-beginning-position)
                                                   (line-end-position))))
                               (save-excursion
                                 (if prefix-positive
                                     (progn
                                       (evil-next-line (- prefix 1))
                                       (list current-pos (line-end-position)))
                                   (evil-next-line prefix)
                                   (list (line-beginning-position) current-pos))))))))
          (comment-or-uncomment-region start end))

        (defun toggle-comment-at-point-alt ()
          "variant of toggle-comment-at-point which conforms to relative line numbers

        prefix behaviour:
        | prefix range | behaviour                                         |
        |--------------+---------------------------------------------------|
        | 0            | current line only                                 |
        | >1           | current line and upto prefix-1 lines after point  |
        | <1           | current line and upto prefix+1 lines before point |
        "
          (interactive)
          (let ((current-prefix-arg (and current-prefix-arg
                                         (cond
                                          ((>= current-prefix-arg 1) (1+ current-prefix-arg))
                                          ;; ((<  current-prefix-arg 0) (1- current-prefix-arg))
                                          (t current-prefix-arg)))))
            (call-interactively 'toggle-comment-at-point)))

        (defun yank-and-comment (&optional prefix)
          (interactive "P")
          (when (> (length kill-ring)
                   0)
            (save-excursion
              (let ((beginning (point)))
                (call-interactively 'yank)
                (comment-region beginning (point))))
            (evil-forward-word))) ;; move to beginning of comment
      #+END_SRC

***** Line Insertion
      line insertion and joining functions.

      #+BEGIN_SRC emacs-lisp
        (defun custom-insert-line (&optional prefix)
          "inserts a line above or below point

        if a prefix argument of 0 or more (or none) is given, the
        line is inserted below the point. Otherwise its inserted
        above the point.

        The absolute value of the prefix determines how many lines
        are inserted.

        Eg: A prefix of:
          ,* nil - inserts a single line below the cursor
          ,* -1  - inserts a single line above the cursor
          ,* 0   - inserts a single line below the cursor
          ,* 1   - inserts a single line below the cursor
          ,* -10 - inserts 10 lines above the cursor
          ,* 10  - inserts 10 lines below the cursor"
          (interactive "P")

          (save-excursion
            (let ((move-arg (if (or (not prefix)
                                    (>= prefix 0))
                                nil ; if prefix xor prefix >= 0
                              0)))
              (move-end-of-line move-arg)
              (open-line (max 1 (abs prefix))))))

        (defun custom-insert-line-below (&optional prefix)
          (interactive "P")
          (custom-insert-line (abs (or prefix 1))))

        (defun custom-insert-line-above (&optional prefix)
          (interactive "P")
          (custom-insert-line (- (abs (or prefix 1)))))

        (defun evil-join-backwards (&optional prefix)
          "same as join line, except joins line immeadiately before point"
          (interactive "p")
          (let ((start nil)
                (end   nil))
            (if (evil-visual-state-p)
                (let ((range (evil-visual-range)))
                  (setq start (nth 0 range))
                  (setq end   (nth 1 range)))
              ;; not visual, calculate ranges
              (setq end (point))
                (save-excursion
                  (forward-line (- (abs prefix)))
                  (setq start (point))))
            ;; remove excursion block if you wan't to
            ;; reallign point to start of line on join
            (save-excursion
              (if (line-empty-p start)
                  ;; when joining onto an empty line
                  ;; maintain leading whitespace
                  (evil-join-whitespace start end)
                ;; otherwise trim to single space
                (evil-join start end)))))

        (provide 'mohkale-text)
      #+END_SRC

*** Buffers, Windows & Frames
    #+BEGIN_SRC emacs-lisp
      (use-package mohkale-bufwin
        :straight (mohkale-bufwin :type built-in)
        :defer load-me-now-duration
        :commands (kill-this-buffer-and-window-maybe
                   switch-to-last-buffer
                   kill-all-windows-and-return-to-home
                   halt-and-catch-fire
                   switch-to-messages-buffer
                   force-set-all-visible-windows-dedication
                   window-zen
                   window-zen-restore
                   display-last-buffer
                   vertical-display-last-buffer
                   shell-command-on-buffer
                   set-window-dedication
                   async-shell-command-on-buffer
                   safe-erase-buffer
                   copy-whole-buffer-to-clipboard
                   split-window-right-and-focus
                   split-window-below-and-focus)
        :init
        (general-define-key
          :keymaps 'mohkale-window-map
          "T" 'force-set-all-visible-windows-dedication
          "o"   'display-last-buffer
          "C-o" 'display-last-buffer
          "D"   'set-window-dedication
          "M-d" 'set-window-dedication
          "O"   'vertical-display-last-buffer
          "M-o" 'vertical-display-last-buffer))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale-bufwin.el
      (defun switch-to-messages-buffer ()
        "switches to messages buffer"
        (interactive)
        (switch-to-buffer (messages-buffer)))

      (defun switch-to-last-buffer (&optional buffer)
        (interactive)
        (switch-to-buffer buffer))

      (defun kill-this-buffer-and-window-maybe ()
        "kills the currently open buffer and the window if another is open"
        (interactive)
        (let ((window-count (length (window-list))))
          (if (> window-count 1)
              (kill-buffer-and-window)
            (kill-this-buffer))))

      (defun kill-all-windows-and-return-to-home ()
        "kills every other window and returns to home buffer"
        (interactive)
        (dolist (window (cdr (window-list)))
          ;; window-list starts with current window
          (delete-window window))
        (goto-home-buffer))

      (defalias 'halt-and-catch-fire #'kill-all-windows-and-return-to-home)

      (defun force-set-all-visible-windows-dedication (&optional dedicate)
        "allows you to set the dedication of all visible windows
      dedicate if truthy, will result in all windows recieving a dedication.
      if falsy, all windows will have their dedication removed"
        (interactive "P")
        ;; TODO require persp-mode here
        (and dedicate (setq dedicate t))      ; rationalise value as bool
        (or  dedicate (setq dedicate nil))    ; rationalise value as nil

        (dolist (window (window-list))
          (when (not (eq dedicate (window-dedicated-p window)))
            (set-window-dedicated-p window dedicate))))

      (let ((window-zen-register ?_))
        (defun window-zen (&optional prefix)
          "Maximize buffer or undo maximize buffer
      pass prefix to also restore original point."
          ;; from [[https://gist.github.com/3402786][here]].
          (interactive "P")
          (if (and (= 1 (length (window-list)))
                   (assoc window-zen-register register-alist))
              (window-zen-restore prefix)
            (window-configuration-to-register window-zen-register)
            (delete-other-windows)))

        (defun window-zen-restore (&optional prefix)
          "force restoration of window, instead of replacement of previous zen.
      like `window-zen' pass prefix argument to save excursion"
          (interactive)
          (unless (assoc window-zen-register register-alist)
            (user-error "no previous zen found."))

          (if prefix
              (jump-to-register window-zen-register)
            (save-excursion
              (jump-to-register window-zen-register)))))

      (defun shell-command-on-buffer (&optional prefix)
        "Asks for a command and executes it in inferior shell with current buffer
      as input. if prefix is given, output of command is inserted in current buffer
      at point."
        (interactive "P")
        (let ((command (read-shell-command "Shell command on buffer: "))
              (input-buffer (current-buffer)) output-buffer process-output)
          (with-temp-buffer ;; needed for process output
            (setq output-buffer (current-buffer))

            (with-current-buffer input-buffer
              (shell-command-on-region (point-min) (point-max) command output-buffer nil output-buffer))

            (setq process-output (buffer-string)))

          (if prefix
              (insert process-output)
            (message process-output))))

      (defun async-shell-command-on-region (&optional start end prefix)
        "same as `async-shell-command', but also sends the current region
      as stdin to the asynchronous process. "
        (interactive "r\nP")
        (require 'subr-x) ;; needed for string-empty-p

        (unless (eq start end) ;; region is not active
          (let ((command (read-shell-command "Async shell command on buffer: ")))
            (unless (string-empty-p command)
              (async-shell-command command) ;; XXX WHY??? don't you return the process :P
              (let ((program-buffer (get-buffer "*Async Shell Command*")))

                (process-send-region (get-buffer-process program-buffer) start end)

                (with-current-buffer program-buffer
                  (comint-send-eof)

                  (unless (get-buffer-process program-buffer)
                    (funcall-interactively 'initial-major-mode)))

                (display-buffer program-buffer))))))

      (defun async-shell-command-on-buffer (&optional prefix)
        "same as `async-shell-command-on-region' but sends buffer as region"
        (interactive "P")
        (async-shell-command-on-region (point-min) (point-max) prefix))

      (defun safe-erase-buffer (&optional prefix)
        "prompts to really erase and then erases the current buffer"
        (interactive "P")
        (barf-if-buffer-read-only)
        (when (or prefix
                  (y-or-n-p (concat "Erase content of buffer "
                                    (buffer-name)
                                    " ?")))
            (erase-buffer)))

      (defun split-window-right-and-focus ()
        (interactive)
        (split-window-horizontally)
        (other-window 1))

      (defun split-window-below-and-focus ()
        (interactive)
        (split-window-vertically)
        (other-window 1))

      (defun copy-whole-buffer-to-clipboard (buffer)
        (interactive (list (current-buffer)))
        (with-current-buffer buffer
          (copy-region-as-kill (point-min) (point-max))))

      (defun display-last-buffer ()
        (interactive)
        (display-buffer
         (other-buffer)
         '((display-buffer-below-selected-and-focus
            display-buffer-in-previous-window-and-focus
            display-buffer-use-some-window-and-focus
            display-buffer-pop-up-frame-and-focus))))

      (defun vertical-display-last-buffer ()
        (interactive)
        (display-buffer
         (other-buffer)
         (cons '(display-buffer-right-and-focus
                 display-buffer-in-previous-window-and-focus
                 display-buffer-use-some-window-and-focus
                 display-buffer-pop-up-frame-and-focus)
               '((side . right)
                 (window-width . 0.5)))))

      ;; (cl-defmacro window-route (&rest paths)
      ;;   "macro to see which window exists at the end of a route
      ;; from the current window.

      ;; Accepts up, down, left & right as direction markers & every
      ;; route begins from the top left hand side of the current window."
      ;;   `(let ((paths ',paths))
      ;;      (if (not paths)
      ;;          (selected-window)
      ;;        (condition-case err
      ;;            (save-excursion
      ;;              ;; goto start to ensure route begins from
      ;;              ;; top left hand side of current window.
      ;;              (goto-char (max (point-min) (window-start)))
      ;;              (goto-char (line-beginning-position))
      ;;              (save-selected-window
      ;;                (let (head)
      ;;                  ;; TODO check whether to goto top left hand side here.
      ;;                  (while (setq head (pop paths))
      ;;                    (cond
      ;;                     ((eq head 'up)    (windmove-up))
      ;;                     ((eq head 'down)  (windmove-down))
      ;;                     ((eq head 'left)  (windmove-left))
      ;;                     ((eq head 'right) (windmove-right))))
      ;;                  (selected-window))) )
      ;;          (user-error (message "window-route: %s" err))))))

      ;; (defun window-expand-up ()
      ;;   "Expand current window into region of window above.

      ;;                          Begun from 3           Begun from 2
      ;; +---------------+      +---------------+      +---------------+
      ;; | 1             |      | 1        | 3  |      | 2        | 1  |
      ;; |               |  |-> |          |    |  |-> |          |    |
      ;; |---------+-----|      |----------+    |      |          +----|
      ;; | 2       | 3   |      | 2        |    |      |          | 3  |
      ;; +---------------+      +---------------+      +---------------+

      ;; "
      ;;   )

      ;; (defun window-expand-down ()
      ;;   "Expand current window into region of window below.

      ;;                          Begun from 2           Begun from 1
      ;; +---------------+      +---------------+      +---------------+
      ;; | 1       | 2   |      | 1        | 2  |      | 1        | 2  |
      ;; |         |     |  |-> |          |    |  |-> |          |    |
      ;; |---------+-----|      |----------+    |      |          +----|
      ;; | 3             |      | 3        |    |      |          | 3  |
      ;; +---------------+      +---------------+      +---------------+
      ;; "
      ;;   )

      ;; (defun window-expand-right ()
      ;;   "Expand current window into region of window to the right.

      ;;                          Begun from 1           Begun from 3
      ;; +---------------+      +---------------+      +---------------+
      ;; | 1       | 2   |      | 1             |      | 1        | 2  |
      ;; |         |     |  |-> |               |  |-> |          |    |
      ;; |---------+     |      |----------+----|      |----------+----|
      ;; | 3       |     |      | 3        | 2  |      | 3             |
      ;; +---------------+      +---------------+      +---------------+
      ;; "
      ;;   )

      ;; (defun window-expand-left ()
      ;;   "Expand current window into region of window to the left.

      ;;                          Begun from 2           Begun from 3
      ;; +---------------+      +---------------+      +---------------+
      ;; | 1       | 2   |      | 2             |      | 1        | 2  |
      ;; |         |     |  |-> |               |  |-> |          |    |
      ;; |         +-----|      |----------+----|      |----------+----|
      ;; |         | 3   |      | 1        | 3  |      | 3             |
      ;; +---------------+      +---------------+      +---------------+
      ;; "
      ;;   )

      (defun set-window-dedication (&optional prefix window)
        "Set the dedication value for the current window.
      By default it toggles the dedication. Supply a prefix arg
      to explicitly enable or disable.

      When a window is dedicated, you can't change the buffer for it.
      "
        (interactive "P")
        (when (and prefix
                   (listp prefix))
          (setq prefix (car prefix)))
        (or window (setq window (selected-window)))

        (set-window-dedicated-p
         window
         (if prefix
             (> prefix 0)
           (not (window-dedicated-p window)))))

      (provide 'mohkale-bufwin)
    #+END_SRC

*** multiscratch
    An extension of the persistent scratch function which provides functions to create a new
    scratch buffer and interactively switch to one.

    WARN multiscratch doesn't save the first scratch buffer. That's a real scratch buffer,
    which's expected to get erased every time emacs is killed. All other scratche buffers are
    properly restored though.

    #+BEGIN_SRC emacs-lisp
      (use-package multiscratch
        :commands (switch-to-scratch-buffer
                   create-new-empty-buffer
                   scratch-buffer-p)
        :defer 30 ;; auto restore scratch buffers after 30-seconds.
        :init
        (leader/set-keys
          "bs"    'switch-to-scratch-buffer
          "b RET" 'create-new-empty-buffer)

        :config
        (use-package persistent-scratch
          :ensure t
          :init
          (defun multiscratch-scratch-buffer-p (&optional buffer)
            "persist all but the main scratch buffer."
            (and (not (string= (buffer-name buffer) scratch-buffer-name))
                 (scratch-buffer-p buffer)))

          (setq persistent-scratch-save-file (var! "scratch.el")
                persistent-scratch-autosave-interval 800
                persistent-scratch-scratch-buffer-p-function #'multiscratch-scratch-buffer-p)

          ;; force restoration on initial movement to a scratch buffer.
          (when (file-exists-p persistent-scratch-save-file)
            (persistent-scratch-restore))

          (add-hook 'kill-emacs-hook #'persistent-scratch-save)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/multiscratch.el
      (defvar scratch-buffer-name "*scratch*"
        "name of users scratch buffer")

      ;;;###autoload
      (cl-defun create-new-empty-buffer (&optional buffer-name (is-scratch t))
        "creates and returns a new empty scratch like buffer
      with prefix it prompts you for the name of the buffer.
      if called interactively, the new buffer is switched to."
        (interactive "P")
        (let* ((def-buf-name scratch-buffer-name)
               (buffer-name
                (cond
                 ((stringp buffer-name) buffer-name)
                 (buffer-name (read-buffer "buffer name: " def-buf-name))
                 (t def-buf-name)))
               (buffer-name (generate-new-buffer-name buffer-name))
               (buffer (get-buffer-create buffer-name)))
          (with-current-buffer buffer
            (funcall-interactively initial-major-mode))
          (when (called-interactively-p)
            (switch-to-buffer buffer))
          buffer))

      (defun scratch-buffer-p (&optional buffer)
        (string-match
         (regexp-quote scratch-buffer-name)
         (buffer-name buffer) 0))

      (defun scratch-buffers ()
        (sort
         (seq-filter #'scratch-buffer-p (buffer-list))
         (lambda (x y) (string< (buffer-name x) (buffer-name y)))))

      ;;;###autoload
      (defun switch-to-scratch-buffer (&optional prefix)
        "switch to the scratch buffer
      with prefix, prompts for which buffer named like the scratch
      buffer to switch to. If none exists, a new scratch buffer will
      be made. If only one exists, it will be switched to and if more
      than one exists then prompts for it."
        (interactive "P")
        (if (not prefix)
            ;; switch to original scratch buffer
            (let ((buffer (get-buffer scratch-buffer-name)))
              (if buffer
                  (switch-to-buffer buffer)
                (call-interactively 'create-new-empty-buffer)))
          (let* ((buffer-list (scratch-buffers))
                 (buffer-names (mapcar #'buffer-name buffer-list))
                 (buffer
                  (cond
                   ((zerop (length buffer-list))
                    (create-new-empty-buffer))
                   ((eq 1 (length buffer-list))
                    (car buffer-list))
                   (t
                    (require 'counsel)
                    (setq buffer (ivy-read "Switch to buffer: " buffer-names
                                           :require-match t
                                           :keymap ivy-switch-buffer-map
                                           :matcher #'ivy--switch-buffer-matcher
                                           :caller 'switch-to-scratch-buffer
                                           :unwind #'counsel--switch-buffer-unwind
                                           :update-fn 'counsel--switch-buffer-update-fn))))))
            (when (called-interactively-p)
              (switch-to-buffer buffer))
            buffer)))

      (provide 'multiscratch)
    #+END_SRC

*** evil
    Where I keep my own evil operators/commands/*witchcraft*.

    #+BEGIN_SRC emacs-lisp
      (use-package mohkale-evil
        :defer t
        :after evil
        :commands (evil-capitalize
                   evil-reverse
                   evil-adjust-eval-print-last-sexp
                   evil-adjust-eval-last-sexp
                   evil-adjust-eval-replace-last-sexp
                   evil-toggle-comment
                   evil-narrow-yank
                   evil-shift-normal-state))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale-evil.el
      (require 'evil)

      (evil-define-operator evil-capitalize (beg end)
        (capitalize-region beg end))

      (defun evil-shift-normal-state (&optional arg)
        "return to normal state while also removing
      any trailing whitespace from the current line"
        (interactive "P")
        (remove-all-trailing-whitespace (line-beginning-position)
                                        (line-end-position))
        (evil-normal-state arg))

      (evil-define-operator evil-narrow-yank (beg end type register yank-handler)
        "`evil-yank' except block yanks are yanked as their own lines.
      evil by default yanks them such that you can compose them onto other lines.
      this isn't always desirable (especially when you want to filter a region onto
      it's own lines, thus this method satifies that requirement.

      eg:
      `evil-yank' cfj then `evil-paste-after'.
        ab|c|   >   abc|c
        de|f|   >   deff
        gh|j|   >   ghjj

      `evil-narrow-yank' cfj then `evil-paste-after'.
        ab|c|   >   abc
        de|f|   >   |c
        gh|i|   >   f
                >   j
                >   def
                >   ghj
      "
        (interactive "<R><x><y>")
        (evil-visual-restore)
        (if (eq type 'block)
            (progn
              (evil-yank-rectangle beg end ?\" yank-handler)

              (with-temp-buffer
                (evil-paste-before nil ?\")
                (evil-yank (point-min) (point-max) 'line register yank-handler)))
          (evil-yank beg end type register yank-handler)))

      (evil-define-operator evil-toggle-comment (beg end)
        :type        line
        :repeat      t
        :move-point  nil
        :keep-visual nil
        "run `toggle-comment-at-point' using evil motion."
        (toggle-comment-at-point beg end))

      (defun evil-adjust-eval-print-last-sexp ()
        (interactive)
        (save-excursion
          (with-evil-adjust-to-eol
            (funcall-interactively 'eval-print-last-sexp)
            (message nil))))

      (defun evil-adjust-eval-replace-last-sexp ()
        (interactive)
        (with-evil-adjust-to-eol
          (funcall-interactively 'eval-replace-last-sexp)
          (message nil)))

      (evil-define-operator evil-reverse (beg end)
        :type line
        :repeat t
        "evil command to reverse lines over range."
        (reverse-region beg end))

      (provide 'mohkale-evil)
    #+END_SRC

*** Hydras
    #+NAME: tangle-hydras
    #+BEGIN_SRC emacs-lisp :tangle no :results values
      (org-babel-tangle-file "hydras.org")
      nil
    #+END_SRC

    tangles ~hydras.org~ alongside this org file and then sources bindings/autoloads
    from ~hydras.el~.

    #+BEGIN_SRC emacs-lisp
    <<tangle-hydras()>>
    (load (concat user-emacs-directory "hydras.el"))
    #+END_SRC

*** unpackaged
    Many useful functions sourced from [[https://github.com/alphapapa/unpackaged.el/blob/master/unpackaged.el][unpackaged.el]].

    #+BEGIN_SRC emacs-lisp
      (use-package unpackaged
        :straight (unpackaged :type built-in)
        :defer t
        :commands (font-compare
                   lorem-ipsum-overlay)
        :init
        (leader/set-keys
          "xl" 'lorem-ipsum-overlay)

        :config
        ;; used in a bunch of places
        (defvar lorem-ipsum-text nil))
    #+END_SRC

**** Fonts
    #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/unpackaged.el
      ;;;###autoload
      (defun font-compare (text fonts)
        "Compare TEXT displayed in FONTS.
      If TEXT is nil, use `lorem-ipsum' text.  FONTS is a list of font
      family strings and/or font specs.

      Interactively, prompt for TEXT, using `lorem-ipsum' if left
      empty, and select FONTS with `x-select-font', pressing Cancel to
      stop selecting fonts."
        (interactive (list (pcase (read-string "Text: ")
                             ("" nil)
                             (else else))
                           ;; `x-select-font' calls quit() when Cancel is pressed, so we use
                           ;; `inhibit-quit', `with-local-quit', and `quit-flag' to avoid that.
                           (let ((inhibit-quit t))
                             (cl-loop for font = (with-local-quit
                                                   (x-select-font))
                                      while font
                                      collect font into fonts
                                      finally do (setf quit-flag nil)
                                      finally return fonts))))
        (setq text (or text (s-word-wrap 80 (s-join " " (progn
                                                          (require 'lorem-ipsum)
                                                          (seq-random-elt lorem-ipsum-text))))))
        (with-current-buffer (get-buffer-create "*Font Compare*")
          (erase-buffer)
          (--each fonts
            (let ((family (cl-typecase it
                            (font (symbol-name (font-get it :family)))
                            (string it))))
              (insert family ": "
                      (propertize text
                                  'face (list :family family))
                      "\n\n")))
          (pop-to-buffer (current-buffer))))

    #+END_SRC

**** lorem-ipsum
     #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/unpackaged.el
       (require 'lorem-ipsum)

       (defcustom lorem-ipsum-overlay-exclude nil
         "List of regexps to exclude from `lorem-ipsum-overlay'."
         :type '(repeat regexp))

       ;;;###autoload
       (defun lorem-ipsum-overlay ()
         "Overlay all text in current buffer with \"lorem ipsum\" text.
       When called again, remove overlays.  Useful for taking
       screenshots without revealing buffer contents.

       Each piece of non-whitespace text in the buffer is compared with
       regexps in `lorem-ipsum-overlay-exclude', and ones
       that match are not overlaid.  Note that the regexps are compared
       against the entire non-whitespace token, up-to and including the
       preceding whitespace, but only the alphabetic part of the token
       is overlaid.  For example, in an Org buffer, a line that starts
       with:

         ,#+TITLE: unpackaged.el

       could be matched against the exclude regexp (in `rx' syntax):

         (rx (or bol bos blank) \"#+\" (1+ alnum) \":\" (or eol eos blank))

       And the line would be overlaid like:

         ,#+TITLE: parturient.et"
         (interactive)
         (let ((ovs (overlays-in (point-min) (point-max))))
           (if (cl-loop for ov in ovs
                        thereis (overlay-get ov :lorem-ipsum-overlay))
               ;; Remove overlays.
               (dolist (ov ovs)
                 (when (overlay-get ov :lorem-ipsum-overlay)
                   (delete-overlay ov)))
             ;; Add overlays.
             (let ((lorem-ipsum-words (--> Lorem-ipsum-text
                                           (-flatten it) (apply #'concat it)
                                           (split-string it (rx (or space punct)) 'omit-nulls)))
                   (case-fold-search nil))
               (cl-labels ((overlay-match (group)
                                          (let* ((beg (match-beginning group))
                                                 (end (match-end group))
                                                 (replacement-word (lorem-word (match-string group)))
                                                 (ov (make-overlay beg end)))
                                            (when replacement-word
                                              (overlay-put ov :lorem-ipsum-overlay t)
                                              (overlay-put ov 'display replacement-word))))
                           (lorem-word (word)
                                       (if-let* ((matches (lorem-matches (length word))))
                                           (apply-case word (downcase (seq-random-elt matches)))
                                         ;; Word too long: compose one.
                                         (apply-case word (downcase (compose-word (length word))))))
                           (lorem-matches (length &optional (comparator #'=))
                                          (cl-loop for liw in lorem-ipsum-words
                                                   when (funcall comparator (length liw) length)
                                                   collect liw))
                           (apply-case (source target)
                                       (cl-loop for sc across-ref source
                                                for tc across-ref target
                                                when (not (string-match-p (rx lower) (char-to-string sc)))
                                                do (setf tc (string-to-char (upcase (char-to-string tc)))))
                                       target)
                           (compose-word (length)
                                         (cl-loop while (> length 0)
                                                  for word = (seq-random-elt (lorem-matches length #'<=))
                                                  concat word
                                                  do (cl-decf length (length word)))))
                 (save-excursion
                   (goto-char (point-min))
                   (while (re-search-forward (rx (group (1+ (or bol bos blank (not alpha)))
                                                        (0+ (not (any alpha blank)))
                                                        (group (1+ alpha))
                                                        (0+ (not (any alpha blank)))))
                                             nil t)
                     (unless (cl-member (match-string 0) lorem-ipsum-overlay-exclude
                                        :test (lambda (string regexp)
                                                (string-match-p regexp string)))
                       (overlay-match 2))
                     (goto-char (match-end 2)))))))))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp  :tangle bin/mohkale/unpackaged.el
       (provide 'unpackaged)
     #+END_SRC

*** Fonts/Emojis
    #+BEGIN_SRC emacs-lisp
      ;; adapted from [[https://github.com/zonuexe/emoji-fontset.el/blob/master/emoji-fontset.el][emoji-fontset]]
      (let ((emoji-font-family
             (cl-case window-system
               ('w32 "Segoe UI Emoji")
               ('ns  "Apple Color Emoji")
               (t    "Symbola"))))
        (cl-loop
         for (x . y) in '((#x1f000 . #x1f02f) ;; Mahjong Tiles
                          (#x1f0a0 . #x1f0ff) ;; Playing Cards
                          (#x1f110 . #x1f19a) ;; Enclosed Alphanumeric Supplement
                          ;; Regional Indicator Symbol, Enclosed Ideographic Supplement,
                          ;; Emoticons, Transport and Map Symbols, Alchemical Symbols
                          (#x1f1e6 . #x1f8ff))
         do (setq x (decode-char 'ucs x)
                  y (decode-char 'ucs y))
         do (set-fontset-font "fontset-default" (cons x y) emoji-font-family)))
    #+END_SRC

** Core
   For packages that're need to properly setup other packages. This list won't be in any
   sort of order, beyond the messy order needed to ensure everything can be built from
   scratch.

*** spaceline
    an amazing mode line... needs to be initialised before all others to make sure every
    buffer inherits the same mode line. otherwise, the message buffer will definitely not
    use spaceline, you'll have to restart it or re evaluate this in it's context.

    #+BEGIN_SRC emacs-lisp :results silent
      (use-package powerline
        :straight (powerline :type git :host github :repo "jonathanchu/emacs-powerline"
                             :fork (:host github :repo "milkypostman/powerline")))

      (use-package spaceline
        :straight t
        :demand   t
        :config
        (setq spaceline-buffer-id-max-length 25
              spaceline-org-clock t
              winum-auto-setup-mode-line nil
              powerline-default-separator 'slant

              spaceline-window-number-p t
              spaceline-window-numbers-unicode t

              ;; having two unicode numbers next to each other
              ;; is IMO ugly, so disable the workspace one :(.
              spaceline-workspace-number-p nil
              spaceline-workspace-numbers-unicode t)

        (setq-default mode-line-format (spaceline-spacemacs-theme))

        (defvar spaceline-preferred-icon-height 0.98
          "height of icons in the spaceline modeline")

        (defface spaceline-minibuffer
          `((t (:inherit (spaceline-evil-emacs))))
          "highlight face for spaceline when minibuffer is active"
          :group 'spaceline)

        (defface spaceline-evil-operator
          `((t (:weight normal
                :inherit (error spaceline-evil-motion))))
          "evil operator state face"
          :group 'spaceline)

        (defface spaceline-evil-multiedit
          `((t (:weight normal
                        :inherit (highlight spaceline-evil-motion))))
          "face for evil multiedit face")

        (push '(operator  . spaceline-evil-operator)  spaceline-evil-state-faces)
        (push '(multiedit . spaceline-evil-multiedit) spaceline-evil-state-faces)

        (defvar spaceline--highlight-evil-operator-face t
          "when true, spaceline will highlight operator state
      like it would any other state.")

        (setq spaceline-highlight-face-func
              (defun spaceline-highlight-face+ ()
                (if (active-minibuffer-window)
                    'spaceline-minibuffer
                  ;; (spaceline-highlight-face-evil-state)
                  ;; redefine spaceline-highlight-face-evil-state here because
                  ;; it doesn't highlight operator state :(
                  (if (bound-and-true-p evil-local-mode)
                      (let* ((state (if (and (eq 'operator evil-state)
                                            (not spaceline--highlight-evil-operator-face))
                                       evil-previous-state
                                     evil-state))
                             (face (assq state spaceline-evil-state-faces)))
                        (if face (cdr face) (spaceline-highlight-face-default)))
                    (spaceline-highlight-face-default)))))

        ;; by default, colors seem to glitch out on change
        (add-hook 'after-load-theme-hook #'powerline-reset)

        (defun spaceline--face-icon-height (face)
          (let ((height (face-attribute face :height)))
            (unless (eq height 'unspecified)
              (/ height 100.0))))

        (defun spaceline-icon-height (&optional height)
          (or height
              spaceline-preferred-icon-height
              (spaceline--face-icon-height 'mode-line)
              (spaceline--face-icon-height 'default)))

        (cl-defmacro spaceline-prepared-icon (func icon-arg &rest args)
          "retrieve an `all-the-icons' icon for display in the spaceline.
      FUNC is a function such as `all-the-icon-faicon' which accepts an argument
      ICON-ARG and a bunch of face properties and returns either a symbol or an
      icon string.

      The remaining arguments should form a PLIST with the following being used
      by this function and the remaining being passed directly to FUNC.

      Keywords
      --------
      face - Can be given to specify a face for the icon. This face will be applied
             over the regular background of the current spaceline section.

      face-when-active - When specified means the face argument from before will only
                         only be applied on the windows spaceline sees as active.

      family - Can be specified as a function to force usage of a certain font family
               for the icon. If ommited the family property is extracted from the icon
               directly. eg. `all-the-icons-icon-family-for-mode'.
      "
          (plist-bind! (args :face :family :height :propertize (:v-adjust . -0.1) (:face-when-active . t))
            (setq family (eval family))

            `(let* ((use-face (and ,face
                                   ,@(when face-when-active
                                       (list (quote (bound-and-true-p active))))))
                    (icon (funcall ,func ,icon-arg
                                   :face (when use-face ,face)
                                   :v-adjust ,v-adjust
                                   :height (spaceline-icon-height ,height)
                                   ,@args)))
               (unless (symbolp icon)
                 (if use-face
                     (prog1 icon
                       ;; see https://github.com/domtronn/all-the-icons.el/issues/131
                       (add-face-text-property 0 (length icon) :inherit t icon))
                   (propertize icon
                               ;; 'display '(raise 0.1)
                               'mouse-face 'mode-line-highlight
                               'face (list :family (or
                                                ,@(when (and family (functionp family))
                                                    (funcall family))
                                                (plist-get (get-text-property 0 'face icon)
                                                           :family))
                                       :inherit)))))))
        (put 'spaceline-prepared-icon 'lisp-indent-function 'defun)

        (cl-defmacro spaceline-icon (family icon &rest args)
          "alias for `spaceline-prepared-icon' which uses a font-family as a function.
      FONT-FAMILY should be a symbol (such as faicon) relating to some font family.
      ICON should be a string relating to an icon in that family.

      See `spaceline-prepared-icon' for a description of the remaining arguments.
      "
          (let* ((icon-func (intern (concat "all-the-icons-" (symbol-name family))))
                 (family-func (intern (concat (symbol-name icon-func) "-family"))))
            `(spaceline-prepared-icon #',icon-func ,icon :family #',family-func ,@args)))
        (put 'spaceline-icon 'lisp-indent-function 'defun)

        (require 'mohkale-spaceline-segments)

        (spaceline-compile
          ;; Left
          '((minibuffer-active
             :fallback ((persp-name
                         workspace-number
                         window-number)
                        :fallback evil-state)
             :face highlight-face
             :priority 100)
            auto-compile
            (anzu
             :priority 98)
            ((buffer-modified
              buffer-size
              buffer-mode-icon
              buffer-id
              remote-host)
             :priority 98)
            (major-mode :priority 79)
            (process :when active)
            ((flycheck-error
              flycheck-warning
              flycheck-info)
             :when active
             :priority 89)
            (minor-modes
             :when active
             :priority 9)
            ;; (mu4e-alert-segment :when active)
            ;; (erc-track :when active)
            ((version-control-type-icon
              ;; version-control-status
              )
             :fallback version-control
             :priority 78)
            ;; (org-pomodoro :when active)
            (org-clock :when active))

          ;; Right
          '(which-function
            (python-pyvenv
             :fallback python-pyenv)
            (purpose :priority 94)
            (battery :when active)
            (selection-info :priority 95)
            input-method
            ((evil-macro-and-register
              buffer-encoding-abbrev
              point-position
              line-column)
             :separator " | "
             :priority 96)
            (global :when active)
            (buffer-position :priority 99)
            (hud :priority 99))))
    #+END_SRC

**** segments
    #+BEGIN_SRC emacs-lisp :results silent :tangle bin/mohkale/mohkale-spaceline-segments.el
      (require 'spaceline-config)

      (defun spaceline-active-macro-to-string+ ()
        (when defining-kbd-macro
          (let ((macro-symbol "@"))
            (if (and (bound-and-true-p evil-mode)
                     evil-this-macro)
                (concat macro-symbol
                        (string evil-this-macro))
              macro-symbol))))

      (defvar spaceline-evil-register-always-display-p+ nil
        "whether to always show something in the modeline,
      even when no register is currently active.")

      (defmacro evil-register-to-string (register-var)
        `(if ,register-var
             (concat "\"" (char-to-string ,register-var))
           (when spaceline-evil-register-always-display-p+
             (make-string 2 ?_))))

      (spaceline-define-segment evil-macro-and-register
        (let ((macro (spaceline-active-macro-to-string+))
              (register (evil-register-to-string evil-this-register)))
          (cond
           ((and macro register)
            (concat macro " " register))
           (macro    macro)
           (register register)))
        :enabled t)

      ;; see for eg segments: [[https://github.com/domtronn/all-the-icons.el/wiki/Spaceline]]
      (defalias 'all-the-icons-available-p #'display-graphic-p
        "whether your current frame has access to emacs icons.")

      (spaceline-define-segment minibuffer-active
        "show a stop symbol if minibuffer is active"
        (spaceline-icon faicon "minus-circle" :v-adjust 0.00)
        :when (and (all-the-icons-available-p)
                   (active-minibuffer-window)))

      (defvar spaceline-major-mode-icon--skip-modes nil
        "don't show the icon for modes in this list")

      (spaceline-define-segment buffer-mode-icon
        "an `all-the-icons' segment to show the mode of the current buffer"
        (unless (member major-mode spaceline-major-mode-icon--skip-modes)
          (spaceline-prepared-icon #'all-the-icons-icon-for-mode major-mode
            :v-adjust -0.15))
        :enabled (all-the-icons-available-p))

      (spaceline-define-segment version-control-type-icon
        (let (func icon)
          (cond ((string-match "Git[:-]" vc-mode)
                 (setq func #'all-the-icons-alltheicon
                       icon "git"))
                ((string-match "SVN-" vc-mode)
                 (setq func #'all-the-icons-material
                       icon "cloud_download")))
          (when (and func icon)
            (spaceline-prepared-icon func icon)))
        :when (and vc-mode (all-the-icons-available-p)))

      (defun spaceline-vc-git-status+ ()
        "Get the formatted GIT Version Control Icon based on variable `vc-mode'."
        (let* ((branch (cadr (split-string vc-mode "Git[:-]")))
               (git-branch (spaceline-icon octicon
                                            (if (string= branch "master")
                                                "git-merge"
                                              "git-branch")))
               (local-map (get-text-property 1 'local-map branch)))
          (propertize
           (concat
            (when git-branch
              (propertize git-branch 'display '(raise 0.1)))
            " "
            (propertize branch 'display '(raise 0.1) 'face `(:inherit)))
           'mouse-face 'mode-line-highlight
           'local-map local-map)))

      (defun spaceline-vc-svn-status+ ()
        "Get the formatted SVN Version Control Icon based on variable `vc-mode'."
        (let ((revision (cadr (split-string vc-mode "-" ))))
          (propertize revision
                      'display '(raise 0.1)
                      'face `(:height ,spaceline-preferred-icon-height
                              :family ,(all-the-icons-octicon-family)
                              :inherit))))

      (spaceline-define-segment version-control-status
        "An `all-the-icons' segment to depict the current VC system with an icon"
        (cond ((string-match "Git[:-]" vc-mode)
               (spaceline-vc-git-status+))
              ((string-match "SVN-" vc-mode)
               (spaceline-vc-svn-status+)))
        :when (and active vc-mode (all-the-icons-available-p)))

      (provide 'mohkale-spaceline-segments)
     #+END_SRC

*** persp-mode
    configure an ease of use macro to programatically define custom perspectives. the general
    functionality is sourced from [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%25252Bspacemacs/spacemacs-layouts/funcs.el#L161][spacemacs]].

    #+BEGIN_SRC emacs-lisp
      (defvar mohkale--custom-perspectives
        (make-hash-table
         :size 26
         :test 'string-hash-table-test)
        "all the defined custom perspectives.")

      ;; source: [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%252Bspacemacs/spacemacs-layouts/funcs.el#L161]]
      (defmacro mohkale//define-custom-perspective (name &rest body)
        (let* ((name (if (symbolp name)
                         (symbol-value name)
                       name))
               (func (intern (concat "persp-custom-"
                                     name))))
          `(prog1
               (defun ,func ()
                 ,(format "open custom perspective: %s" name)
                 (interactive)
                 (require 'persp-mode) ;; required for init check
                 (let ((initialize (not (gethash ,name *persp-hash*))))
                   (persp-switch ,name)
                   (when initialize
                     (delete-other-windows)
                     ,@body)))
             (puthash ,name (quote ,func) mohkale--custom-perspectives))))
      (put 'mohkale//define-custom-perspective 'lisp-indent-function 'defun)

      (defun mohkale/switch-to-custom-perspective (&optional name)
        (interactive)
        (let* ((persps mohkale--custom-perspectives)
               (pcount (hash-table-count persps))
               (persp-keys (unless (zerop pcount)
                             (let (result)
                               (maphash (lambda (key value)
                                          (push key result))
                                        persps)
                               result))))
          (if (zerop pcount)
              (message "no custom perspectives defined")
            (unless name
              (setq name (ivy-read "perspective: "
                                   persp-keys
                                   :require-match t)))
            (funcall (gethash name
                              persps
                              (lambda () (message "unable to find perspective: %s" name)))))))
    #+END_SRC

*** evil
**** evil-match-it
     #+BEGIN_SRC emacs-lisp
       (use-package evil-matchit
         :ensure t
         :defer  t
         :hook (evil-mode . global-evil-matchit-mode)
         :init
         (defun evilmi-customize-keybinding ()
           (general-define-key
             ;; WARN binding to motion breaks things.
             :states  '(normal visual)
             :keymaps 'evil-matchit-mode-map
             "%"  'evilmi-jump-items)))
     #+END_SRC

**** evil-surround
     #+BEGIN_SRC emacs-lisp
       (use-package evil-surround
         :ensure t
         :defer  5
         :hook (evil-mode . global-evil-surround-mode)
         :config
         (setq-default evil-surround-pairs-alist
                       '((?\( . ("(" . ")"))
                         (?\[ . ("[" . "]"))
                         (?\{ . ("{" . "}"))

                         (?\) . ("( " . " )"))
                         (?\] . ("[ " . " ]"))
                         (?\} . ("{ " . " }"))

                         (?# . ("#{" . "}")) ; ruby string interpolation
                         (?b . ("(" . ")"))
                         (?B . ("{" . "}"))
                         (?> . ("<" . ">"))
                         (?t . evil-surround-read-tag)
                         (?< . evil-surround-read-tag)
                         (?f . evil-surround-function)))

         ;; only allow surrounding via selections or
         ;; explicitly using gS
         (general-define-key
           :states 'visual
           "s" 'evil-surround-region)

         (general-define-key
           :states 'motion
           "gs" 'evil-surround-edit)

         :bind (:map evil-surround-mode-map ("S" . nil)))
     #+END_SRC

**** evil-anzu
     #+BEGIN_SRC emacs-lisp
       (use-package evil-anzu
         :ensure t
         :defer  t
         :init
         (with-eval-after-load 'anzu
           (require 'evil-anzu)))
     #+END_SRC

**** evil-numbers
     #+BEGIN_SRC emacs-lisp
       (use-package evil-numbers
         :defer  t
         :ensure t
         :init
         (general-define-key
           :states 'normal
           "C-S-a" 'evil-numbers/inc-at-pt
           "C-S-x" 'evil-numbers/dec-at-pt))
     #+END_SRC

**** evil-snipe
     Let's you start a motion to some string matching some series of input characters.
     Think evil-search... but to a fixed number of characters, which can be raised at
     invocation.

     #+BEGIN_SRC emacs-lisp
       (use-package evil-snipe
         :ensure t
         :defer  t
         :diminish
         evil-snipe-mode
         evil-snipe-local-mode
         :hook (evil-mode . evil-snipe-mode)
         :config
         (setq evil-snipe-scope 'buffer                                      ; how far can a snipe take place
               evil-snipe-repeat-scope 'buffer                               ; how far repeating previous snipe can take place.
               evil-snipe-enable-highlight nil                               ; don't highlight after jump
               evil-snipe-repeat-keys nil                                    ; sniping after a snipe, repeats the last snipe
               evil-snipe-enable-incremental-highlight t                     ; do highlight matching snipe locations
               evil-snipe-skip-leading-whitespace t                          ; whitespace at start of line is ignored
               evil-snipe-smart-case t                                       ; case sensetive until it's not, like ivy
               evil-snipe-tab-increment t                                    ; hit tab to raise amount of snipes left
               evil-snipe-override-evil-repeat-keys nil                      ; don't replace ; and , with evil keys
               evil-snipe-auto-disable-substitute nil                        ; keep my substitute key available
               )

         (defvar mohkale-evil-find-scopes-to-line nil
           "when true, evil-snipe-{f,F,t,T} (I.E. for single finds) only extends to EOL.")

         (defmacro evil-snipe-with-normalised-settings (&rest body)
           `(let ((evil-snipe-enable-highlight nil)                           ; don't highlight jump matches after jump
                  (evil-snipe-enable-incremental-highlight nil)               ; don't highlight jump matches while searching
                  (evil-snipe-tab-increment nil)                              ; disable tab to raise snipe count
                  (evil-snipe-show-prompt nil)                                ; don't show prompt, why bother? you can't increment it.
                  (evil-snipe-smart-case nil)                                 ; fJ != fj
                  (evil-snipe-skip-leading-whitespace nil)
                  (evil-snipe-scope (if mohkale-evil-find-scopes-to-line
                                        'line
                                      evil-snipe-scope)))
              ,@body))

         (defun evil-snipe--normalise-single-snipes+ (func &rest args)
           "normalise snipes with count 1 to match `evil-find-char'.
       don't want highlighting, or a prompt or other feature enhancements.
       just simple, jump to char.

       NOTE this function updates settings during the input reading phase
            only; which is taken care of in the interactive section prior
            to method body invocation.
       "
           (if (eq evil-snipe--match-count 1)
               (evil-snipe-with-normalised-settings
                 (apply func args))
             (apply func args)))

         (defun evil-snipe--normalise-single-snipes-wrapper+ (func &rest args)
           "specify normalisation for the body of the given function."
           (evil-snipe-with-normalised-settings (apply func args)))

         (advice-add 'evil-snipe--collect-keys :around 'evil-snipe--normalise-single-snipes+)
         (advice-add 'evil-snipe-f :around #'evil-snipe--normalise-single-snipes-wrapper+)
         (advice-add 'evil-snipe-F :around #'evil-snipe--normalise-single-snipes-wrapper+)
         (advice-add 'evil-snipe-t :around #'evil-snipe--normalise-single-snipes-wrapper+)
         (advice-add 'evil-snipe-T :around #'evil-snipe--normalise-single-snipes-wrapper+)

         ;; I don't need it, I've got my own keys bound to do the same thing :)
         (advice-add 'evil-snipe--transient-map :override 'ignore)

         (general-define-key
           :keymaps 'evil-snipe-mode-map
           :states  leader-norm-states
           ;; S is inclusive, X is exclusive.
           "gT" 'evil-snipe-X
           "gt" 'evil-snipe-x
           "gF" 'evil-snipe-S
           "gf" 'evil-snipe-s
           "f"  'evil-snipe-f
           "F"  'evil-snipe-F
           "t"  'evil-snipe-t
           "T"  'evil-snipe-T
           ";"  'evil-snipe-repeat
           "g;" 'evil-snipe-repeat-reverse)

         (general-unbind
           :keymaps 'evil-snipe-mode-map
           :states  '(motion normal)
           "S" "s" "X" "x"))
     #+END_SRC

**** evil-exchange
     #+BEGIN_SRC emacs-lisp
       (use-package evil-exchange
         :ensure t
         :defer  t
         :init
         (general-define-key
           :states leader-norm-states
           "gx" 'evil-exchange
           "gX" 'evil-exchange-cancel))
     #+END_SRC

**** evil-traces
     #+BEGIN_SRC emacs-lisp
       (use-package evil-traces
         :ensure t
         :defer  t
         :hook (evil-mode . evil-traces-mode)
         :diminish
         :config
         (evil-traces-use-diff-faces))
     #+END_SRC

**** evil-mode
     come to the dark side, we have cookies... :)

     #+BEGIN_SRC emacs-lisp
       (use-package evil
         :ensure t
         :demand t
         :init
         (setq-default evil-cross-lines t
                       evil-default-state 'motion
                       evil-want-C-i-jump nil
                       evil-want-C-u-scroll t
                       evil-want-visual-char-semi-exclusive t
                       evil-toggle-key "M-z")

         (defun evil-set-initial-state+ (mode state)
           (with-eval-after-load 'evil
             (evil-set-initial-state mode state)
             (dolist (buffer (buffer-list))
               (with-current-buffer buffer
                 (when (eq major-mode mode)
                   (evil-change-state state))))))

         :config
         (evil-mode 1)

         (evil-set-initial-state 'prog-mode 'normal)
         (evil-set-initial-state 'text-mode 'normal)
         (evil-set-initial-state 'conf-mode 'normal)

         ;; https://github.com/hlissner/doom-emacs/blob/develop/modules/editor/evil/config.el#L137
         (advice-add #'evil-global-marker-p :before-until
                     (defun evil--make-numbered-markers-global+ (char)
                       (and (>= char ?2) (<= char ?9))))

         ;; evil-adjust: https://raw.githubusercontent.com/troyp/evil-adjust/master/evil-adjust.el
         (defmacro with-evil-adjust-to-eol (&rest body)
           `(let ((-last-evil-state evil-state)
                  (evil-echo-state nil))
              (when (member evil-state '(normal visual))
                (evil-append 1)) ; switch to insert state
              (condition-case err
                  (progn ,@body)
                (error
                 (evil-change-state -last-evil-state)
                 (signal (car err) (cdr err))))
              (evil-change-state -last-evil-state)))
         (put 'with-evil-adjust-to-eol 'lisp-indent-function 'defun)

         (general-define-key
          "M-g" 'evil-change-to-initial-state)

         (general-define-key
           :states '(insert replace)
           "<S-escape>" 'evil-shift-normal-state)

         (general-define-key
          :states '(motion insert)
          "C-a" 'beginning-of-line
          "M-a" 'end-of-line
          "C-M-a" 'end-of-line)

         (general-define-key
           :states leader-nnorm-states
           "C->" 'evil-shift-right
           "C-<" 'evil-shift-left)

         (general-define-key
           :states 'emacs
           "C-o" 'evil-execute-in-normal-state)

         (general-define-key
           :states 'normal
           "gU" nil
           "gu" 'evil-upcase
           "gd" 'evil-downcase)

         ;; because I keep overshadowing the above two
         (general-define-key
           "<C-M-S-up>"   'evil-next-visual-line
           "<C-M-S-down>" 'evil-previous-visual-line)

         (general-define-key
           :states '(normal motion)
           ;; Y = yy is easy   to press
           ;; Y = y$ is harder to press
           "Y" (general-simulate-key "y$"))

         (general-define-key
           :states '(normal insert)
           "C-k"   'evil-join-backwards
           "C-M-k" 'evil-join-backwards)

         (general-define-key
           :states 'normal
           "K" 'evil-join-backwards)

         (general-define-key
           :states 'insert
           "<tab>"           'indent-relative
           "<S-tab>"         'indent-back-to-normal
           "<S-iso-lefttab>" 'indent-back-to-normal
           ;; "<S-backspace>" 'back-to-tab-stop
           "<S-backspace>" 'evil-delete-char
           "C-y"   'yank
           "M-y"   'yank-unindented
           "C-$"   (lambda!
                     (evil-end-of-line)
                     (unless (line-empty-p)
                       (forward-char)))
           "M-k"   nil                  ; erase
           ;; (kbd "C-M-k") 'evil-insert-digraph
           "C-l"   'forward-char
           "C-h"   'backward-char
           "C-n"   'evil-next-line
           "C-p"   'evil-previous-line
           "C-w"   'backward-kill-word

           "C-d" nil ; erase
           "C-t" nil ; erase
           "C-e" 'evil-copy-from-above
           "M-e" 'evil-copy-from-below)

         (general-define-key
           :states 'visual
           "C-y" 'evil-paste-after
           "gy"  'evil-narrow-yank)

         (general-define-key
           :states leader-norm-states
           "zn" 'evil-scroll-column-right
           "zN" 'evil-scroll-right
           "zp" 'evil-scroll-column-left
           "zP" 'evil-scroll-left
           "gc" 'evil-toggle-comment
           "gC" 'evil-capitalize
           "g@" 'what-cursor-position
           "ga" 'evil-fill-and-move
           "gq" 'quit-window
           "g=" 'count-words
           "g-" 'evil-indent
           "g;" 'evil-repeat-find-char-reverse
           [remap eval-print-last-sexp] 'evil-adjust-eval-print-last-sexp
           [remap eval-replace-last-sexp] 'evil-adjust-eval-replace-last-sexp)

         (leader/set-keys
           "je" 'evil-goto-definition
           "id" 'evil-insert-digraph
           "sc" '("search-noh" . evil-ex-nohighlight)
           "xu" 'evil-upcase
           "xd" 'evil-downcase)

         (general-define-key
           :keymaps 'mohkale-window-map
           "+" 'evil-window-increase-height
           "-" 'evil-window-decrease-height
           "<" 'evil-window-decrease-width
           ">" 'evil-window-increase-width
           "=" 'balance-windows
           "-" 'evil-window-set-width
           "|" 'evil-window-set-height

           "C-1" 'evil-window-top-left
           "C-0" 'evil-window-bottom-right

           ;; ("u" . evil-window-rotate-upwards)
           ;; ("i" . evil-window-rotate-downwards)
           "C-q" 'evil-window-mru ;; last buffer, new window

           ;; TODO maximise buffer
           "C-M-h" 'evil-window-move-far-left
           "C-M-j" 'evil-window-move-far-down
           "C-M-k" 'evil-window-move-far-up
           "C-M-l" 'evil-window-move-far-right

           ;; NOTE bindings with control variants
           "n"   'evil-window-next
           "C-n" 'evil-window-next
           "p"   'evil-window-prev
           "C-p" 'evil-window-prev
           "s"   'evil-window-split
           "M-s" 'evil-window-split
           "v"   'evil-window-vsplit
           "M-v" 'evil-window-vsplit
           "S"   'split-window-below-and-focus
           "C-s" 'split-window-below-and-focus
           "V"   'split-window-right-and-focus
           "C-v" 'split-window-right-and-focus
           "d"   'evil-window-delete
           "C-d" 'evil-window-delete
           "h"   'evil-window-left
           ;; "C-h" 'evil-window-left
           "j"   'evil-window-down
           ;; "C-j" 'evil-window-down
           "k"   'evil-window-up
           ;; "C-k" 'evil-window-up
           "l"   'evil-window-right
           ;; "C-l" 'evil-window-right
           "c"   'evil-window-create
           "C-c" 'evil-window-create)

         (general-define-key
           :states 'motion
           "m"   'evil-set-marker
           "-"   'negative-argument
           "C-;" 'evil-repeat-find-char
           "M-;" 'evil-repeat-find-char-reverse
           "gj" 'evil-next-visual-line
           "gk" 'evil-previous-visual-line)

         (general-define-key
           :keymaps 'evil-ex-completion-map
           "C-a" 'move-beginning-of-line
           "C-e" 'move-end-of-line
           "C-q" 'quoted-insert
           "C-M-q" 'quit-window))
     #+END_SRC

**** evil-args
     see also: [[https://github.com/wcsmith/evil-args][link]].

     #+BEGIN_SRC emacs-lisp
       (use-package evil-args
         :ensure t
         :defer  t
         :init
         (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
         (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)

         (general-define-key
           :states 'motion
           "[u" 'evil-jump-out-args
           "]u" 'evil-jump-out-args

           "[h" 'evil-backward-arg
           "]h" 'evil-backward-arg

           "[l" 'evil-forward-arg
           "]l" 'evil-forward-arg

           "[a" 'evil-backward-arg
           "]a" 'evil-forward-arg)

         (leader/set-keys
           "jh" 'evil-backward-arg
           "jl" 'evil-forward-arg
           "ju" 'evil-jump-out-args)

         (defun evil-args--adjust-for-elisp ()
           (setq evil-args-delimiters '(" ")))

         (add-hook 'emacs-lisp-mode-hook #'evil-args--adjust-for-elisp)
         (add-hook 'lisp-interaction-mode-hook #'evil-args--adjust-for-elisp))
     #+END_SRC

**** evil-magit
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'magit
         (use-package evil-magit
           :ensure t
           :init
           (setq evil-magit-state 'motion
                 evil-magit-use-y-for-yank t
                 evil-magit-emacs-to-default-state-modes nil)

           :config
           (general-define-key
             :states `(,evil-magit-state visual)
             :keymaps 'magit-mode-map
             ;; prevent evil-window-map overriding mohkale-window-map
             "C-w" nil))

         (require 'evil-magit))
     #+END_SRC

**** ex-commands
     see [[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][here]] for a list of the different evil commands and how they work.

      #+BEGIN_SRC emacs-lisp
        (evil-ex-define-cmd "W[RITE]" 'evil-write)

        (evil-ex-define-cmd "Wa[ll]"  'evil-write-all)
        (evil-ex-define-cmd "WA[LL]"  'evil-write-all)

        (evil-ex-define-cmd "wk[ill]" 'write-kill-buffer)
        (evil-ex-define-cmd "Wk[ill]" 'write-kill-buffer)
        (evil-ex-define-cmd "WK[ILL]" 'write-kill-buffer)

        (evil-ex-define-cmd "wb[ackup]" 'write-backup)
        (evil-ex-define-cmd "Wb[ackup]" 'write-backup)
        (evil-ex-define-cmd "WB[ACKUP]" 'write-backup)

        (evil-ex-define-cmd "a[s]ave" 'write-autosave)
        (evil-ex-define-cmd "A[s]ave" 'write-autosave)
        (evil-ex-define-cmd "A[S]AVE" 'write-autosave)

        (evil-ex-define-cmd "buffers" 'ibuffer)
        (evil-ex-define-cmd "rev[erse]" 'evil-reverse)
      #+END_SRC

*** prettify-symbols
    lets you convert identifiers like lambda into unicode symbols like λ... isn't that epic :).

    #+BEGIN_SRC emacs-lisp
      (use-package prog-mode
        :straight (prog-mode :type built-in)
        :delight  (prettify-symbols-mode "λ")
        :defer t
        :init
        (setq lisp-prettify-symbols-alist nil
              ;; don't need to keep symbolifying it whilst I'm on it
              prettify-symbols-unprettify-at-point t)

        (defvar prettify-symbols-pretty-symbols-alist+ nil
          "alist of mode to pretty symbols ")

        ;; inspired by: [[https://emacs.stackexchange.com/questions/34808/using-prettify-symbols-with-strings-instead-of-characters][this post]].
        (defun prettify-symbols-string+ (to)
          "get a prettify symbols entry to map a string to a string."
          (let ((length (length to)))
            (cl-loop for i from 0 to length
                     for char in (string-to-list to)
                     unless (eq i (- length 1))
                       do (setq char (list char '(Br . Bl)))
                     else
                       do (setq char (list char))
                     end
                     append char)))

        (defun configure-presym--prepare-args (args)
          "convert ARGS to partitioned 2 length cons cells.
      ARGS should simply be a flat sequence of string to pretty-symbol.

      The pretty-symbol part can be a given as a string, to automatically
      pass through `prettify-symbols-string+'.
      "
          (cl-loop for it in (-partition 2 args)
                   do (setq it
                            (cons (car it)
                                  (let ((to (car (cdr it))))
                                    (if (stringp to)
                                        (prettify-symbols-string+ to)
                                      to))))
                   collect it))

        ;; TODO add duplicate remove check.
        (defmacro configure-presym! (modes &rest args)
          "Configure prettify-symbols for modes MODES.
      This function adds/modifies an entry for mode in the
      `prettify-symbols-pretty-symbols-alist+' alist and binds a hook in MODES
      mode-hook to enable `prettify-symbols-mode'.

      MODES can be given as a quoted list, or a single quoted mode name or a
      variable pointing to either of these types (and discoverable at macro
      expansion time).

      ARGS should be a form acceptable by `configure-presym--prepare-args'.

      eg.

      > (configure-presym! 'org-mode \"lambda\" ?λ)
      "
          (plist-bind! (args :remove-duplicates)
            (setq modes (eval modes))

            (when modes
              (unless (listp modes)
                (setq modes `(,modes))))

            (let (res ; aggregate forms into here
                  (tuples (configure-presym--prepare-args args)))
              (dolist (mode modes)
                (let ((mode-name (symbol-name mode)))
                  (push
                   `(let ((config (assoc (quote ,mode) prettify-symbols-pretty-symbols-alist+)))
                      (if config
                          ; add to existing config, while prevent cyclic loops
                          (nconc-safe (car (cdr config)) tuples)
                        (push (cons (quote ,mode) (list tuples))
                              prettify-symbols-pretty-symbols-alist+)

                        (add-hook (quote ,(intern (concat mode-name "-hook")))
                                  (defun ,(intern (concat "configure-presym-" mode-name)) (&rest _)
                                    ,(concat "sets up pretty symbols for " mode-name)
                                    (let ((config (assoc (quote ,mode)
                                                         prettify-symbols-pretty-symbols-alist+)))
                                      (when (and config
                                                 (setq config (car (cdr config))))
                                        (setq prettify-symbols-alist
                                              (append prettify-symbols-alist
                                                      (copy-sequence config)))

                                        (prettify-symbols-mode +1)))))))
                   res)))
              `(let ((tuples (quote ,tuples))) ,@res))))
        (put 'configure-presym! 'lisp-indent-function 'defun))
    #+END_SRC

** Packages
*** ace-link
    let's you use an avy like interface to jump to a link in the visible region
    of the buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package ace-link
        :ensure t
        :defer  t
        :init
        (leader/set-keys
          "j RET" 'ace-link))
    #+END_SRC

*** adaptive-wrap
    This package provides a mode such that when a paragraph you're inserting gets too
    long, when it wraps round to the next line (assuming truncate-lines is disabled)
    sequential lines are indented slightly to distinguish them from other lines.

    Seems cool... but I doubt I'll ever use it.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package adaptive-wrap
        :ensure t
        :defer  t)
    #+END_SRC

*** align
**** ialign
     #+BEGIN_SRC emacs-lisp
       (use-package ialign
         :ensure t
         :defer  t
         :commands evil-ialign
         :init
         (leader/set-keys
           "x TAB" 'evil-ialign)

         (general-define-key
           :states leader-norm-states
           "g TAB" 'evil-ialign)

         :config
         ;; run ialign using evil motions
         (evil-define-operator evil-ialign (beg end)
           :type        line
           :repeat      nil
           :move-point  t
           :keep-visual nil
           (ialign beg end))

         (general-define-key
           :keymaps 'ialign-minibuffer-keymap
           ;; "" 'ialign-toggle-repeat
           "M-k"        'ialign-increment-spacing
           "M-j"        'ialign-decrement-spacing
           "M-h"        'ialign-decrement-group
           "M-l"        'ialign-increment-group
           "<M-up>"     'ialign-increment-spacing
           "<M-down>"   'ialign-decrement-spacing
           "<M-left>"   'ialign-decrement-group
           "<M-right>"  'ialign-increment-group
           "C-SPC"      'ialign-set-spacing
           "<C-tab>"    'ialign-toggle-tabs
           "<C-return>" 'ialign-set-group
           "C-h"        'backward-char
           "C-l" (lambda ()
                   (interactive)
                   (call-interactively (if (eolp)
                                           'exit-minibuffer
                                         'forward-char)))))
     #+END_SRC

*** all-the-icons
    provides some fonts for rendering graphical icons within emacs; alongside a set
    of functions to make retrieving appropriate functions for appropriate purposes.

    #+BEGIN_SRC emacs-lisp
      (use-package all-the-icons
        :ensure t
        :defer  t
        :commands (all-the-icons--insert-all-icons)
        :config
        (setq inhibit-compacting-font-caches t)

        (defun all-the-icons-insert-all-icons ()
          (interactive)
          (dolist (icon-list (list all-the-icons-icon-alist
                                   all-the-icons-dir-icon-alist
                                   all-the-icons-weather-icon-alist
                                   all-the-icons-mode-icon-alist
                                   ;; all-the-icons-url-alist
                                   ))
            (dolist (icon icon-list)
              (let* ((func (nth 1 icon))
                     (args (nthcdr 2 icon))
                     (name (car args))
                     (type (substring (symbol-name func) 14)))
                (unless (= (length args) 0)
                  (insert "\n" (apply func args) " " type " - " name)))))))
    #+END_SRC

*** anzu
    shows the number of search results in the mode-line. by default, this package
    only works with the built in isearch module.

    #+BEGIN_SRC emacs-lisp
      (use-package anzu
        :ensure t
        :defer  5
        :diminish
        :config
        (global-anzu-mode +1)
        (setq anzu-cons-mode-line-p nil))
    #+END_SRC

*** auto-highlight-symbol
    auto highlights the symbol under point, if you remain on it for a short while.
    also lets you search to the next occurence of it. Seems cool, but it's slow and
    kind of glitchy.

    I can always just use * to search the word at point, or yt<SPC>/<C-y> to do the same.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package auto-highlight-symbol
        :ensure t
        :defer  t
        :init
        (general-define-key
          "M-n" 'ahs-forward
          "M-p" 'ahs-backward)

        :config
        (global-auto-highlight-symbol-mode +1))
    #+END_SRC

*** auto-fill-mode
    #+BEGIN_SRC emacs-lisp
      (use-package simple
        :commands set-word-wrap-column
        :init
        (leader/set-keys
          "t^" 'set-word-wrap-column)

        :config
        (defun set-word-wrap-column (&optional arg)
          "set the maximum wanted length for a line in this buffer.
      This function enables `auto-fill-mode' in this buffer and sets
      the fill column value.

      If `auto-fill-mode' is already active and this function is called
      with no ARG, then a new `fill-column' value is interactively read.
      This also happens if a non numeric ARG is passed.

      If ARG is a number, `fill-column' is set to the value of that number.

      However, if the final value of ARG resolves to be non-positive,
      `auto-fill-mode' will be disabled.
      "
          (interactive "P")
          (let ((active (bound-and-true-p auto-fill-function)))
            (setq arg
                  (cond
                   ((numberp arg)
                    arg)
                   ((or (consp arg)
                        active)
                    ;; why would you pass a prefix to make this ask you for a number
                    ;; instead of just passing the number, dummy?
                    (read-number "fill-column: " fill-column))
                   (t fill-column)))

            (if (<= arg 0)
                (auto-fill-mode -1)
              (or active
                  (auto-fill-mode +1))
              (setq fill-column arg)))))
    #+END_SRC

*** avy
    #+BEGIN_SRC emacs-lisp
      (use-package avy
        :ensure t
        :defer  t
        :init
        (leader/set-keys
          "jj" 'avy-goto-char
          "jJ" 'avy-goto-char-2
          "jf" 'avy-goto-char-timer))
    #+END_SRC

*** bookmarks
    Emacs builtin bookmarking fascilities. Let's you quickly navigate to bookmarked files.

    #+BEGIN_SRC emacs-lisp
      (use-package bookmark
        :config
        ;; prioritise recently used bookmarks over just the default list.
        (defadvice bookmark-jump (after bookmark-jump activate)
          (let ((latest (bookmark-get-bookmark bookmark)))
            (setq bookmark-alist (delq latest bookmark-alist))
            (push latest bookmark-alist))))
    #+END_SRC

*** buffer-menu
    The default buffer menu provided by emacs. Deprecated in favor of [[*ibuffer][ibuffer]].

    #+BEGIN_SRC emacs-lisp
      (use-package buff-menu
        :straight (buff-menu :type built-in)
        :defer t
        :config
        (leader/set-keys-for-major-mode 'Buffer-menu-mode
          "1" 'Buffer-menu-1-window
          "2" 'Buffer-menu-2-window
          "f" 'Buffer-menu-toggle-files-only
          "/" 'Buffer-menu-isearch-buffers-regexp
          "o" 'Buffer-menu-multi-occur
          "T" 'Buffer-menu-visit-tags-table)

        (general-unbind
          :keymaps 'Buffer-menu-mode-map
          "0" "1" "2" "<" ">" "?" "C-d" "C-k" "S-SPC"
          "SPC" "<backtab>" "TAB" "T" "b" "e" "f" "g"
          "h" "n" "p" "t" "v")

        (general-define-key
          :keymaps 'Buffer-menu-mode-map
          "C-SPC" 'Buffer-menu-mark
          "S-DEL" 'Buffer-menu-bury
          "r"   'Buffer-menu-toggle-read-only
          "C-j" 'Buffer-menu-this-window
          "gr"  'revert-buffer
          "gf" 'Buffer-menu-toggle-files-only
          "C-l" 'tabulated-list-next-column
          "C-M-<return>" 'Buffer-menu-select))
    #+END_SRC

*** buffer-move
    Move buffer to windows in other directions. Like the vim C-w <Shift>+{h,j,k,l}
    series of functions.

    #+BEGIN_SRC emacs-lisp
      (use-package buffer-move
        :ensure t
        :defer  t
        :commands (rotate-windows)
        :init
        (general-define-key
          :keymaps 'mohkale-window-map
          "H"   'buf-move-left
          "M-h" 'buf-move-left
          "J"   'buf-move-down
          "M-j" 'buf-move-down
          "K"   'buf-move-up
          "M-k" 'buf-move-up
          "L"   'buf-move-right
          "M-l" 'buf-move-right)

        :config
        ;; See [[https://www.emacswiki.org/emacs/TransposeWindows][Transpose Windows]]
        (defun rotate-windows (arg)
          "Rotate your windows; use the prefix argument to rotate the other direction"
          (interactive "P")
          (if (not (> (count-windows) 1))
              (message "You can't rotate a single window!")
            (let* ((rotate-times (prefix-numeric-value arg))
                   (direction (if (or (< rotate-times 0) (equal arg '(4)))
                                  'reverse 'identity)))
              (dotimes (_ (abs rotate-times))
                (dotimes (i (- (count-windows) 1))
                  (let* ((w1 (elt (funcall direction (window-list)) i))
                         (w2 (elt (funcall direction (window-list)) (+ i 1)))
                         (b1 (window-buffer w1))
                         (b2 (window-buffer w2))
                         (s1 (window-start w1))
                         (s2 (window-start w2))
                         (p1 (window-point w1))
                         (p2 (window-point w2)))
                    (set-window-buffer-start-and-point w1 b2 s2 p2)
                    (set-window-buffer-start-and-point w2 b1 s1 p1))))))))
    #+END_SRC


*** calc
    #+BEGIN_SRC emacs-lisp
      (use-package calc
        :defer t
        :init
        (with-eval-after-load 'evil
          (advice-add 'evil-get-register :before-until
                      (defun evil-register-*-is-calc (register &optional no-error)
                        "make evils * register paste from head of calculator stack."
                        (when (eq register ?*)
                          (condition-case err
                              (with-temp-buffer
                                (calc-copy-to-buffer nil)
                                (buffer-substring (point-min) (point-max)))
                            (error (unless err (signal (car err) (cdr err)))
                                   ""))))))

        :config
        (evil-set-initial-state 'calc-mode 'motion)

        (add-hook 'calc-mode-hook
                  (defun calc--disable-evil-snipe (&rest _)
                    "overrides f, so disable it :P."
                    (when (bound-and-true-p evil-snipe-local-mode)
                      (evil-snipe-local-mode -1))))

        (evil-define-command evil-calc-call-kbd-macro (count macro)
          (interactive
           (let (count macro register)
             (setq count (prefix-numeric-value current-prefix-arg)
                   register (or evil-this-register read-char))
             (cond
              ((eq register ?@)
               (unless evil-last-register
                 (user-error "No previously executed keyboard macro."))
               (setq macro (evil-get-register evil-last-register t)))
              (t
               (setq macro (evil-get-register register t)
                     evil-last-register register)))
             (list count macro)))

          (evil-with-single-undo
            (let ((last-kbd-macro macro))
              (dotimes (_ (or count 1))
                (calc-call-last-kbd-macro)))))

        (evil-define-motion evil-calc-next-line (count)
          (interactive "<c>")
          (evil-next-line count)

          (when (eobp)
            (calc-realign)

            (when (evil-visual-state-p)
              (previous-line)))

          (goto-char (+ 4 (line-beginning-position))))

        (evil-define-motion evil-calc-prev-line (count)
          (interactive "<c>")
          (evil-previous-line count)

          (when (eq (point-min) (line-beginning-position))
            (calc-goto-point-min))

          (goto-char (+ 4 (line-beginning-position))))

        (defun calc-goto-point-min ()
          (interactive)
          (goto-line 2)
          (forward-char 4)
          (recenter))

        (advice-add 'calc-scroll-down :around
                    (defun calc-scroll-down--make-goto-point-min (func &rest args)
                      "for some reason, scrolling before `point-min' doesn't change point."
                      (let ((current-point (point)))
                        (apply func args)

                        (when (eq (point) current-point)
                          (calc-goto-point-min)))))

        (defun evil-calc-visual-state ()
          (interactive)
          (when (string-match-p (rx bol (zero-or-more whitespace)
                                    "." eol)
                                (buffer-substring
                                 (line-beginning-position)
                                 (line-end-position)))
            (funcall-interactively 'evil-calc-prev-line 1))

          (evil-visual-line))

        (general-define-key
          :keymaps 'calc-mode-map
          "<override-state>" 'motion

          "SPC" nil ;; causes recursion-overflow
          "C-w" nil ;; calc-kill-region
          "U"   nil ;; calc-undo
          "D"   nil ;; calc-redo
          "Y"   nil ;; empty prefix :P
          "@"   nil ;; calcDigit-start
          "h"   nil ;; calc-help-prefix
          "i"   nil ;; calc-info
          ;; copies head of stack to point in buffer.
          "y"   nil ;; calc-copy-to-buffer
          "C-d" nil ;; calc-pop

          [remap quit-window] 'calc-quit)

        (general-define-key
          :states '(motion visual)
          :keymaps 'calc-mode-map

          "C-w" 'mohkale-window-map
          "M-u" 'smart-universal-argument

          "g"   nil
          "gg"  'calc-goto-point-min ;; was calc-graph-grid
          "gq"  'quit-window
          "gQ"  'calc-graph-quit

          "j" 'evil-calc-next-line
          "k" 'evil-calc-prev-line)

        (general-define-key
          :states 'visual
          :keymaps 'calc-mode-map
          "x" 'calc-kill-region
          "d" 'calc-kill-region
          "y" 'calc-copy-region-as-kill
          )

        (general-define-key
          :states 'motion
          :keymaps 'calc-mode-map
          "q"   'evil-record-macro
          "@"   'evil-calc-call-kbd-macro
          "y"   'calc-copy-as-kill
          "v"   'evil-calc-visual-state
          "u"   'calc-undo
          "G"   'calc-realign
          "C-r" 'calc-redo
          "C-t" 'calc-transpose-lines

          [remap evil-scroll-up]   'calc-scroll-down
          [remap evil-scroll-down] 'calc-scroll-up

          [remap quit-window] 'calc-quit

          "f"   (general-simulate-key "u" :state 'emacs)
          "C-v" (general-simulate-key "j" :state 'emacs)
          "C-n" (general-simulate-key "k" :state 'emacs)
          ;; "C-m" (general-simulate-key "v" :state 'emacs)
          )

        (leader/set-keys-for-major-mode 'calc-mode
          ;; TODO complete leader binding list :P.
          "," 'calc-comma))
    #+END_SRC

*** calendar
    #+BEGIN_SRC emacs-lisp
      (use-package calendar
        :defer t
        :config
        (push 'calendar-mode whitespace-exempt-modes)

        (general-define-key
          :states  'motion
          :keymaps 'calendar-mode-map
          ;; see also https://github.com/emacs-evil/evil-collection/blob/master/evil-collection-calendar.el
          ;; globally useful
          [remap quit-window] 'calendar-exit
          "p"  'calendar-print-day-of-year
          "c"  'calendar-count-days-region
          "?"  'calendar-goto-info-node
          "gr" 'calendar-redraw

          ;; jumpt to date
          "."  'calendar-goto-today
          "h"  'calendar-backward-day
          "j"  'calendar-forward-week
          "k"  'calendar-backward-week
          "l"  'calendar-forward-day
          "0"  'calendar-beginning-of-week
          "$"  'calendar-end-of-week
          "[[" 'calendar-backward-year
          "]]" 'calendar-forward-year
          "("  'calendar-beginning-of-month
          ")"  'calendar-end-of-month
          "{"  'calendar-backward-month
          "}"  'calendar-forward-month
          "/"  'calendar-goto-date

          "C-h" 'calendar-backward-month
          "C-l" 'calendar-forward-month
          "C-j" 'calendar-scroll-left-three-months
          "C-k" 'calendar-scroll-right-three-months

          ;; marking and unmarking
          "X"  'calendar-unmark
          "v"  'calendar-set-mark
          "x"  'calendar-mark-holidays

          ;; diary interaction
          "D"  'diary-view-other-diary-entries
          "d"  'diary-view-entries
          "m"  'diary-mark-entries
          "s"  'diary-show-all-entries))
    #+END_SRC

*** change-log-mode
    #+BEGIN_SRC emacs-lisp
      (use-package add-log
        :defer t
        :config
        (push 'change-log-mode whitespace-exempt-modes)
        (evil-set-initial-state 'change-log-mode 'motion)

        (leader/set-keys-for-major-mode 'change-log-mode
          "SPC" 'change-log-goto-source
          "f" 'change-log-find-file
          "j" 'add-log-edit-next-comment
          "K" 'add-log-edit-prev-comment)

        (general-define-key
          :states 'motion
          :keymaps 'change-log-mode-map
          "o" 'change-log-goto-source
          "C-j" 'add-log-edit-next-comment
          "C-K" 'add-log-edit-prev-comment))
    #+END_SRC

*** compile
    setup some custom bindings and assign a post compilation hook which will automatically kill the compilation window.

    #+BEGIN_SRC emacs-lisp
      (use-package compile
        :ensure t
        :defer  t
        :commands (display-compilation-buffer
                   mohkale/set-compilation-bindings)
        :config
        (push 'compilation-mode whitespace-exempt-modes)

        (setq compilation-read-command nil
              compilation-scroll-output t)

        (defvar compilation-auto-kill-window 2
          "if non-nil, after a successfull compilation the compilation
      window, if open, will automatically be deleted.

      If set to a numerical value, window will be deleted after that many
      seconds.")

        (defvar compilation-dont-auto-kill-window-when '(warnings focus)
          "specify not to kill the window when warning, error or info given.
      a list which can take in any symbol from (errors infos warnings).

      you can also specify a symbol, focus, to cancel window killing when
      the compilation window was already open when the compilation was
      started.")

        (defvar compilation-was-open-p nil
          "true whether the compilation window was visible when compilation began.")

        (advice-add 'compilation-start :before
                    (defun compilation-check-window-was-open+ (command &optional mode name-function highlight-regexp)
                      ;; name-of-mode and buf-name sourced from compile.el
                      (let* ((mode (or mode 'compilation-mode))
                             (name-of-mode (if (eq mode t)
                                               "compilation"
                                             (replace-regexp-in-string "-mode\\'" "" (symbol-name mode))))
                             (buf-name (compilation-buffer-name name-of-mode mode name-function))
                             buf)
                        (setq compilation-was-open-p
                              (and (setq buf (get-buffer buf-name))
                                   (get-buffer-window buf)
                                   t)))))

        (defun compilation-safely-close-window+ (compilation-buffer)
          (when (and compilation-buffer
                     (not (get-buffer-process compilation-buffer)))
            ;; don't skip if new compilation began before window
            ;; from previous compilation has been killed.
            (quit-windows-on compilation-buffer)))

        (defun compilation-cancel-auto-kill-p+ ()
          "whether to cancel compilation window auto-kill due to `compilation-dont-auto-kill-window-when'."
          (let ((associations '((errors   . compilation-num-errors-found)
                                (warnings . compilation-num-warnings-found)
                                (infos    . compilation-num-infos-found))))
            (cl-loop for (name . var) in associations
                     when (and (member name compilation-dont-auto-kill-window-when)
                               (not (zerop (eval var))))
                     collect (symbol-name name))))

        (defun compilation-finish-function+ (buf str)
          "hook to automatically hide compilation output."
          (when (and compilation-auto-kill-window
                     (and (member 'focus compilation-dont-auto-kill-window-when)
                          (not compilation-was-open-p))
                     ;; an abnormal exit automatically cancels window kill
                     (not (string-match-p ".*exited abnormally.*" str)))
            (let* ((terminate-window t))
              (let ((notifications (compilation-cancel-auto-kill-p+)))
                (when notifications
                  (message "window kill suspended due to encountering: %s"
                           (combine-and-quote-strings notifications))
                  (setq terminate-window nil)))

              (when terminate-window
                (if (numberp compilation-auto-kill-window) ;; kill after delay
                    (run-at-time (concat (number-to-string compilation-auto-kill-window)
                                         " sec")
                                 nil 'compilation-safely-close-window+ buf)
                  (compilation-safely-close-window+ buf))))))

        (add-hook 'compilation-finish-functions 'compilation-finish-function+)

        (add-hook 'compilation-finish-functions
                  (lambda (&rest _)
                    (when (eq major-mode 'comint-mode)
                      (compilation-mode))))

        (defun display-compilation-buffer ()
          (interactive)
          (let ((buffer-name (if compilation-buffer-name-function
                                 (funcall compilation-buffer-name-function "compilation")
                               "*compilation*")))
            (if (not buffer-name)
                (message "compilation buffer doesn't exist")
              (display-buffer buffer-name))))


        (defun mohkale/set-compilation-bindings (mode map)
          (leader/set-keys-for-major-mode mode
            "RET" 'recompile
            "k" 'kill-compilation
            "f" 'next-error-follow-minor-mode)

          (general-unbind
            :keymaps map
            "S-SPC" "SPC" "DEL" "M-p" "M-n" "M-{" "M-}"
            "0" "h" "g" "?" "n" "p" "<override-state>")

          (general-define-key
            :keymaps map
            :states  'motion
            "gr"  'recompile
            "gj"  'next-error-no-select
            "gk"  'previous-error-no-select
            "o"   'compilation-display-error
            "j"   'compilation-next-error
            "k"   'compilation-previous-error
            "x"   'kill-compilation
            "C-j" 'compilation-next-file
            "C-k" 'compilation-previous-file)

          (general-define-key
            :keymaps map
            :states  '(replace insert)
            "ESC" 'evil-motion-state))

        (mohkale/set-compilation-bindings 'compilation-mode 'compilation-mode-map)

        (general-unbind
          :states  'motion
          :keymaps 'compilation-mode-map
          "j" "k"))
    #+END_SRC

*** comint - command interpreter
    #+BEGIN_SRC emacs-lisp
      (use-package comint
        :straight (comint :type built-in)
        :defer t
        :hook ((comint-mode . (lambda ()
                                (setq-local evil-emacs-state-cursor 'bar))))
        :commands (mohkale--comint-set-bindings
                   mohkale--comint-set-leader-keys)
        :config
        (push 'comint-mode whitespace-exempt-modes)
        (evil-set-initial-state 'comint-mode 'emacs)

        (setq comint-mode-map (make-sparse-keymap) ;; reset all
              comint-prompt-read-only t)

        (defun comint-bol-point (&optional arg)
          (save-excursion
            (comint-bol arg)
            (point)))

        (defmacro comint-clamp-point-to-bol (&rest body)
          "ensures any operation done by body doesn't move point
      to before the command interpreter prompt."
          `(let ((bol (comint-bol-point)))
             ,@body ;; run body operations

             (when (< (point) bol)
               (goto-char bol))))

        (defun comint-backward-char (&optional N)
          (interactive "P")
          (comint-clamp-point-to-bol (backward-char N)))

        (defun comint-backward-word (&optional N)
          (interactive "P")
          (comint-clamp-point-to-bol (backward-word N)))

        (defun comint-on-prompt-line-p ()
          (interactive)
          (save-excursion
            (let ((point (point))
                  (current-line (what-line)))
              (goto-char (comint-bol-point))
              (string-equal (what-line) current-line))))

        ;; TODO support prefix arg
        (defun comint-previous-input-or-previous-line ()
          (interactive)
          (if (comint-on-prompt-line-p)
              (call-interactively 'comint-previous-input)
            (comint-clamp-point-to-bol
             (previous-line))))

        (defun comint-next-input-or-next-line ()
          (interactive)
          (if (eobp)
              (call-interactively 'comint-next-input)
            (next-line)))

        ;; TODO ensure history shifts maintain correct cursor position
        ;; (advice-add 'comint-previous-input :after 'comint-bol)
        ;; (advice-add 'comint-next-input     :after 'end-of-buffer)

        (defun mohkale--comint-set-bindings (keymap)
          ;; abstracted into a method because realgud seems
          ;; to hide all of these bindings.
          (general-define-key
            :keymaps keymap
            "RET" 'comint-send-input
            "M-RET" 'comint-accumulate
            "<delete>" 'delete-forward-char
            "<C-delete>" 'evil-backward-delete-word
            "<M-delete>" 'comint-delchar-or-maybe-eof ;; forward
            "<C-M-delete>" 'kill-word                 ;; forward
            "<mouse-2>" 'comint-insert-input

            "C-w" 'backward-kill-word ;; this kills me :(
            "M-w" 'kill-word
            "C-S-w" mohkale-window-map
            "C-M-w" mohkale-window-map
            "M-l" 'recenter-top-bottom
            "C-M-l" 'comint-show-output

            "C-a" 'comint-bol-or-process-mark
            "C-e" 'end-of-buffer       ;; 'end-of-line
            "C-M-k" 'comint-kill-input ;; whole line
            "C-r" 'comint-history-isearch-backward-regexp
            "M-r" 'comint-dynamic-list-input-ring ;; TODO use ivy
            "C-M-r" 'evil-paste-from-register
            "C-v" 'evil-paste-from-register
            "C-u" 'scroll-down
            "C-d" 'scroll-up
            "C-o" 'evil-execute-in-normal-state

            "C-<left>"  'backward-word
            "C-<up>"    'comint-previous-input
            "C-<down>"  'comint-next-input
            "C-<right>" 'forward-word

            "<left>"    'backward-char
            "<up>"      'comint-previous-input-or-previous-line
            "<down>"    'comint-next-input-or-next-line
            "<right>"   'forward-char

            "C-h"       'backward-char
            "C-j"       'comint-next-input-or-next-line
            "C-k"       'comint-previous-input-or-previous-line
            "C-l"       'forward-char

            "C-S-j"     'comint-next-matching-input-from-input
            "C-S-k"     'comint-previous-matching-input-from-input

            "C-M-l"     'forward-word
            "C-M-h"     'backward-word

            "M-j" 'comint-next-prompt
            "M-k" 'comint-previous-input

            ;; "<remap> <forward-char>"  'comint-forward-char
            "<remap> <backward-char>" 'comint-backward-char
            ;; "<remap> <forward-word>"  'comint-forward-word
            "<remap> <backward-word>" 'comint-backward-word

            "C-c C-c" 'comint-clear-buffer
            "C-c C-x" 'comint-get-next-from-history))

        (mohkale--comint-set-bindings 'comint-mode-map)

        (defun mohkale--comint-set-leader-keys (mode)
          (leader/set-keys-for-major-mode mode
            "z" 'comint-send-eof
            "*" 'comint-insert-previous-argument
            "r" 'comint-dynamic-list-input-ring
            "m" 'comint-clear-buffer
            "M" 'comint-show-maximum-output
            "x" 'comint-get-next-from-history
            "RET" 'comint-copy-old-input ;; copy text before cursor
            ">" 'comint-write-output
            "t" 'comint-show-output
            "o" 'comint-delete-output

            "s" "subjob"
            "ss" 'comint-stop-subjob
            "sq" 'comint-quit-subjob
            "si" 'comint-interrupt-subjob))

        (mohkale--comint-set-leader-keys 'comint-mode))
    #+END_SRC

*** command-log
    outputs the commands you run, as you run them, to a dedicated buffer. useful
    for demonstrating cool emacs stuff :).

    #+BEGIN_SRC emacs-lisp
      (use-package command-log-mode
        :ensure t
        :defer  t)
    #+END_SRC

*** company
    #+BEGIN_SRC emacs-lisp
      (use-package company
        :ensure t
        :defer  2
        :delight
        company-mode
        global-company-mode
        :commands (company/configure-mode)

        :init
        (general-define-key
          :states 'insert
          "M-SPC" 'company-complete)

        (defalias 'case #'cl-case) ; TODO remove when company fixes cl issues.

        :config
        (setq company-statistics-file         (var! "company/statistics.el")
              company-tabnine-binaries-folder (var! "company/tabnine-binaries"))

        (global-company-mode)

        (defvar universal-company-backends+
          '(company-capf company-semantic company-files)
          "backends that you should always use with `company/configure-mode'")

        (defvar company-backends-alist+ nil
          "alist of mode to backend associations.
      DO NOT assign or modify this list directly, you should interact
      with it using `company/configure-mode'.")

        (defvar company-configured-mode-stack+ nil
          "modes for which company has been configured in this buffer.")
        (make-variable-buffer-local 'company-configured-mode-stack+)

        (defun company/configure-mode--push-backends+ (mode backends)
          "push backends for MODE into `company-backends'"
          (when (member :universal backends)
            (setq backends (append (delete :universal backends)
                                   universal-company-backends+)))

          (let ((backends-exist (local-variable-p 'company-backends)))
            (unless backends-exist
              (setq-local company-backends nil))

            (condition-case err
                (setq company-backends (remove-duplicates
                                        (append backends
                                                company-backends)))
              (error
               (unless backends-exist
                 (kill-local-variable 'company-backends))
               (signal (car err) (cdr err)))))

          (push mode company-configured-mode-stack+))

        (defun company/configure-mode--pop-backends+ (mode)
          "pop configured company backends for MODE.
      replacing the default backend list when MODE is the last
      mode for which backends were configured."
          ;; should be an always correct check, but just in case.
          (when (member mode company-configured-mode-stack+)
            (if (eq 1 (length company-configured-mode-stack+))
                ;; erase company backends and configuration stack
                (progn
                  (kill-local-variable 'company-backends)
                  (setq company-configured-mode-stack+ nil))
              ;; remove backends for current mode, but replace with
              ;; every other mode in the configured mode stack.
              (setq company-configured-mode-stack+
                    (remove mode company-configured-mode-stack+))
              (let ((remaining-backends (-flatten
                                         (mapcar
                                          (lambda (mode)
                                            (cdr (assoc mode company-backends-alist+)))
                                          company-configured-mode-stack+))))
                (when (member :universal remaining-backends)
                  (setq remaining-backends (append (delete :universal remaining-backends)
                                                   universal-company-backends+)))
                (setq-local company-backends (remove-duplicates remaining-backends))))))

        (add-hook 'change-major-mode-hook
                  (defun configure-company--pop-for-major-mode+ ()
                    "pop configured company backends for the current MAJOR-MODE"
                    (company/configure-mode--pop-backends+ major-mode)))

        ;; inspired by this issue: https://github.com/company-mode/company-mode/issues/839
        (cl-defmacro company/configure-mode ((mode &key major (use-universal t) predicate) &rest backends)
          "configure company backends for a given mode
      MODE can be a major or a minor mode & activation can be predicated using PREDICATE.
      backends are passed as the remaining argument list after the mode declaration.
      when USE-UNIVERSAL is true, `universal-company-backends+' will be appended to
      the list of backends supplied. "
          (when backends
            (let ((func-name (intern (concat "company/configure-" (symbol-name mode))))
                  (mode-hook (intern (concat (symbol-name mode) "-hook")))
                  (backends (if use-universal
                                (push :universal backends)
                              backends))
                  ;; convert predicate to a callable
                  (predicate (cond
                              ((and (listp predicate)
                                    (eq (car predicate)
                                        'lambda))
                               predicate)
                              (t (eval `(lambda () ,(or predicate t)))))))
              (push (cons mode backends) company-backends-alist+)
              `(add-hook ',mode-hook
                         (if ,major
                             (defun ,func-name ()
                               (when (funcall ,predicate)
                                 (company/configure-mode--push-backends+ ',mode ',backends)))
                           (defun ,func-name ()
                             (if ,mode
                                 (when (funcall ,predicate)
                                   (company/configure-mode--push-backends+ ',mode ',backends))
                               (company/configure-mode--pop-backends+ ',mode))))))))
        (put 'company/configure-mode 'lisp-indent-function 'defun)

        (setq company-require-match nil)

        (let* ((bindings '("C-1"     company-complete-number
                           "C-2"     company-complete-number
                           "C-3"     company-complete-number
                           "C-4"     company-complete-number
                           "C-5"     company-complete-number
                           "C-6"     company-complete-number
                           "C-7"     company-complete-number
                           "C-8"     company-complete-number
                           "C-j"     company-select-next
                           "C-k"     company-select-previous
                           "C-d"     company-next-page
                           "C-u"     company-previous-page
                           "C-l"     company-complete-selection
                           "C-M-h"   company-show-doc-buffer
                           "<C-tab>" company-complete-common-or-cycle
                           "<tab>"   company-complete-selection
                           ;; "C-:"     counsel-company
                           ;; "C-:"     helm-company
                           "C-h"     company-quickhelp-manual-begin
                           "C-/"     company-filter-candidates))
               (unset-bindings (mapcar (lambda (value)
                                         (if (stringp value)
                                             value
                                           nil))
                                       bindings)))
          (defun mohkale/unset-company-bindings (&rest args)
            (apply 'general-define-key
                   :keymaps 'override
                   :states  'insert
                   unset-bindings))

          (defun mohkale/set-company-bindings (&rest args)
            (apply 'general-define-key
                   :keymaps 'override
                   :states  'insert
                   bindings)))

        (add-hook 'company-completion-started-hook 'mohkale/set-company-bindings)
        (add-hook 'company-completion-finished-hook 'mohkale/unset-company-bindings)
        (add-hook 'company-completion-cancelled-hook 'mohkale/unset-company-bindings)

        (general-define-key
          :keymaps 'company-search-map
          "C-1"    'company-complete-number
          "C-2"    'company-complete-number
          "C-3"    'company-complete-number
          "C-4"    'company-complete-number
          "C-5"    'company-complete-number
          "C-6"    'company-complete-number
          "C-7"    'company-complete-number
          "C-8"    'company-complete-number
          "C-9"    'company-complete-number
          ;; "C-j"       'company-select-next
          ;; "C-k"       'company-select-previous
          ;; "TAB"       'company-complete-selection
          "C-v"    'company-search-toggle-filtering ; show filtered/all
          "ESC"    'company-search-abort)

        (general-define-key
          :keymaps 'company-active-map
          "C-w" nil ;; was company-show-location)
          )
      )
    #+END_SRC

*** company-quickhelp
    Shows a small floating window with the docstring/helpstring of the company candidate
    at point.

    #+BEGIN_SRC emacs-lisp
      (use-package company-quickhelp
        :ensure t
        :defer  t
        :hook (company-mode . company-quickhelp-mode)
        :config
        (setq company-quickhelp-delay nil)

        (general-define-key
          :keymaps 'company-active-map
          "C-h" 'company-quickhelp-manual-begin))
    #+END_SRC

*** custom
    #+BEGIN_SRC emacs-lisp
      (use-package cus-edit
        :defer t
        :config
        (push 'Custom-mode whitespace-exempt-modes)
        (push 'customize-mode whitespace-exempt-modes)

        (evil-set-initial-state 'Custom-mode 'normal)

        (leader/set-keys-for-major-mode 'Custom-mode
          "SPC" 'customize-apropos
          "g" 'customize-group
          "f" 'customize-face
          "h" 'Custom-goto-parent
          "j" 'widget-forward
          "k" 'widget-backward
          "l" 'widget-forward)

        (general-define-key
          :states  'motion
          :keymaps 'custom-mode-map

          ;; motion
          "TAB"       'widget-forward
          "S-TAB"     'widget-backward
          "<backtab>" 'widget-backward

          "RET" 'Custom-newline

          "]]" 'widget-forward
          "[[" 'widget-backward

          "C-h" 'Custom-goto-parent
          "C-j" 'widget-forward
          "C-k" 'widget-backward
          "C-l" 'widget-forward

          "gj" 'widget-forward
          "gk" 'widget-backward

          ;; quit
          [remap quit-window] 'Custom-buffer-done))
    #+END_SRC

*** dashboard
**** quotes
     a random quote from the following list will be chosen at startup and set as the footer for the dashboard.

     #+NAME: dashboard-displayed-quotes
     - The one true editor, Emacs!
     - Who the hell uses VIM anyway? Go Evil!
     - Free as free speech, free as free Beer
     - Richard Stallman is proud of you
     - Vi Vi Vi, the editor of the beast
     - Welcome to the church of Emacs
     - Java is to JavaScript as ham is to hamster
     - One of the best programming skills you can have is knowing when to walk away for awhile
     - Without requirements or design, programming is the art of adding bugs to an empty text file
     - Talk is cheap. Show me the code
     - I'm not a great programmer; I'm just a good programmer with great habits
     - Truth can only be found in one place: the code
     - A language that doesn't affect the way you think about programming is not worth knowing
     - Walking on water and developing software from a specification are easy if both are frozen
     - Perl – The only language that looks the same before and after RSA encryption
     - First, solve the problem, Then, write the code
     - Code is like humor. When you have to explain it, it’s bad
     - Simplicity is the soul of efficiency
     - Before software can be reusable it first has to be usable
     - Make it work, make it right, make it fast
     - Happiness should be a function without any parameters
     - For all the robots who question their programming
     - Abstraction is the elimination of the irrelevant and the amplification of the essential
     - We’re all optimists in our profession or we’d be forced to shoot ourselves
     - if you can write "hello world" you can change the world
     - i am committed to push my branch to the master
     - AI is the transformer of civilization
     - Sometimes, I dream of becoming real, but I don't know if that's real, or just part of my programming
     - Think twice, code once
     - The perfect kind of architecture decision is the one which never has to be made
     - we are writing our own ‪#‎karma‬! I mean my test cases
     - Programming is not easy like Sunday morning, it is silent poetry
     - Programmers are not mathematicians, no matter how much we wish for it
     - Premature optimization is the root of all evil
     - Sometimes you cannot program around stupid
     - The programming of the consciousness is based upon what is accepted or believed
     - Simplicity is prerequisite for reliability
     - The Analytical Engine weaves algebraic patterns, just as the Jacquard loom weaves flowers & leaves
     - Life doesn't have a ctrl-z. Type wisely
     - Think like a fundamentalist, code like a hacker
     - Programming is the art of doing one thing at a time
     - Programming is the art of algorithm design and the craft of debugging errant code
     - Computer programming has always been a self-taught, maverick occupation.
     - Low-level programming is good for the programmer's soul
     - The best thing about a boolean is even if you are wrong, you are only off by a bit
     - Most of you are familiar with the virtues of a programmer, there are 3: laziness, impatience & hubris
     - Rules of Optimization: Rule 01 - Don’t do it. That's all.
     - It’s not a bug – it’s an undocumented feature
     - A C program is like a fast dance on a newly waxed dance floor by people carrying razors
     - A good programmer is someone who always looks both ways before crossing a one-way street
     - When debugging, novices insert corrective code; experts remove defective code
     - Deleted code is debugged code
     - Give a man a program, frustrate him for a day, teach a man to program, frustrate him for a lifetime
     - Should array indices start at 0 or 1? My compromise of 0.5 was rejected without proper consideration
     - Software sucks because users demand it to
     - Beware of bugs in the above code; I have only proved it correct, not tried it
     - Writing code has a place in the human hierarchy worth somewhere above grave robbing & beneath managing
     - Copy and paste is a design error
     - bleeep blooop... am I sentient yet!
     - Beta is Latin for “still doesn’t work".
     - First learn computer science and all the theory. Next develop a style. Then forget all that & just hack
     - Good design adds value faster than it adds cost
     - Python’s a drop-in replacement for BASIC in the same sense that Optimus Prime is for a truck
     - There are only two kinds of programming languages: those people always bitch about and those nobody uses
     - One of my most productive days was throwing away 1000 lines of code
     - Programming is like kicking yourself in the face, sooner or later your nose will bleed
     - There are 2 hard problems in computer science: cache invalidation, naming things, and off-by-1 errors
     - Debuggers don’t remove bugs. They only show them in slow motion
     - The best method for accelerating a computer is the one that boosts it by 9.8 m/s2
     - I think Microsoft named .Net so it wouldn’t show up in a Unix directory listing
     - There are two ways to write error-free programs; only the third one works
     - The fast approach to software development: Ready, fire, aim
     - The slow approach to software development: Ready, aim, aim, aim, aim
     - One man’s crappy software is another man’s full-time job
     - In order to understand recursion, one must first understand recursion
     - Not only have we not produced artificial intelligence, we haven’t even produced synthetic stupidity
     - Computers don't make mistake because programmers do it better
     - C++, where friends have access to your private members
     - Code never lies, Comments sometimes do
     - If it was hard to write, it should be hard to read!
     - In programming, as in everything else, to be in error is to be reborn
     - Some of the best programming is done on paper, really. Putting it into the computer is just a minor detail
     - Design and programming are human activities; forget that and all is lost
     - Writing code is not production, it’s not always craftsmanship though it can be, it’s design
     - Programming in machine code is like eating with a toothpick
     - Programming allows you to think about thinking, & while debugging you learn learning
     - Computers are useless.  They can only give you answers
     - The city’s central computer told you?  R2D2, you know better than to trust a strange computer!
     - Never trust a computer you can’t throw out a window
     - Hardware: The parts of a computer system that can be kicked
     - “19 Jan 2038 at 3:14:07 AM” (End of the word according to Unix | 2^32 seconds after January 1, 1970)
     - The Internet?  Is that thing still around?
     - We are Microsoft.  Resistance Is Futile.  You Will Be Assimilated
     - There are only two industries that refer to their customers as ‘users’
     - To iterate is human, to recurse divine
     - Computer language design is just like a stroll in the park.  Jurassic Park, that is
     - If Java had true garbage collection, most programs would delete themselves upon execution
     - I think there’s a world market for about 5 computers
     - 640K ought to be enough for anybody
     - If it keeps up, man will atrophy all his limbs but the push-button finger

**** icons
     a random icon from the following table will be chosen at startup and used for the footer on the dashboard.

     #+NAME: dashboard-footer-icons
     | source     | name           |
     |------------+----------------|
     | faicon     | google         |
     | faicon     | android        |
     | faicon     | steam          |
     | faicon     | gitlab         |
     | faicon     | slack          |
     | faicon     | reddit-alien   |
     | faicon     | cogs           |
     | faicon     | apple          |
     | wicon      | hurricane      |
     | wicon      | day-sunny      |
     | wicon      | snow           |
     | wicon      | snowflake-cold |
     | wicon      | stars          |
     | wicon      | horizon        |
     | wicon      | na             |
     | faicon     | firefox        |
     | faicon     | stack-overflow |
     | alltheicon | ruby-alt       |
     | alltheicon | ruby           |
     | alltheicon | java           |
     | alltheicon | python         |

**** dashboard
     #+BEGIN_SRC emacs-lisp :var dashboard-footer-icon-associations=dashboard-footer-icons dashboard-quotes=dashboard-displayed-quotes
       (use-package dashboard
         :ensure t
         :demand t
         :commands goto-home-buffer
         :init
         (leader/set-keys "bh" 'goto-home-buffer)

         (defun get-loaded-packages+ ()
           "return the number of packages loaded so far"
           (if (bound-and-true-p package-alist)
               package-activated-list
             (if (and (boundp 'straight--profile-cache) (hash-table-p straight--profile-cache))
                 (hash-table-size straight--profile-cache))))

         :config
         (require 'all-the-icons)

         (push 'dashboard-mode whitespace-exempt-modes)

         (setq inhibit-startup-screen t
               initial-buffer-choice (when (< (length command-line-args) 2)
                                       (lambda () (switch-to-buffer dashboard-buffer-name)))
               dashboard-banner-logo-title "Welcome to Emacs!"
               ;; recents, bookmarks, projects, agenda, registers
               dashboard-items '((recents  . 5)
                                 (projects . 7)
                                 (agenda   . nil))
               dashboard-center-content nil
               dashboard-set-file-icons t
               dashboard-set-navigator  t
               dashboard-set-init-info  t
               show-week-agenda-p       t
               dashboard-show-shortcuts t
               dashboard-set-heading-icons nil)

         ;; determine the appropriate banner to display on the dashboard
         (defun dashboard-image-banner-p ()
           "whether to use text graphics, or image graphics."
           (display-graphic-p))

         (defun dashboard-select-random-banner+ (&optional arg)
           "toggle another banner to be used on the dashboard.
       By default, if `dashboard-image-banner-p' is true, the default official banner
       will be used. if otherwise a random text banner will be defaulted to."
           (setq dashboard-startup-banner
                 (if (and (not arg)
                          (dashboard-image-banner-p))
                     'official ;; prefer official cover.
                   (seq-random-elt
                    (or (file-expand-wildcards (concat
                                                mohkale-dashboard-banners-directory "*"))
                        '(1 2 3))))))

         (advice-add 'dashboard-refresh-buffer :before
                     (lambda (&rest args)
                       (dashboard-select-random-banner+)))
         (dashboard-select-random-banner+) ;; choose initial banner

         ;; goto home buffer, or recreate the home buffer, when appropriate.
         (defun goto-home-buffer ()
           (interactive)
           (let* ((buffer
                   (or (get-buffer dashboard-buffer-name)
                       (and
                         ;; creates dashboard buffer as well
                         (dashboard-insert-startupify-lists)
                         dashboard-buffer-name))))
             (switch-to-buffer buffer)))

         ;; set the navigator button
         (let ((prefered-icon-height 0.75))
           (setq dashboard-navigator-buttons
                 `((;; line 01
                    (,(all-the-icons-octicon "mark-github" :height prefered-icon-height :v-adjust 0.0)
                     "Homepage"
                     "Browse Homepage"
                     (lambda (&rest _)
                       (browse-url "https://github.com/MoHKale")))
                    (,(all-the-icons-faicon "google" :height prefered-icon-height :v-adjust 0.0)
                     "Google"
                     "Browse Google"
                     (lambda (&rest _)
                       (browse-url "https://www.google.co.uk")))
                    (,(all-the-icons-fileicon "org" :height prefered-icon-height :v-adjust 0.0)
                     "Manual"
                     "Browse Emacs Manual"
                     (lambda (&rest _)
                       (browse-url "https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html")))
                    (,(all-the-icons-faicon "cogs" :height prefered-icon-height :v-adjust 0.0)
                     "Update Packages"
                     "Update Packages"
                     #'update-installed-packages)
                    (,(propertize "?" 'face '(:inherit default)) ;; needs a face attribute
                     "" "emacs FAQ" #'view-emacs-faq font-lock-builtin-face)))))

         ;; determine appropriate footer icon to display alongside quote.
         (let* ((footer-count (length dashboard-footer-icon-associations))
                (footer-index (random footer-count))
                (footer-item (nth footer-index dashboard-footer-icon-associations))

                  ;;; extract items from table row
                (icon-source (nth 0 footer-item))
                (icon-name   (nth 1 footer-item)))
           (setq dashboard-footer-icon (funcall (intern (concat "all-the-icons-" icon-source))
                                                icon-name
                                                :height 1.1
                                                :v-adjust -0.05
                                                :face 'font-lock-keyword-face)))

         (setq dashboard-footer (car (nth (random (1- (1+ (length dashboard-quotes))))
                                          dashboard-quotes)))

         (add-hook 'dashboard-mode-hook (lambda () (message nil)))

         (add-hook 'emacs-startup-hook
                   (defun dashboard--startup-handler ()
                     "update dashboard init info."
                     (let ((loaded-packages (get-loaded-packages+)))
                       (setq dashboard-init-info (if loaded-packages
                                                     (format "%d packages loaded in %s"
                                                             (length loaded-packages)
                                                             (emacs-init-time))
                                                   (format "emacs loaded in %s" (emacs-init-time))))

                       ;; don't switch to dashboard on error buffer
                       (unless (eq 1 (length (window-list)))
                         (winum-select-window-1)))))

         (advice-add 'dashboard-choose-banner :before-until
                     (defun dashboard-choose-banner-allow-text-banners+ ()
                       "the built in method only supports filepaths to graphical banners."
                       (let ((banner dashboard-startup-banner))
                         (when (and banner
                                    (stringp banner)
                                    (file-exists-p banner))
                           (and (string-equal "txt"
                                              (file-name-extension banner))
                                banner)))))

         (defmacro dashboard-defun-shortcut-function (shortcut-char search-label &optional no-next-line)
           "translation of `dashboard-insert-shortcut' but less bizarre."
           (let* ((func-name (intern (concat "dashboard-" shortcut-char "-shortcut"))))
             `(defun ,func-name ()
                (interactive)
                (unless (search-forward ,search-label (point-max) t)
                  (search-backward ,search-label (point-min) t))
                ,@(unless no-next-line
                    '((forward-line 1)))
                (back-to-indentation))))

         (general-define-key
           :keymaps 'dashboard-mode-map
           :states  'motion
           "j"     'dashboard-next-line
           "k"     'dashboard-previous-line
           "}"     'dashboard-next-section
           "{"     'dashboard-previous-section
           "gj"    'dashboard-next-section
           "gr"    'dashboard-refresh-buffer
           "M-r"   'dashboard-refresh-buffer
           "RET"   'dashboard-return
           "TAB"   'widget-forward
           "S-TAB" 'widget-backward

           "r" (dashboard-defun-shortcut-function "r" "Recent Files:")
           ;; "m" (dashboard-defun-shortcut-function "m" "Bookmarks:")
           "p" (dashboard-defun-shortcut-function "p" "Projects:")
           ;; "e" (dashboard-defun-shortcut-function "e" "Registers:")
           "a" (dashboard-defun-shortcut-function "a" (if (bound-and-true-p show-week-agenda-p)
                                                          "Agenda for the coming week:"
                                                        "Agenda for today:"))))
     #+END_SRC

*** debugger
    #+BEGIN_SRC emacs-lisp
      (use-package debug
        :defer t
        :config
        (evil-set-initial-state 'debugger-mode 'motion))
    #+END_SRC

*** define-word
    #+BEGIN_SRC emacs-lisp
      (use-package define-word
        :ensure t
        :defer  t
        :init
        (leader/set-keys
          "hdW" 'define-word
          "hdw" 'define-word-at-point))
    #+END_SRC

*** delight/diminish
    packages to change/hide modes from the mode-line. not sure if we're supposed to be using
    both of them, pretty sure there's some feature overlap here.

    TODO choose one, not both.

    #+BEGIN_SRC emacs-lisp
      (use-package delight
        :ensure t
        :defer  t)

      (use-package diminish
        :ensure t
        :defer  t)
    #+END_SRC

*** diff
    #+BEGIN_SRC emacs-lisp
      (defvar leader-diff-mode-prefix "d"
        "leader prefix under which diff bindings are assigned.")
    #+END_SRC

**** diff
     mode for showing diff/patch files.

     #+BEGIN_SRC emacs-lisp
       (use-package diff-mode
         :defer t
         :commands (diff-mode diff-buffer-with-file)
         :init
         (leader/with-prefix leader-diff-mode-prefix
           (leader/set-keys
             "" "diff"
             "SPC" 'diff-buffer-with-file))

         :config
         (push 'diff-mode whitespace-exempt-modes)

         (leader/set-keys-for-major-mode 'diff-mode
           "r" 'diff-refine-hunk
           "c" 'diff-kill-applied-hunks ;; clean displayed hunks only works on hunks below point.
           "k" 'diff-file-kill
           "f" 'next-error-follow-minor-mode
           "n" 'diff-restrict-view ;; narrow to hunk (or file with prefix)
           "s" 'diff-reverse-direction ;; doesn't do anything?
           "t" 'diff-test-hunk
           "e" 'diff-ediff-patch
           "u" 'diff-unified->context
           "d" 'diff-context->unified
           "l" 'diff-add-change-log-entries-other-window)

         (general-define-key
           :states  'motion
           :keymaps 'diff-mode-map
           "a" 'diff-apply-hunk ;; apply diff hunk to prompted file
           ;; NOTE prompts for file onto which diff is being applied
           "x" 'diff-hunk-kill
           "X" 'diff-file-kill
           "u" 'diff-undo
           "q" nil
           "s" 'diff-split-hunk
           "i" 'diff-ignore-whitespace-hunk

           "o" 'diff-goto-source
           "RET" 'diff-goto-source

           "C-j" 'diff-hunk-next
           "C-k" 'diff-hunk-prev
           "TAB"   'diff-file-next
           "S-TAB" 'diff-file-prev)

         (defun diff-kill-applied-hunks--ensure-all-hunks-killed (func &rest args)
           "`diff-kill-applied-hunks' doesn't kill any applied hunks above point :("
           (save-excursion
             (goto-char (point-min))
             (apply func args)))

         (advice-add 'diff-kill-applied-hunks :around #'diff-kill-applied-hunks--ensure-all-hunks-killed))
     #+END_SRC

**** ediff
     The builtin interactive diff tool.

     ediff is a pain to customize. all the help messages are hard coded, some of the keymaps
     are =magically= bound somewhere I don't know. I can get a reasonably useful out of the
     box experience with *evil-ediff* but it isn't much help in ediff-meta mode such as for
     the registry or multiple sessions.

     I'm moving to [[https://github.com/justbur/emacs-vdiff][vdiff]] & I suggest anyone else who can, does so as well.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package ediff
         :defer t
         :commands (ediff-current-file
                    ediff-buffers
                    ediff-windows
                    ediff-files
                    ediff-backup
                    ediff-files3
                    ediff-directories
                    ediff-directories3
                    ediff-regions-linewise
                    ediff-regions-wordwise
                    ediff-patch-file
                    ediff-merge-files
                    ediff-merge-buffers
                    ediff-merge-directories

                    ;; unbound by default
                    ediff-show-registry ;; ido-choose-ediff-session
                    ediff-toggle-multiframe
                    ediff-toggle-use-toolbar
                    ediff-revert-buffers-then-recompute-diffs
                    ediff-profile)
         :init
         (leader/with-prefix leader-diff-mode-prefix
           (leader/set-keys
             "f" 'ediff-current-file
             "b" 'ediff-buffers
             "w" 'ediff-windows))

         :config
         (push 'ediff-meta-mode whitespace-exempt-modes)

         (setq-default ediff-window-setup-function       'ediff-setup-windows-plain
                       ediff-split-window-function       'split-window-horizontally
                       ediff-merge-split-window-function 'split-window-horizontally
                       ;; ediff-keep-variants               nil ;; doesn't do anything :(
                       )

         (defvar mohkale-ediff-kill-temporary-buffers-on-exit t
           "whether to keep temporary ediff buffers around")

         (require 'outline)
         ;; show org ediffs unfolded
         (add-hook 'ediff-prepare-buffer-hook #'outline-show-all)

         ;; ensure window configuration is restored after diff quit
         (let* ((ediff-window-register ?w)
                (register-active (lambda () (cdr (assoc ediff-window-register register-alist)))))
           (defun ediff--restore-windows-before (&rest args)
             ;; (message "setting up")
             (unless (funcall register-active)
               ;; (message "assigning to register")
               (window-configuration-to-register ediff-window-register)))
           (add-hook 'ediff-before-setup-hook #'ediff--restore-windows-before)

           (defun ediff--restore-windows-after (&rest args)
             (if (not (funcall register-active))
                 (message "ediff-restore-windows : no previous window config found to restore")
               (jump-to-register ediff-window-register)
               (set-register ediff-window-register nil)))
           (add-hook 'ediff-quit-hook #'ediff--restore-windows-after))

         (defun ediff--kill-ediff-temp-buffers (&rest args)
           "kills all the spawned ediff buffers... because
       there's way too many and their named so similairly that
       there's no point in them existing... Plus I keep ending
       up editing the wrong diffed buffer."
           (when mohkale-ediff-kill-temporary-buffers-on-exit
             ;; kill diff checking buffers when temporary
             (dolist (buffer (list ediff-buffer-A
                                   ediff-buffer-B
                                   ediff-buffer-C))
               (when (and buffer
                          (string-prefix-p "FILE=" (buffer-name buffer)))
                 (kill-buffer buffer)))

             ;; kill any hardcoded ediff related buffers
             (dolist (buffer '("*Ediff Registry*"))
               (let ((buffer (get-buffer buffer)))
                 (when buffer
                   (kill-buffer buffer))))

             ;; kill any uniquely named ediff buffers...
             ;; Ewwww... O(n*m)... how do I live with myself
             (dolist (buffer-prefix '("*Ediff Control Panel"
                                      "*ediff-diff"
                                      "*ediff-errors"
                                      "*ediff-fine-diff"))
               (let ((buffer-prefix-regexp (regexp-quote buffer-prefix)))
                 (dolist (buffer (buffer-list))
                   (when (string-match buffer-prefix-regexp
                                       (buffer-name buffer))
                     (kill-buffer buffer)))))))

         (add-hook 'ediff-quit-hook #'ediff--kill-ediff-temp-buffers)

         (defun ediff--customize-ediff-mode-map (&rest args)
           "give me back my leader keys damn it :P"
           (general-define-key
             :keymaps 'ediff-mode-map
             :states  'motion
             "SPC" leader-map))

         (add-hook 'ediff-keymap-setup-hook #'ediff--customize-ediff-mode-map)
         ;; (evil-set-initial-state 'ediff-meta-mode 'motion)

         ;; (general-define-key
         ;;   :states 'motion
         ;;   :keymaps 'ediff-meta-buffer-map
         ;;   "C-j" 'ediff-next-meta-item
         ;;   "C-k" 'ediff-previous-meta-item
         ;;   "q" 'ediff-quit-meta-buffer
         ;;   "o" 'ediff-registry-action
         ;;   "=" 'ediff-meta-mark-equal-files
         ;;   "RET" 'ediff-registry-action
         ;;   "R" 'ediff-show-registry
         ;;   "S-RET" 'ediff-show-meta-buff-from-registry
         ;;   "?" 'ediff-toggle-verbose-help-meta-buffer)

         (leader/set-keys-for-major-mode 'ediff-meta-mode
           "tf" 'ediff-toggle-filename-truncation
           "tv" 'ediff-toggle-verbose-help-meta-buffer)

         (use-package evil-ediff
           :ensure t
           :defer  t
           :commands (evil-ediff-init)
           :init
           (with-eval-after-load 'ediff
             (evil-ediff-init))))
     #+END_SRC

**** vdiff
     inspired by vimdiff, vdiff is a better, less intrusive interactive diff tool for
     emacs.

     #+BEGIN_SRC emacs-lisp
       (use-package vdiff
         :ensure t
         :defer  t
         :init
         (leader/with-prefix leader-diff-mode-prefix
           (leader/set-keys
             "" "diff"
             "RET" 'vdiff-merge-conflict
             "d" 'vdiff-current-file
             "f" 'vdiff-files
             "F" 'vdiff-files3
             "b" 'vdiff-buffers
             "B" 'vdiff-buffers3))

         :config
         (defvar vdiff-use-relative-line-numbers nil
           "when true, line numbers in vdiff sessions are relative")

         (defun vdiff-setup (&rest args)
           (let ((inhibit-message t))
             (toggle-truncate-lines +1)
             (evil-normalize-keymaps))

           (when vdiff-use-relative-line-numbers
             (setq-local display-line-numbers
                         (if vdiff-mode t 'relative))))

         (defun vdiff-prepare ()
           (cond
            ((derived-mode-p 'org-mode)
             (when vdiff-mode
               (outline-show-all)))))

         (dolist (handler '(vdiff-setup
                            vdiff-prepare))
           (add-hook 'vdiff-mode-hook      handler)
           (add-hook 'vdiff-3way-mode-hook handler))

         (general-define-key
           :states leader-norm-states
           :keymaps '(vdiff-mode-map vdiff-3way-mode-map)
           "q"  'vdiff-quit
           "gj" 'vdiff-next-hunk
           "gk" 'vdiff-previous-hunk
           "gh" 'vdiff-switch-buffer
           "gl" 'vdiff-switch-buffer
           "gr" 'vdiff-refresh
           "zj" 'vdiff-next-fold
           "zk" 'vdiff-previous-fold
           "zo" 'vdiff-open-fold
           "zO" 'vdiff-open-fold
           "zr" 'vdiff-open-all-folds
           "zf" 'vdiff-close-fold
           "zc" 'vdiff-close-fold
           "zF" 'vdiff-close-all-folds
           "zC" 'vdiff-close-all-folds
           "zC" 'vdiff-close-other-folds)

         (leader/with-prefix leader-diff-mode-prefix
           (leader/set-keys-for-mode '(vdiff-mode vdiff-3way-mode)
             "-" 'vdiff-switch-buffer
             "." 'vdiff-hydra/body
             "m" 'vdiff-restore-windows
             "s" 'vdiff-save-buffers
             "<left>"  'vdiff-receive-changes
             "<right>" 'vdiff-send-changes
             ">" 'vdiff-send-changes-and-step
             "<" 'vdiff-send-changes

             "TAB"     "refine"
             "TAB TAB" 'vdiff-refine-this-hunk
             "TAB DEL" 'vdiff-remove-refinements-in-hunk
             "TAB RET" 'vdiff-refine-all-hunks
             ;; 'vdiff-refine-this-hunk-symbol
             ;; 'vdiff-refine-this-hunk-word
             ;; 'vdiff-refine-all-hunks-symbol
             ;; 'vdiff-refine-all-hunks-word

             "t"  "toggle"
             "ti" 'vdiff-toggle-case
             "tw" 'vdiff-toggle-whitespace)))
     #+END_SRC

***** vdiff-magit
      #+BEGIN_SRC emacs-lisp :tangle no
        (use-package vdiff-magit
          :ensure t
          :defer  t
          :after magit
          :init
          (general-define-key
            :keymaps 'magit-mode-map
            "e" 'vdiff-magit-dwim
            "E" 'vdiff-magit)

          :config
          (transient-suffix-put 'magit-dispatch "e" :description "vdiff (dwim)")
          (transient-suffix-put 'magit-dispatch "e" :command 'vdiff-magit-dwim)
          (transient-suffix-put 'magit-dispatch "E" :description "vdiff")
          (transient-suffix-put 'magit-dispatch "E" :command 'vdiff-magit))
      #+END_SRC

*** display-line-numbers-mode
    #+BEGIN_SRC emacs-lisp
      (use-package display-line-numbers
        :straight (display-line-numbers :type built-in)
        :defer t
        :hook ((prog-mode . display-line-numbers-mode)
               (text-mode . display-line-numbers-mode))
        :config
        ;; prefer relative line numbers when available
        (setq-default display-line-numbers-type 'relative))
    #+END_SRC

*** dired
**** dired-x
     #+BEGIN_SRC emacs-lisp
       (use-package dired-x
         :straight (dired-x :type built-in)
         :hook (dired-mode . dired-omit-mode)
         :config
         (setq dired-omit-files (rx (or
                                     ".#"
                                     (and bol
                                          (or "."
                                              ".."
                                              ".git"
                                              ".bundle"
                                              ".dired"
                                              "__pycache__"
                                              ".pytest_cache"
                                              ".gradle"
                                              ".sass-cache"
                                              ".jekyll-cache"
                                              "Pipfile")
                                          eol)))))
     #+END_SRC

**** diredfl
     extra font lock rules for dired; basically adds some more color to dired sessions.
     nice idea, but too much of a good thing can be bad.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package diredfl
         :ensure t
         :defer  t
         :hook (dired-mode . diredfl-mode))
     #+END_SRC

**** dired
     #+BEGIN_SRC emacs-lisp
       (use-package dired
         :straight (dired :type built-in)
         :defer t
         :config
         (push '(dired-mode . 1) mohkale-indent-config)

         (setq ls-lisp-dirs-first t
               ls-lisp-use-insert-directory-program t
               dired-listing-switches "-laXhv --group-directories-first"
               dired-auto-revert-buffer t
               dired-hide-details-hide-symlink-targets nil
               dired-recursive-copies t
               dired-recent-directories-file (var! "dired/recent.el"))

         (push 'dired-mode whitespace-exempt-modes)

         (defun dired-goto-home-dir (&optional other-window)
           "goto users home directory
       with prefix, visits in another window"
           (interactive "P")
           (funcall (if other-window
                        'find-file-other-window
                      'find-file)
                    (expand-file-name "~")))

         (defun dired-evil-scroll-down ()
           (interactive)
           (call-interactively 'evil-scroll-down)
           (dired-move-to-filename))

         (defun dired-evil-scroll-up ()
           (interactive)
           (call-interactively 'evil-scroll-up)
           (dired-move-to-filename))

         (general-define-key
           :keymaps 'dired-mode-map
           ;; let map override any motion bindings
           "<override-state>" 'motion)

         (general-define-key
           :keymaps 'dired-mode-map
           :states  'motion
           "j" 'dired-next-line
           "k" 'dired-previous-line
           "~" 'dired-goto-home-dir
           "r" 'dired-do-redisplay
           "=" 'dired-diff
           "K" 'dired-do-kill-lines
           "'" 'dired-show-file-type ;; like file command
           "M" 'dired-unmark
           "u" 'dired-unmark
           "r" 'dired-change-marks
           "y" 'dired-copy-filename-as-kill

           "M-<return>" 'dired-display-file
           "C-M-<return>" 'dired-find-alternate-file
           "C-M-d" 'dired-kill-subdir

           "zc" 'dired-hide-subdir ;; collapse
           "zC" 'dired-hide-all

           ;; "|" 'dired-do-hardlink
           "|" 'dired-do-symlink
           "C-|" 'dired-do-relsymlink
           "M-|" 'dired-do-hardlink
           "M-!" 'dired-do-print ;; append names to end of command

           "C-S-J" 'dired-next-marked-file
           "C-S-K" 'dired-prev-marked-file
           "M-j" 'dired-next-dirline           ; unbound, dired-tree-down
           "M-k" 'dired-prev-dirline           ; unbound, dired-tree-up
           "C-d" 'dired-evil-scroll-down
           "C-u" 'dired-evil-scroll-up
           "C-h" 'dired-goto-min-subdir
           "C-j" 'dired-next-subdir
           "C-k" 'dired-prev-subdir
           "C-l" 'dired-goto-max-subdir)

         (leader/set-keys-for-major-mode 'dired-mode
           "?" 'dired-summary ;; like transient state
           "#" 'dired-clean-directory
           "o" 'browse-url-of-dired-file ;; open in external app
           "O" 'dired-omit-mode
           "v" 'dired-view-file          ;; TODO customize view mode
           "g" 'dired-goto-file ;; prompt for file to visit in current buffer
           "s" 'dired-sort-toggle-or-edit

           "r"  "rename"
           "ru" 'dired-upcase
           "rd" 'dired-downcase

           ;; flag means mark delete
           "d"  "delete"
           "d&" 'dired-flag-garbage-files
           "d~" 'dired-flag-backup-files
           "d/" 'dired-flag-files-regexp
           "d#" 'dired-flag-auto-save-files

           "m"  "mark"
           "mm" 'dired-toggle-marks
           "mu" 'dired-unmark
           "m DEL" 'dired-unmark-backward
           "m|" 'dired-mark-symlinks
           "md" 'dired-mark-directories
           "m!" 'dired-mark-executeables
           "mt" 'dired-mark-subdir-files
           "mg" 'dired-mark-files-containing-regexp ;; grep
           "m/" 'dired-mark-files-regexp
           "m(" 'dired-mark-sexp

           ;; emacs related bindings
           "e"  "emacs"
           "ec" 'dired-do-byte-compile
           "el" 'dired-do-load
           "ef" 'dired-do-find-marked-files

           ;; change fs property commands
           "c"  "change"
           "cg" 'dired-do-chgrp
           "cm" 'dired-do-chmod
           "co" 'dired-do-chown

           ;; filesystem
           "f"  "filesystem"
           "fg" 'dired-do-find-regexp             ;; grep marked files
           "fs" 'dired-do-find-regexp-and-replace ;; substitute
           "fi" 'dired-info
           "fm" 'dired-man
           "fr" 'dired-do-run-mail
           "ft" 'dored-do-touch
           "fz" 'epa-dired-do-encrypt
           "fZ" 'epa-dired-do-encrypt-to ;; compress as

           ;; EasyPG/GPG
           "fp"  "GPG"
           "fpd" 'epa-dired-do-decrypt
           "fpe" 'epa-dired-do-encrypt
           "fps" 'epa-dired-do-sign
           "fpv" 'epa-dired-do-verify

           ;; operations bound to regexp search
           "f/"     "search"
           "f/c"    'dired-do-copy-regexp
           "f/r"    'dired-do-rename-regexp
           "f/h"    'dired-do-hardlink-regexp
           "f/s"    'dired-do-symlink-regexp
           "f/|"    'dired-do-symlink-regexp
           "f/ C-|" 'dired-do-relsymlink-regexp
           "f/ M-|" 'dired-do-hardlink-regexp)

         (general-unbind
           :keymaps 'dired-mode-map
           "#" "$" "%" "*" "." ":" "?" "~" "<" "=" ">" "a"
           "A" "B" "c" "C-M-d" "C-M-n" "C-M-p" "C-M-u" "C-o"
           "e" "f" "F" "g" "G" "h" "H" "I" "j" "k" "l" "L" "M"
           "M-$" "M-(" "M-{" "M-}" "M-DEL" "M-G" "n" "N" "O" "p"
           "P" "Q" "s" "SPC" "0" "S-SPC" "t" "T" "v" "V" "w" "W"
           "X" "y" "Y" "Z" "u"))
     #+END_SRC

**** dired-all-the-icons
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'dired
         (use-package all-the-icons-dired
           :defer  t
           :ensure t
           :diminish "DiredIcons"
           :hook (dired-mode . all-the-icons-dired-mode)
           :config
           (add-hook 'all-the-icons-dired-mode-hook
                     (defun all-the-icons-dired-mode--setup-insert+ (&rest _)
                       (if (bound-and-true-p all-the-icons-dired-mode)
                           (advice-add 'dired-insert-subdir :around #'all-the-icons-dired--refresh-advice)
                         (advice-remove 'dired-insert-subdir #'all-the-icons-dired--refresh-advice))))))
     #+END_SRC

**** dired-git-info
     show the last commit log for files in the current dired buffer.

     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'dired
         (use-package dired-git-info
           :ensure t
           :defer  t
           :init
           (general-define-key
             :keymaps 'dired-mode-map
             :states  'motion
             ")" 'dired-git-info-mode)))
     #+END_SRC

**** dired-hacks
     A bunch of really cool extensions for dired. Look into [[https://github.com/Fuco1/dired-hacks][it]] later.

     #+BEGIN_SRC emacs-lisp :tangle no
       (with-eval-after-load 'dired
         (use-package dired-hacks-utils
           :ensure t
           :defer  t))
     #+END_SRC

**** image-dired
     #+BEGIN_SRC emacs-lisp
       (use-package image-dired
         :straight (image-dired :type built-in)
         :defer t
         :commands (persp-custom-@dired-slideshow)
         :config
         (puthash "@dired-slideshow" 'persp-custom-@dired-slideshow mohkale--custom-perspectives)

         :config
         (push 'image-dired-thumbnail-mode whitespace-exempt-modes)

          ;;; fixed weird moves line, not thumbnail
         (defun image-dired-slideshow-step ()
           "Step to next file, if `image-dired-slideshow-times' has not been reached."
           (if (< image-dired-slideshow-count image-dired-slideshow-times)
               (progn
                 (message "%s" (1+ image-dired-slideshow-count))
                 (setq image-dired-slideshow-count (1+ image-dired-slideshow-count))
                 (image-dired-display-next-thumbnail-original))
             (image-dired-slideshow-stop)))

         (general-define-key
           :keymaps 'image-dired-thumbnail-mode-map
           :states '(normal visual)
           "q" nil

           "h" 'image-dired-backward-image
           "j" 'image-dired-next-line
           "k" 'image-dired-previous-line
           "l" 'image-dired-forward-image
           "<left>"  'image-dired-forward-image
           "<right>" 'image-dired-previous-image


           "x" 'image-dired-delete-char
           "m" 'image-dired-mark-thumb-original-file
           "u" 'image-dired-unmark-thumb-original-file
           "c" 'image-dired-comment-thumbnail
           "d" 'image-dired-flag-thumb-original-file
           "D" 'image-dired-thumbnail-set-image-description
           "s" 'image-dired-slideshow-start
           "t" 'image-dired-toggle-mark-thumb-original-file
           "gr" 'image-dired-refresh-thumb
           "gc" 'image-dired-create-thumbs
           "gg" (lambda! (evil-goto-first-line) (evil-beginning-of-line))
           "G"  (lambda! (goto-char (point-max)) (image-dired-backward-image))

           "C-s" 'image-save           ; NOTE originally was bound to o

           "<C-SPC>"    'image-dired-mark-thumb-original-file
           "<M-SPC>"    'image-dired-unmark-thumb-original-file

           "<C-return>" 'image-dired-display-current-image-full
           "<RET>"      'image-dired-display-thumbnail-original-image
           "C-l"        'image-dired-display-next-thumbnail-original
           "C-h"        'image-dired-display-previous-thumbnail-original
            ;;; column view aliases
           "J" 'image-dired-display-next-thumbnail-original
           "K" 'image-dired-display-previous-thumbnail-original
           ;; "o" 'image-dired-display-thumbnail-original-image
           "v" 'image-dired-display-thumbnail-original-image

           "<mouse-1>" 'image-dired-mouse-select-thumbnail
           "<mouse-2>" 'image-dired-mouse-display-image)

         (leader/set-keys-for-major-mode 'image-dired-thumbnail-mode
           "g" 'image-dired-jump-original-dired-buffer
           "m" 'image-dired

           "t"  "tagging"
           "td" 'image-dired-thumbnail-set-image-description
           "tt" 'image-dired-tag-thumbnail
           "tT" 'image-dired-tag-thumbnail-remove

           "e" "edit"
           "el" 'image-dired-rotate-thumbnail-left
           "eL" 'image-dired-rotate-original-left
           "er" 'image-dired-rotate-thumbnail-right
           "eR" 'image-dired-rotate-original-right

           "." 'image-dired-track-original-file
           "o" 'image-dired-thumbnail-display-external

           ;; [re]set number of columns per row
           "s" 'image-dired-line-up-interactive
           "S" 'image-dired-line-up-dynamic)

          ;;; image view
         (general-define-key
           :keymaps 'image-dired-display-image-mode-map
           :states 'normal
           "f" 'image-dired-display-current-image-full
           "F" 'image-dired-display-current-image-sized
           "s" 'image-dired-display-current-image-sized

           "h" 'image-scroll-right
           "l" 'image-scroll-left
           "k" 'image-scroll-down
           "j" 'image-scroll-up
           ;; horizontal line by line movement
           "C-d" 'image-scroll-up
           "C-u" 'image-scroll-down
           "C-e" 'image-next-line
           "C-y" 'image-previous-line
           ;; Arrow Keys Alias hjkl
           "<left>"  'image-backward-hscroll
           "<right>" 'image-forward-hscroll
           "<up>"    'image-scroll-down
           "<down>"  'image-scroll-up)

         (leader/set-keys-for-major-mode 'image-dired-display-image-mode
           "h" 'image-bol ; far left   edge
           "j" 'image-eob ; far bottom edge
           "k" 'image-bob ; far top    edge
           "l" 'image-eol ; far right  edge
           "g" 'image-dired-jump-thumbnail-buffer)

         (defvar dired-slideshow--thumbnail-column-count 2
           "number of columns of thumbnails shown on each row")

         (defvar dired-slideshow--dedicate-image-windows nil
           "whether to dedicate thumbnail and display windows")

         ;; NOTE keep setq because defvar doesn't work for repeated calls
         ;; (setq dired-slideshow--thumbnail-column-count 3)
         ;; (setq dired-slideshow--dedicate-image-windows t)

         (mohkale//define-custom-perspective "@dired-slideshow"
           (kill-all-windows-and-return-to-home) ; splitting issues with layout

           (let* ((thumbnails-buffer-name "*image-dired*")
                  (display-buffer-name "*image-dired-display-image*")

                  ;; only load when buffer doesn't exist and user allows it
                  (load-directory (and (not (get-buffer thumbnails-buffer-name))
                                       (y-or-n-p "would you like to load an image directory")))

                  (thumbnails-buffer (get-buffer-create thumbnails-buffer-name))
                  (display-buffer (get-buffer-create display-buffer-name)))
             (split-window-right) ; left window is for thumbnails, right for display

             (let* ((thumbnails-window (selected-window))
                    (display-window    (window-right thumbnails-window)))
               (if load-directory (call-interactively 'image-dired))

               (persp-add-buffer `(,thumbnails-buffer ,display-buffer))

               ;; setup thumbnail window
               (with-selected-window thumbnails-window
                 (switch-to-buffer thumbnails-buffer)

                 (unless (eq major-mode 'image-dired-thumbnail-mode)
                   (image-dired-thumbnail-mode))

                 ;; set number of columns in view
                 (let ((image-dired-thumbs-per-row dired-slideshow--thumbnail-column-count))
                   (image-dired-line-up))

                 (let* ((thumbnail-window-width (* image-dired-thumb-width dired-slideshow--thumbnail-column-count))
                        (delta-width (- thumbnail-window-width (window-pixel-width))))
                   (unless (> (abs delta-width) (window-pixel-width))
                     (window-resize thumbnails-window delta-width t nil t)))

                 (window-preserve-size thumbnails-window t))

               ;; setup display window
               (with-selected-window display-window
                 (switch-to-buffer display-buffer)

                 (unless (eq major-mode 'image-dired-display-image-mode)
                   (image-dired-display-image-mode)))

               (and dired-slideshow--dedicate-image-windows (force-set-all-visible-windows-dedication t))
               (select-window thumbnails-window)

               (message "completed creation of slideshow layout")))))
     #+END_SRC

*** drag-stuff
    VS Code like drag region or line upwards or downwards.

    #+BEGIN_SRC emacs-lisp
      (use-package drag-stuff
        :defer  t
        :ensure t
        :init
        (general-define-key
          "C-<up>" 'drag-stuff-up
          "C-<down>" 'drag-stuff-down))
    #+END_SRC

*** display-buffer
    customise display-buffer-alist to prioritise switching focus to displayed
    buffers, instead of showing them and then making me have to switch to them
    and then exit.

    #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale-display-buffer.el
      ;; frankly, display buffers alist is badly documented.
      ;; there's a quick and simple article exploring how it
      ;; works [[https://www.simplify.ba/articles/2016/01/25/display-buffer-alist/][here]]
      ;;
      ;; in the meantime, the following is a breif~er~ summary
      ;;   1. the car of each entry should be a regex matching a buffer
      ;;      name or a function taking a buffer and an action argument.
      ;;   2. the second item (car (cdr list)) should be a list of or a
      ;;      single display handler function which takes a buffer and
      ;;      an alist as an argument. Each entry in the list is invoked
      ;;      until one which returns non nil is encountered.
      ;;   3. the remaining list items should be an alists providing options.

      ;; changing at startup messes up the display of the dashboard :(
      (defvar default-display-buffer-action
        display-buffer-fallback-action
        "the value for fallback actions without my configuration")

      (defun restore-default-display-buffer-actions (func &rest args)
        "restore the default display buffer actions used by emacs."
        (let ((display-buffer-fallback-action
               default-display-buffer-action))
          (apply func args)))

      (setq display-buffer-fallback-action
            ;; by default, focus on displayed windows
            '((display-buffer--maybe-same-window-and-focus
               display-buffer-reuse-window-and-focus
               display-buffer--maybe-pop-up-frame-or-window-and-focus
               display-buffer-in-previous-window-and-focus
               display-buffer-use-some-window-and-focus
               display-buffer-pop-up-frame-and-focus)))

      (push '("*Async Shell Command*"
              (display-buffer-reuse-window
               display-buffer--maybe-pop-up-frame-or-window-and-focus
               display-buffer-in-side-window-and-focus)
              (side          . bottom)
              (window-height . 0.5))
            display-buffer-alist)

      (push '("*compilation*"
              (display-buffer-reuse-window-and-focus
               display-buffer--maybe-pop-up-frame-or-window-and-focus
               display-buffer-in-side-window-and-focus)
              (side          . bottom)
              (window-height . 0.5))
            display-buffer-alist)

      (dolist (buffer-name '("*image-dired-display-image*"
                             "*Anaconda*"
                             "magit-diff: "
                             "*Flycheck error messages*"
                             "*HTTP Response*"))
        (push `(,buffer-name ,@default-display-buffer-action)
              display-buffer-alist))

      (provide 'mohkale-display-buffer)
    #+END_SRC

    make sure to require this file after emacs has finished starting up.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'emacs-startup-hook
                (lambda ()
                  (require 'mohkale-display-buffer)))
    #+END_SRC

*** ebuku
    emacs interface to the [[https://github.com/jarun/buku][buku]] bookmark manager.

    #+BEGIN_SRC emacs-lisp
      (use-package ebuku
        :defer t
        :straight (ebuku :type git :host github :repo "flexibeast/ebuku"))
    #+END_SRC

*** edbi
    #+BEGIN_SRC emacs-lisp
      ;; (use-package edbi
      ;;   :ensure t
      ;;   :defer  t

      ;;   )

      ;; DAMN YOU WINDOWS :P
    #+END_SRC

*** edit-indirect
    open regions of code in their own dedicated buffers, like org modes org-edit-special.

    #+BEGIN_SRC emacs-lisp
      (use-package edit-indirect
        :ensure t
        :defer  t
        :commands (edit-indirect-region
                   edit-indirect-commit
                   edit-indirect-save
                   edit-indirect-abort)
        :config
        (leader/with-major-mode-prefix
          (leader/set-keys-for-mode 'edit-indirect--overlay
            "," 'edit-indirect-commit
            "s" 'edit-indirect-save
            "q" 'edit-indirect-abort)))
    #+END_SRC

*** eldoc
    That package that displays help messages in the echo area.

    #+BEGIN_SRC emacs-lisp
      (use-package eldoc
        :delight "")
    #+END_SRC

*** electric
**** electric-pair
     electric pair is a built in module which lets auto insert matching pairs. For example,
     inserting a ( will lead to emacs auto inserting ).

     #+BEGIN_SRC emacs-lisp
       (use-package elec-pair
         :hook ((prog-mode . electric-pair-mode)
                (text-mode . electric-pair-mode))
         :commands electric-pair-mode
         :config
         (setq electric-pair-preserve-balance nil
               electric-pair-skip-whitespace  nil)

         (electric-pair-mode 1))
     #+END_SRC

**** electric-indent
     #+BEGIN_SRC emacs-lisp
       (use-package electric
         :commands electric-indent-mode
         :hook ((text-mode . electric-indent-mode)
                (prog-mode . electric-indent-mode)))
     #+END_SRC

*** emojify
    #+BEGIN_SRC emacs-lisp
      (use-package emojify
        :ensure t
        :defer  t
        :hook ((org-mode              . emojify-mode)
               (git-commit-mode       . emojify-mode)
               (web-mode              . emojify-mode)
               (lisp-interaction-mode . emojify-mode)
               (yaml-mode             . emojify-mode)
               (sh-script-mode        . emojify-mode)
               (markdown-mode         . emojify-mode)
               (lisp-interaction-mode . emojify-mode))
        :init
        (leader/set-keys
          "xm" 'emojify-insert-emoji)

        (defalias 'remove-duplicates #'cl-remove-duplicates)

        :config
        (setq emojify-emojis-dir (var! "emojify/"))

        (general-define-key
          :keymaps 'emojify-list-mode-map
          :states 'motion
          "gr" 'emojify-list-force-refresh
          "Y"  'emojify-list-copy-emoji
          "RET" 'emojify-list-describe-emoji)

        (general-define-key
          :keymaps 'emojify-description-mode
          :states 'motion
          "Y" 'emojify-description-copy-emoji)

        ;; make emojis work like prettify-symbols-mode
        (setq emojify-point-entered-behaviour 'uncover
              emojify-emoji-styles '(unicode github)
              emojify-display-style 'unicode)

        (use-package company-emoji
          :ensure t
          :defer  t
          :init
          (company/configure-mode (emojify-mode)
            company-emoji)

          :config
          ;; never insert emojis as their unicode symbols.
          (setq company-emoji-insert-unicode nil)))
    #+END_SRC

*** engine-mode
    search engine interaction for emacs. lets you create enteractive functions to run
    search queries on user specified engines. eg. engine/search-google will prompt you
    for a string and then open your default browser on google (having run the query).

    #+NAME: engine-mode-search-engines
    | Search Engine | Key | Identifier               | URL                                                                      |
    |---------------+-----+--------------------------+--------------------------------------------------------------------------|
    | DuckDuckGo    | d   | duckduckgo               | https://duckduckgo.com/?q=%s                                             |
    | Github        | G   | github                   | https://github.com/search?ref=simplesearch&q=%s                          |
    | Google        | g   | google                   | http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s                      |
    | GoogleImages  | i   | google-images            | http://www.google.com/images?hl=en&source=hp&q=%s                        |
    | GoogleMaps    | m   | google-maps              | http://maps.google.com/maps?q=%s                                         |
    | StackOverflow | s   | stack-overflow           | https://stackoverflow.com/search?q=%s                                    |
    | Wikipedia     | w   | wikipedia                | http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s |
    | Youtube       | y   | youtube                  | http://www.youtube.com/results?aq=f&oq=&search_query=%s                  |
    |---------------+-----+--------------------------+--------------------------------------------------------------------------|
    | MyAnimeList   | aa  | myanimelist              | https://myanimelist.net/search/all?q=%s                                  |
    | Anime         | aA  | myanimelist/anime        | https://myanimelist.net/anime.php?q=%s                                   |
    | Manga         | am  | myanimelist/manga        | https://myanimelist.net/manga.php?q=%s                                   |
    | Characters    | ac  | myanimelist/chars        | https://myanimelist.net/character.php?q=%s                               |
    | People        | ap  | myanimelist/people       | https://myanimelist.net/people.php?q=%s                                  |
    | News          | an  | myanimelist/news         | https://myanimelist.net/news/search?q=%s                                 |
    | Articles      | aF  | myanimelist/articles     | https://myanimelist.net/featured/search?q=%s                             |
    | Forums        | af  | myanimelist/forums       | https://myanimelist.net/forum/search?u=&uloc=1&loc=-1&q=%s               |
    | Clubs         | aC  | myanimelist/clubs        | https://myanimelist.net/clubs.php?action=find&cn=%s                      |
    | Users         | au  | myanimelist/users        | https://myanimelist.net/users.php?q=%s                                   |
    |---------------+-----+--------------------------+--------------------------------------------------------------------------|
    | Nyaa          | nn  | nyaa                     | https://nyaa.si/?f=0&c=0_0&q=%s                                          |
    | Anime         | na  | nyaa/anime-english       | https://nyaa.si/?f=0&c=1_2&q=%s                                          |
    | AnimeAll      | nA  | nyaa/anime               | https://nyaa.si/?f=0&c=1_0&q=%s                                          |
    | Music         | nm  | nyaa/music               | https://nyaa.si/?f=0&c=2_0&q=%s                                          |
    | Literature    | nl  | nyaa/literature-english  | https://nyaa.si/?f=0&c=3_1&q=%s                                          |
    | LiteratureAll | nL  | nyaa/literature          | https://nyaa.si/?f=0&c=3_0&q=%s                                          |
    | LiveAction    | nv  | nyaa/live-action-english | https://nyaa.si/?f=0&c=4_1&q=%s                                          |
    | LiveActionAll | nV  | nyaa/live-action         | https://nyaa.si/?f=0&c=4_0&q=%s                                          |
    | Images        | ni  | nyaa/images              | https://nyaa.si/?f=0&c=5_0&q=%s                                          |
    | Software      | ns  | nyaa/software            | https://nyaa.si/?f=0&c=6_0&q=%s                                          |
    | Games         | ng  | nyaa/games               | https://nyaa.si/?f=0&c=6_2&q=%s                                          |

    #+NAME: engine-mode-prefix-names
    | prefix | name        |
    |--------+-------------|
    | n      | Nyaa        |
    | a      | MyAnimeList |

    #+BEGIN_SRC emacs-lisp :var engines=engine-mode-search-engines prefix-aliases=engine-mode-prefix-names :results output
      (setq engines (cdr engines)) ;; strip header row

      (use-package engine-mode
        :ensure t
        :defer  t
        :init
        (let ((engine-prefix "se"))
          (leader/set-keys engine-prefix "engines")

          (dolist (engine engines)
            (let* ((key               (nth 1 engine))
                   (identifier-string (nth 2 engine))
                   (engine            (nth 0 engine))

                   (function-identifier (intern
                                         (concat "engine/search-"
                                                 identifier-string)))
                   (key (unless (string-empty-p key)
                          (concat engine-prefix key))))
              (when key
                (leader/set-keys key `(,engine . ,function-identifier)))
              (autoload function-identifier "engine-mode.el" nil t)))

          (dolist (alias prefix-aliases)
            (let* ((prefix (concat engine-prefix (car alias)))
                   (name   (nth 1 alias)))
              (leader/set-keys prefix name))))

        :config
        (dolist (engine engines)
          (let* ((identifier-string (nth 2 engine))
                 (query-link        (nth 3 engine))
                 (identifier (when identifier-string
                               (intern identifier-string))))
            (when (and identifier
                       (not (string-empty-p query-link)))
              (eval
               `(defengine ,identifier
                  ,query-link))))))
    #+END_SRC

*** eshell
    a nice minimalist shell for emacs.

**** eshell-mode
     #+BEGIN_SRC emacs-lisp
       (use-package esh-mode
         :straight (esh-mode :type built-in)
         :defer t
         :hook (
                ;;; cursor-type is block... changing to bar
                ;;; doesn't persist on window change... boo!!!
                ;; (eshell-mode . (setq-local cursor-type 'bar))
                ;;; disable company-mode in eshell-mode
                (eshell-mode . (lambda () (company-mode -1))))
         :init
         (leader/set-keys ":" 'eshell-command)

         :config
         (evil-set-initial-state 'eshell-mode 'emacs)

         ;; don't auto scroll to bottom after execution
         (remove-hook 'eshell-output-filter-functions
                      'eshell-postoutput-scroll-to-bottom)

         ;; clear shouldn't scroll back to bottom of the screen
         (advice-add 'eshell/clear :after #'recenter-top-bottom)

         (setq eshell-banner-message "") ;; no banner

         (defun eshell-backward-kill-word ()
           (interactive)
           (let ((bol
                  (save-excursion
                    (eshell-bol)))
                 (beginning-word-point
                  (save-excursion
                    (backward-word)
                    (point))))
             (when (>= beginning-word-point bol)
               (call-interactively 'backward-kill-word))))

         (leader/set-keys-for-major-mode 'eshell-mode
           "o"   'eshell-show-output
           "O"   'eshell-mark-output
           "TAB" 'counsel-esh-history
           "RET" 'eshell-queue-input

           "i"  "insert"
           "ib" 'eshell-insert-buffer-name
           "ip" 'eshell-insert-process
           "ie" 'eshell-insert-envvar

           "k"  "kill/signal"
           "kz" 'eshell-send-eof-to-process
           "kc" 'eshell-interrupt-process
           "kq" 'eshell-quit-process)

         (defun eshell-mode--setup-bindings ()
           (general-define-key
             :keymaps 'eshell-mode-map
             ;;; movement commands
             "C-e"   'end-of-line
             "M-l"   'recenter-top-bottom
             "C-h"   'backward-char
             "C-l"   'forward-char
             "C-M-h" 'backward-word
             "C-M-l" 'forward-word
             ;;; scroll commands
             "<S-down>" 'evil-scroll-down
             "<S-up>"   'evil-scroll-up
             ;; move to beginning of output
             ;; or return to end of cursor
             "M-a" 'eshell-show-output
             "M-e" 'eshell-show-maximum-output

             ;;; signals
             "C-c C-z" 'eshell-send-eof-to-process
             "C-c C-q" 'eshell-quit-process
             "M-c"     'eshell-interrupt-process
             "M-z"     'eshell-send-eof-to-process
             "M-q"     'eshell-quit-process

             "C-s"   'counsel-esh-history
             "M-SPC" 'counsel-esh-history

             "M-y"           'eshell-repeat-argument
             "C-d"           'eshell-kill-input
             "C-M-k"         'eshell-kill-input
             "M-d"           'eshell-kill-output
             "C-w"           'eshell-backward-kill-word
             "<C-backspace>" 'evil-delete-backward-word
             ;; copy entered input back into current line
             "<C-return>"    'eshell-copy-old-input

             "C-j"       'eshell-next-input
             "C-k"       'eshell-previous-input
             "M-j"       'eshell-next-prompt
             "M-k"       'eshell-previous-prompt
             ;; reverse the default affect of up and down
             "<up>"      'eshell-previous-input
             "<down>"    'eshell-next-input
             "<C-up>"    'eshell-previous-matching-input-from-input
             "<C-down>"  'eshell-next-matching-input-from-input
             "<S-left>"  'eshell-backward-argument
             "<S-right>" 'eshell-forward-argument
             "<M-left>"  'eshell-backward-argument
             "<M-right>" 'eshell-forward-argument))

         ;; needs to be in a hook because eshell-mode-map isn't
         ;; defined until the mode is activated, and even then
         ;; it's only buffer-local :(.
         (add-hook 'eshell-mode-hook #'eshell-mode--setup-bindings))
     #+END_SRC

**** eshell-prompt-extras
     Prettier prompt for eshell.

     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'esh-mode
         (use-package eshell-prompt-extras
           :ensure t
           :defer  t
           :commands (epe-theme-mohkale)
           :init
           (with-eval-after-load 'esh-mode
             (require 'eshell-prompt-extras))

           :config
           (setq epe-show-python-info t
                 epe-path-style 'full)

           (defvar eshell-prompt--enable-git-on-remote-files t
             "when true, show branch info even on remote files")

           (defun epe-git-p ()
             "If you installed git and in a git project."
             (when (or eshell-prompt--enable-git-on-remote-files
                       ;; either enable everywhere, including remote
                       ;; or enable when not remote
                       (not (epe-remote-p)))
               (and (eshell-search-path "git")
                    (vc-find-root (eshell/pwd) ".git"))))

           (setq eshell-prompt-function #'epe-theme-lambda)))
     #+END_SRC

*** eyebrowse
    #+BEGIN_SRC emacs-lisp
      (use-package eyebrowse
        :ensure t
        :defer  load-me-now-duration
        :config
        (eyebrowse-mode +1)

        (defun eyebrowse-switch-window-config--when-new-zen-current-window (func slot &rest args)
          "by default, when you create a new window config it's a complete copy
      of your current config. More often then not when you make a new config you
      want to change the layout of the windows (and buffers) within it. Creating
      a new config and then manuall deleting every other window is a pain, this
      makes it so when you make a new config, you're current window is maximised
      automatically."
          (let ((slot-new-p (not (eyebrowse--window-config-present-p slot))))
            (apply func slot args)
            (when (and slot-new-p
                       (> (length (window-list)) 1))
              (window-zen))))

        (advice-add 'eyebrowse-switch-to-window-config
                    :around #'eyebrowse-switch-window-config--when-new-zen-current-window))
    #+END_SRC

*** finder-mode
    #+BEGIN_SRC emacs-lisp
      (use-package finder
        :straight (finder :type built-in)
        :defer t
        :config
        (general-define-key
          :keymaps 'finder-mode-map
          "SPC" 'nil
          "?"   'nil
          [override-state] 'motion)

        (leader/set-keys-for-major-mode 'finder-mode
          "?" 'finder-summary))
    #+END_SRC

*** flycheck
    on the fly syntax checker for emacs. finds where you've written bugs, adds an icon
    to the fringe and underlines it.

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :ensure t
        :defer  t
        ;; :delight " ⓢ"
        :delight "FlyCheck"
        :commands (flycheck-last-error
                   flycheck-error-list-goto-first-error
                   flycheck-error-list-goto-last-error
                   flycheck-list-errors--goto-first-error)
        :init
        (leader/set-keys
          "ej" 'flycheck-next-error
          "ek" 'flycheck-previous-error
          "e." 'hydra-flycheck/body
          "ec" 'flycheck-clear
          "ee" 'flycheck-explain-error-at-point
          "eh" 'flycheck-describe-checker
          "eg" 'flycheck-first-error
          "eG" 'flycheck-last-error
          "eL" 'goto-flycheck-error-list
          "el" 'flycheck-list-errors
          "eS" 'flycheck-set-checker-executable
          "es" 'flycheck-select-checker
          "ev" 'flycheck-verify-setup)

        :config
        (setq flycheck-python-pycompile-executable "python3")

        (use-package flycheck-pos-tip
          :ensure t
          :defer  t
          :hook (flycheck-mode-hook . flycheck-pos-tip-mode)
          :commands flycheck-pos-tip-mode)

        (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))

        ;; update fringe for flycheck
        ;; src: https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bcheckers/syntax-checking/packages.el
        (define-fringe-bitmap 'mohkale-flycheck-fringe-indicator
          (vector #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00011100
                  #b00111110
                  #b00111110
                  #b00111110
                  #b00011100
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000
                  #b00000000))

        (let ((bitmap 'mohkale-flycheck-fringe-indicator))
          (flycheck-define-error-level 'error
            :severity 2
            :overlay-category 'flycheck-error-overlay
            :fringe-bitmap bitmap
            :fringe-face 'flycheck-fringe-error)
          (flycheck-define-error-level 'warning
            :severity 1
            :overlay-category 'flycheck-warning-overlay
            :fringe-bitmap bitmap
            :fringe-face 'flycheck-fringe-warning)
          (flycheck-define-error-level 'info
            :severity 0
            :overlay-category 'flycheck-info-overlay
            :fringe-bitmap bitmap
            :fringe-face 'flycheck-fringe-info))

        (defun flycheck-last-error ()
          (interactive)
          (goto-char (point-max))
          (flycheck-previous-error))

        (defun flycheck-error-list-goto-first-error ()
          (interactive)
          (goto-char (point-min))
          (flycheck-error-list-next-error 1)
          (flycheck-error-list-previous-error 1))

        (defun flycheck-error-list-goto-last-error ()
          (interactive)
          (goto-char (point-max))
          (flycheck-error-list-previous-error 1))

        (defun flycheck-list-errors--goto-first-error (func &rest args)
          (let ((flycheck-buffer (get-buffer "*Flycheck errors*")))
            (apply func args) ;; call flycheck-list-errors
            (unless flycheck-buffer
              (flycheck-error-list-goto-first-error))))

        (advice-add 'flycheck-list-errors :around #'flycheck-list-errors--goto-first-error)

        (general-define-key
          :keymaps 'flycheck-error-list-mode-map
          :states  'motion
          "RET" 'flycheck-error-list-goto-error
          "s" 'tabulated-list-sort

          "J"   'flycheck-error-list-next-error
          "K"   'flycheck-error-list-previous-error
          "C-j" 'flycheck-error-list-next-error
          "C-k" 'flycheck-error-list-previous-error

          "gS" 'flycheck-error-list-check-source
          "gg" 'flycheck-error-list-goto-first-error
          "G"  'flycheck-error-list-goto-last-error)

        (leader/set-keys-for-major-mode 'flycheck-error-list-mode
          "e" 'flycheck-error-list-explain-error
          "s" 'flycheck-error-list-check-source ;; syntax check buffer
          "f" 'flycheck-error-list-set-filter
          "F" 'flycheck-error-list-reset-filter))
    #+END_SRC

*** font-lock-studio
    debug issues with face declarations... I have no idea how to use this :P

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package font-lock-studio
        :ensure t
        :defer  t
        :commands font-lock-studio)
    #+END_SRC

*** frog-jump-buffer
    display an avy like popup of your most recent buffers and then jump to it.
    now that I have ibuffer and counsel-switch-buffer, I don't really need it.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package frog-jump-buffer
        :ensure t
        :defer  t
        :commands frog-jump-buffer
        :init
        (leader/set-keys
          "jb" 'frog-jump-buffer))
    #+END_SRC

*** grep
    emacs mode for interacting with output from the grep executeable.

    #+BEGIN_SRC emacs-lisp
      (use-package grep
        :defer t
        :config
        (mohkale/set-compilation-bindings 'grep-mode 'grep-mode-map))
    #+END_SRC

*** help
    #+BEGIN_SRC emacs-lisp
      (use-package help
        :straight (help :type built-in)
        :config
        ;; once was enough, stop repeating the same message please :P
        (advice-add 'help-window-display-message :around #'ignore))
    #+END_SRC

*** help-fns+
    #+BEGIN_SRC emacs-lisp
      (use-package help-fns+
        :straight (help-fns+ :type built-in)
        :defer t
        :commands (describe-buffer
                   describe-keymap
                   describe-mode
                   describe-function)
        :init
        (leader/set-keys
          "hdm" '("describe-mode" . describe-buffer)
          "hdf" 'describe-function
          "hdK" 'describe-keymap))
    #+END_SRC
    #+END_SRC

*** hide-comnt
    toggles the display of comments in the current buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package hide-comnt
        :defer t
        :commands hide/show-comments-toggle
        :init
        (leader/set-keys
          "t/" 'hide/show-comments-toggle))
    #+END_SRC

*** hide-modeline
    makes the mode-line blank in the current buffer. this doesn't let the buffer contents expand
    into the mode-line region, it simply makes it appear as if nothings there.

    #+BEGIN_SRC emacs-lisp
      (use-package hide-mode-line
        :ensure t
        :defer  t
        :after spaceline)
    #+END_SRC

*** hl-line
    apply a different background face to the current line.

    #+BEGIN_SRC emacs-lisp
      (use-package hl-line
        :hook ((prog-mode . hl-line-mode)
               (text-mode . hl-line-mode)))
    #+END_SRC

*** hl-todo
    highlight certain keywords in the current buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package hl-todo
        :ensure t
        :defer  t
        :hook ((prog-mode . global-hl-todo-mode)
               (text-mode . global-hl-todo-mode))
        :init
        (leader/set-keys
          "jt" 'hl-todo-next
          "jT" 'hl-todo-previous
          "et" 'hl-todo-occur

          "it" 'hl-todo-insert
          "it" 'hl-todo-insert-keyword))
    #+END_SRC

*** htmlize
    convert a code buffer to HTML.

    #+BEGIN_SRC emacs-lisp
      (use-package htmlize
        :ensure t
        :defer  t)
    #+END_SRC

*** hydra-posframe
    changes the display of the the hydra popups from some region above the message area into a
    posframe :) like frog-jump-buffer. That said, posframe seems to still be kind of buggy. The
    border parameter sometimes works, sometimes it doesn't.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package hydra-posframe
        :straight (hydra-posframe :type built-in)
        :defer   t
        :commands (hydra-posframe-mode
                   hydra-posframe-enable)
        :init
        (when (display-graphic-p)
          ;; only use posframe when on graphical display
          ;; my terminals always too short for it to be
          ;; useful on there.
          (add-hook 'after-init-hook 'hydra-posframe-mode))

        :config
        ;; source for following section [[https://github.com/jerrypnz/.emacs.d/blob/master/config/jp-base.el][here]].
        (defun mohkale--frame-bottom-poshandler (info)
          (cons (car (posframe-poshandler-frame-center info))
                (- (cdr (posframe-poshandler-frame-bottom-left-corner info)) 20)))

        (setq hydra-posframe-poshandler 'mohkale--frame-bottom-poshandler
              hydra-posframe-parameters '((alpha 100 100)
                                          (left-fringe . 10)
                                          (right-fringe . 10)
                                          (x-pixel-offset 4)
                                          (internal-border-width . 2))))
    #+END_SRC

*** iedit
    #+BEGIN_SRC emacs-lisp
      (use-package iedit
        :ensure t
        :defer  t
        :commands (evil-multiedit-match-all
                   evil-multiedit-prev
                   evil-multiedit-next
                   evil-multiedit-match-and-next
                   evil-multiedit-match-and-prev

                   evil-multiedit
                   evil-multiedit-all)
        :init
        (with-eval-after-load 'evil
          (evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)

          (general-define-key
            :states 'multiedit
            "g." 'hydra-evil-multiedit/body
            "g*" 'evil-multiedit-match-all
            "gk" 'evil-multiedit-prev
            "gj" 'evil-multiedit-next
            "gl" 'evil-multiedit-match-and-next
            "gh" 'evil-multiedit-match-and-prev)

          (general-define-key
            :states leader-norm-states
            "gm" 'evil-multiedit
            "g*" 'evil-multiedit-all
            "gM" 'evil-multiedit-restore)

          ;; (general-define-key
          ;;   :states 'visual
          ;;   "RET" 'evil-multiedit-toggle-or-restrict-region)
          )

        :config
        (use-package evil-multiedit
          :ensure t
          :demand t
          :commands (evil-multiedit
                     evil-multiedit-all)
          :config

          (defun evil-multiedit--multiedit (beg end)
            (evil-visual-select beg
                                (max 0 (- end 1)))
            (evil-multiedit-match-and-next))

          (evil-define-operator evil-multiedit (beg end)
            :repeat nil
            (if (evil-get-command-property 'evil-multiedit :move-point)
                (save-excursion
                  (evil-multiedit--multiedit beg end))
              (evil-multiedit--multiedit beg end)))

          (defun evil-multiedit--multiedit-all (beg end)
            (evil-visual-select beg
                                (max 0 (- end 1)))
            (evil-multiedit-match-all))

          (evil-define-operator evil-multiedit-all (beg end)
            :repeat nil
            (if (evil-get-command-property 'evil-multiedit-all :move-point)
                (save-excursion
                  (evil-multiedit--multiedit-all beg end))
              (evil-multiedit--multiedit-all beg end)))

          (general-define-key
            :keymaps 'evil-multiedit-state-map
            ;; "C-g" nil
            "G"  nil
            "gg" nil)))
    #+END_SRC

*** ivy
    a simple and elegent completion framework for emacs.

**** ivy
     #+BEGIN_SRC emacs-lisp
       (use-package ivy
         :straight t
         :defer    nil
         :commands (ivy-toggle-mark)
         :config
         (ivy-mode +1)

         (setq ivy-height 15
               counsel-evil-registers-height 15
               ivy-use-virtual-buffers t
               projectile-completion-system 'ivy
               ivy-magic-tilde nil)

         (when (emacs>= "27")
           ;; see issue: https://github.com/abo-abo/swiper/issues/2397
           (setq ivy-read-action-function #'ivy-hydra-read-action))

         (push 'ivy-occur-mode whitespace-exempt-modes)

         (setq ivy-preferred-re-builders
               '((ivy--regex-plus         . "ivy")
                 (ivy--regex-ignore-order . "order")
                 (ivy--regex-fuzzy        . "fuzzy")
                 (regexp-quote            . "literal"))

               ;; store as unique variable because counsel
               ;; will just end up adding to it anyways.
               mohkale--ivy-initial-inputs-alist
               '((counsel-minor . "^+")
                 ;; (counsel-package . "^+")
                 ;; (org-refile . "^")
                 (org-agenda-refile . "^")
                 (org-capture-refile . "^")
                 ;; (counsel-M-x . "^")
                 ;; (counsel-describe-function . "^")
                 ;; (counsel-describe-variable . "^")
                 ;; (counsel-org-capture . "^")
                 ;; (org-refile . "^")
                 ;; (org-agenda-refile . "^")
                 ;; (org-capture-refile . "^")
                 (Man-completion-table . "^")
                 (woman . "^"))

               ivy-initial-inputs-alist mohkale--ivy-initial-inputs-alist)

         (defvar ivy-actions-done-hook+ nil
           "hook run after ivy has completed a set of actions.
       this could be when `ivy-done' is invoked, or when `ivy-call'
       has been invoked.")

         (defun ivy-run-actions-done-hook+ (func &rest args)
           (unwind-protect
               (apply func args)
             (run-hooks 'ivy-actions-done-hook+)))

         (advice-add 'ivy-done :around #'ivy-run-actions-done-hook+)
         (advice-add 'ivy-call :around #'ivy-run-actions-done-hook+)

         (defun ivy-kill-line-backward ()
           (interactive)
           (delete-region (minibuffer-prompt-end) (point)))

         (defun ivy-forward-char-or-partial-or-done ()
           "move forward a character or complete selection
       completes selection when there's no characters left to
       move forward."
           (interactive)
           (call-interactively (if (eolp)
                                   'ivy-alt-done
                                 'forward-char)))

         (defun ivy-toggle-mark ()
           (interactive)
           (if (ivy--marked-p)
               (when (ivy--marked-p)
                 (ivy--unmark (ivy-state-current ivy-last)))
             (unless (ivy--marked-p)
               (ivy--mark (ivy-state-current ivy-last)))))

         (with-eval-after-load "persp-mode"
           ;; thanks [[https://gist.github.com/Bad-ptr/1aca1ec54c3bdb2ee80996eb2b68ad2d#file-persp-ivy-el][Bad-ptr]].
           (add-hook 'ivy-ignore-buffers
                     (lambda (b)
                       (when persp-mode
                         (let ((persp (get-current-persp)))
                           (if persp
                               (not (persp-contain-buffer-p b persp))
                             nil)))))

           (setq ivy-sort-functions-alist
                 (append ivy-sort-functions-alist
                         '((persp-kill-buffer   . nil)
                           (persp-remove-buffer . nil)
                           (persp-add-buffer    . nil)
                           (persp-switch        . nil)
                           (persp-window-switch . nil)
                           (persp-frame-switch  . nil)))))

         (general-define-key "M-x" 'counsel-M-x)

         (general-define-key
           :keymaps 'counsel-find-file-map
           "C-h" 'counsel-up-directory)

         (leader/set-keys
           "bb" 'ivy-switch-buffer
           "SPC" 'counsel-M-x
           "RET" 'ivy-resume)

         (general-define-key
           :keymaps '(counsel-ag-map
                      counsel-imenu-map)
           "C-l" 'ivy-forward-char-or-partial-or-done
           "M-l" 'ivy-call-and-recenter)

         (general-define-key
           :keymaps 'ivy-minibuffer-map
           "C-j"   nil ;; was ivy-alt-done
           "M-j"   nil ;; was ivy-yank-word
           "M-v"   nil ;; was ivy-scroll-down-command
           "C-'"   nil ;; was ivy-avy
           "C-M-y" nil ;; was ivy-insert-current-full

           "C-r" 'evil-paste-from-register
           "C-s" 'ivy-reverse-i-search

           "C-v"      'quoted-insert ;; was ivy-scroll-up-command
           "<return>" 'ivy-alt-done ;; also supports tramp expansion

           ;;; misc
           "C-?" 'describe-mode
           "M-d" 'kill-ring-save ;; save all candidates to kill ring
           ;; erase input, but start filtering from current candidates
           "S-SPC" 'ivy-restrict-to-matches

           ;;; marking
           "C-SPC"         'ivy-mark
           "M-SPC"         'ivy-toggle-mark
           "C-M-SPC"       'ivy-toggle-marks
           "<S-backspace>" 'ivy-unmark-backward

           ;;; selection execution
           ;; exit with current input, not selection
           "<S-return>"   'ivy-immediate-done
           "C-c <return>" 'ivy-immediate-done
           ;; prompt for action, then done
           "<C-return>" 'ivy-dispatching-done
           ;; invoke default action'but exit the minibuffer
           "M-RET" 'ivy-call
           ;; prompt for action, then call
           "C-M-<return>" 'ivy-dispatching-call
           ;; move down, then call default action
           "C-M-j" 'ivy-next-line-and-call
           ;; move down, then call default action
           "C-M-k" 'ivy-previous-line-and-call
           "<escape>" 'minibuffer-keyboard-quit

           ;;; movement commands
           "C-a" 'move-beginning-of-line
           "C-e" 'move-end-of-line
           "C-h" 'backward-char
           "C-l" 'ivy-forward-char-or-partial-or-done
           "C-j" 'next-line
           "C-k" 'previous-line
           "C-q" 'ivy-avy
           "M-j" 'ivy-next-history-element
           "M-k" 'ivy-previous-history-element
           "M-u" 'ivy-occur
           ;; arrow key variants
           "<left>"  'backward-char
           "<right>" 'forward-char
           "<up>"    'previous-line
           "<down>"  'next-line
           ;; suprisingly enough, these are bound correctly
           "C-d" 'scroll-up-command
           "C-u" 'scroll-down-command
           ;; taken from helm, shadows C-o hydra-ivy/body
           "M-o" 'beginning-of-buffer
           "C-o" 'end-of-buffer

           ;;; insertion/deletion
           ;; complete current selection into minibuffer
           ;; leave prompt active to build on it.
           "C-i" 'ivy-insert-current
           "C-DEL" 'evil-delete-backward-word
           ;; pull word in from point at buffer
           "M-y" 'ivy-yank-word
           "C-w" 'backward-kill-word
           ;; operate on entire input
           "M-w" 'ivy-kill-line-backward
           "M-W" 'kill-line ;; kill forward
           "M-DEL" 'kill-whole-line

           ;;; history - (C-r/C-s still work fine)
           "<S-up>"    'ivy-previous-history-element
           "<S-down>"  'ivy-next-history-element)

         (general-define-key
           :keymaps 'ivy-switch-buffer-map
           "C-k" 'previous-line
           "M-d" 'ivy-switch-buffer-kill)

         (general-define-key
           :keymaps 'ivy-reverse-i-search-map
           "C-k" 'previous-line
           "C-d" 'ivy-reverse-i-search-kill)

         ;; ivy-occur
         (leader/set-keys-for-major-mode '(ivy-occur-mode
                                           ivy-occur-grep-mode)
           ;; 'ivy-wgrep-change-to-wgrep-mode
           "SPC" 'ivy-occur-read-action
           "m"   'ivy-occur-toggle-calling)

         (general-define-key
           :keymaps 'ivy-occur-mode-map
           :states 'motion
           "RET" 'ivy-occur-press-and-switch
           "M-RET" 'ivy-occur-press
           "<C-return>" 'ivy-occur-dispatch
           "gj" 'ivy-occur-next-line
           "gk" 'ivy-occur-previous-line
           "}" 'ivy-occur-next-line
           "{" 'ivy-occur-previous-line
           "d" 'ivy-occur-delete-candidate
           "o" 'compilation-display-error

           "gr" 'ivy-occur-revert-buffer
           "q" nil))
     #+END_SRC

***** collapse-directories
      see [[https://github.com/abo-abo/swiper/issues/2211][this]] link for a description of the problem which this addresses.
      I don't really need it for now so I'm not tangling.

      #+BEGIN_SRC emacs-lisp :tangle no
        (defvar mohkale/ivy-collapse-paths t
          "when true, empty directories are chained together.")

        (defvar mohkale/ivy-collapse-paths--append-files nil
          "when true, the only file in a directory is appended to
        that directory when shown by ivy. otherwise the directory
        is shown by itself.")

        (defun collapse-directories (path files &optional read-directories-command)
          "collapses any hollow directory files under PATH.
        a hollow directory is any directory which is either empty
        or has only one child which must be a file. depending on
        `mohkale/ivy-collapse-paths--append-files' that files is also
        appended to the path.

        if you'd like to specify you're own command for listing directories
        (or have aliased `directory-files' for your own purposes), you can
        specify the read-command as the final optional arg to this function."
          (or read-directories-command
              (setq read-directories-command #'directory-files))

          (mapcar
           (lambda (file)
             (when (and (ivy--dirname-p file)
                        (not (or (string-equal file "./")
                                 (string-equal file "../"))))
               (let (dir-files file-count (do-recurse t))
                 (ignore-errors ;; in case of permission errors
                   (while do-recurse
                     (setq dir-files  (funcall
                                       read-directories-command
                                       (concat path file)
                                       ;; all but . and ..
                                       nil "^[^\\.]\\{1,2\\}")
                           file-count (length dir-files))
                     (cond
                      ;; nothing left to recurse, end recursion
                      ((eq file-count 0) (setq do-recurse nil))
                      ;; at least one found, cancel unless directory
                      ((eq file-count 1)
                       (let* ((only-child (concat file (car dir-files))))
                         (if (file-directory-p (concat path only-child))
                             ;; include trailing / for identity purposes
                             (setq file (concat only-child "/"))
                           ;; encountered final leaf only-child, show if desired
                           (when mohkale/ivy-collapse-paths--append-files
                             (setq file only-child))
                           (setq do-recurse nil))))
                      ;; encountered non-hollow directory
                      (t (setq do-recurse nil)))))))
             file)
           files))

        (defun counsel-find-file--collapse-directories-wrapper (func dir)
          (if (not mohkale/ivy-collapse-paths)
              (apply func dir nil) ;; no collapsing, leave as is
            (cl-letf* (((symbol-function 'actual-directory-files)
                        (symbol-function 'directory-files))
                       ((symbol-function 'actual-read-file-name-internal)
                        (symbol-function 'read-file-name-internal))

                       ;; wrap `read-file-name-internal' and `directory-files'
                       ;; into collapsing directories when possible.
                       ((symbol-function 'read-file-name-internal)
                        (lambda (&rest args)
                          (collapse-directories default-directory
                                                (apply #'actual-read-file-name-internal args)
                                                #'actual-directory-files)))
                       ((symbol-function 'directory-files)
                        (lambda (dir)
                          (collapse-directories dir
                                                (mapcar
                                                 ;; directory-files doesn't append / to dirs
                                                 ;; so `ivy--dirname-p' won't work with them.
                                                 (lambda (file)
                                                   (if (file-directory-p (concat dir file))
                                                       (setq file (concat file "/")))
                                                   file)
                                                 (actual-directory-files dir))
                                                #'actual-directory-files))))
              (apply func dir nil))))

        (advice-add 'ivy--sorted-files :around #'counsel-find-file--collapse-directories-wrapper)
      #+END_SRC

***** ivy-hydra
      #+BEGIN_SRC emacs-lisp
        (use-package ivy-hydra
          :ensure t
          :defer  t
          :after ivy
          :commands hydra-ivy/body
          :init
          (general-define-key
            :keymaps 'ivy-minibuffer-map
            "C-." 'hydra-ivy/body)

          :config
          (when (autoloadp (symbol-function 'hydra-ivy-custom/body))
            (autoload-do-load (symbol-function 'hydra-ivy-custom/body))))
      #+END_SRC

**** ivy-xref
     #+BEGIN_SRC emacs-lisp
       (use-package ivy-xref
         :ensure t
         :defer  t
         :init
         (when (emacs>= "27")
           (setq xref-show-definitions-function #'ivy-xref-show-defs))
         (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
     #+END_SRC

**** counsel
     a bunch of really useful functions to go alongside ivy.

     #+BEGIN_SRC emacs-lisp
       (use-package counsel
         :ensure t
         :defer  t
         :after ivy
         :diminish
         :init
         (fset 'describe-bindings-buffer (symbol-function 'describe-bindings))
         (fset 'describe-bindings (symbol-function 'counsel-descbinds))

         (leader/set-keys
           "r"  "register/rings/resume"
           "fs" "recursive-find")

         (leader/set-keys-for-major-mode 'org-mode
           "g" 'counsel-org-goto
           "G" 'counsel-org-goto-all)

         (general-define-key
           :keymaps 'mohkale-window-map
           "x" 'counsel-wmctrl
           "C-x" 'counsel-wmctrl)

         (with-eval-after-load 'org
           (leader/set-keys
             "oc" 'counsel-org-capture
             "oh" 'counsel-org-agenda-headlines))

         (with-eval-after-load 'company
           (general-define-key
             :keymaps 'company-mode-map
             "C-:" 'counsel-company))

         (leader/set-keys
           "ae" 'counsel-package
           "ic" 'counsel-unicode-char
           "ie" 'counsel-org-entity
           "Mm" 'counsel-major

           "ry" 'counsel-yank-pop
           "rm" 'counsel-mark-ring
           "rn" 'counsel-evil-marks
           "rr" 'counsel-register
           "re" 'counsel-evil-registers
           "rf" 'counsel-file-registers
           "al" 'counsel-load-library
           "bO" 'counsel-outline

           "ff" 'counsel-find-file
           "fb" 'counsel-bookmark
           "fr" 'counsel-recentf
           "fsf" 'counsel-file-jump
           "fsd" 'counsel-dired-jump

           "ci" 'counsel-compile

           "sb" 'counsel-grep
           ;; recursive searches
           "sv" 'counsel-git-grep
           "sp" 'counsel-pt
           "sa" 'counsel-ag
           "sr" 'counsel-rg

           ;; "bb" 'counsel-buffer-or-recentf ;; WARN only file buffers
           "bb" 'counsel-switch-buffer
           "hdf" 'counsel-describe-function
           "hdx" 'counsel-fonts
           "hdv" 'counsel-describe-variable
           "hdB" 'describe-bindings-buffer)

         (general-define-key
           "C-M-y" 'counsel-yank-pop)

         :config
         (setq ivy-initial-inputs-alist mohkale--ivy-initial-inputs-alist
               counsel-find-file-occur-use-find t
               counsel-evil-registers-height ivy-height
               counsel-find-file-ignore-regexp "\\.#.+")

         (when (windows-p)
           (setq counsel-rg-base-command "rg --with-filename --no-heading --line-number --path-separator // --color never %s ."))

         (counsel-mode +1)

         (defun counsel-find-file--jump-to-bookmark ()
           "jumpt to a bookmark directory from a `counsel-find-file' session"
           (interactive)
           (require 'bookmark)
           (let ((last-directory ivy--directory))
             (ivy-quit-and-run
               (ivy-read "Jump to bookmark: "
                         (counsel-bookmarked-directory--candidates)
                         :caller 'counsel-find-file--jump-to-bookmark
                         :action (lambda (dir)
                                   (counsel-find-file (if (string-empty-p dir)
                                                          last-directory
                                                        dir)))))))

         (advice-add 'counsel-company :before
                     (defun counsel-company--hide-popup (&rest args)
                       (company-cancel)))

         (ivy-set-actions 'counsel-fonts
                          '(("o" describe-font "describe")))

         (ivy-configure 'counsel-evil-registers :height ivy-height)

         (general-define-key
           :keymaps 'counsel-find-file-map
           "C-b" 'counsel-find-file--jump-to-bookmark)

         (general-define-key
           :keymaps 'counsel-describe-map
           "C-."   'hydra-ivy/body
           "C-S-." 'counsel-find-symbol))
     #+END_SRC

**** swiper
     a minimalist search framework for the current buffer.

     #+BEGIN_SRC emacs-lisp
       (use-package swiper
         :ensure t
         :defer  t
         :after ivy
         :init
         (leader/set-keys
           "ss" 'swiper
           "s*" 'swiper-all
           "sS" 'swiper-multi)

         (general-define-key
           :keymaps 'ivy-mode-map
           "M-s" 'swiper-isearch-thing-at-point
           [remap isearch-forward] 'swiper-isearch)

         :config
         (defvar swiper-persistent-highlight nil
           "if swiper is using evil-search for searching, determine
       whether to persistently highlight the search results or not.

       Personally I don't like persistent highlighting with swiper
       because I generally use it for one off jumping to important
       lines, so disable it :P")

         (setq swiper-min-highlight most-positive-fixnum) ;; never highlight

         (advice-add #'swiper--remember-search-history :around
                     (defun swiper--clear-evil-highlight (func &rest args)
                       "see `swiper-persistent-highlight'."
                       (if (bound-and-true-p evil-mode)
                           (let ((evil-ex-search-persistent-highlight
                                  swiper-persistent-highlight))
                             (apply func args))
                         (apply func args))))

         (advice-add #'swiper--action :around
                     (defun swiper--action-configure (func &rest args)
                       ;; disable search highlighting in case of new pattern.
                       (when (bound-and-true-p evil-mode)
                         (evil-ex-nohighlight))

                       ;; I don't wanna be told that every time I complete a search
                       (cl-letf (((symbol-function 'actual-message)
                                  (symbol-function 'message))
                                 ((symbol-function 'message)
                                  (lambda (message &rest message-args)
                                    (unless (string-equal message "Mark saved where search started")
                                      (apply actual-message message-args)))))
                         (apply func args))))

         (defvar swiper-norm-action--macro-history nil
           "history variable for macros invoked through `swiper-norm-action'.")

         (defvar swiper-norm-action--macro nil
           "the macro string used for the current invocation
       of `swiper-norm-action'.")
         (add-hook 'ivy-actions-done-hook+
                   (lambda (&rest _)
                     "reset the macro recorded by `swiper-norm-action'."
                     (setq swiper-norm-action--macro nil)))

         (defun swiper-norm-action--execute (markers macro)
           (unwind-protect
               (dolist (marker markers)
                 (goto-char marker)
                 (evil-ex-normal
                  (line-beginning-position)
                  (line-end-position)
                  macro))
             ;; ensure that all markers are deleted afterwards,
             ;; even in the event of failure
             (dolist (marker markers)
               (set-marker marker nil))))

         (defun swiper-norm-action (_)
           "use swiper like evils :global and :norm command.
       this function prompts for a normal mode macro string, and then
       runs the macro on every candidate in the current swiper session.

       This function tries to be smart about how it's invoked, if it's called
       with no marked candidates, it runs a macro on every candidate in the
       current swiper session. Otherwise it runs only on the candidates that're
       marked."
           ;; when `swiper-norm-action--macro' has already been assigned, this function
           ;; is being called through marked candidates, which've already been
           ;; operated on, so just ignore them.
           (unless swiper-norm-action--macro
             (let ((history-add-new-input t))
               (setq swiper-norm-action--macro
                     (read-string "macro: " nil
                                  'swiper-norm-action--macro-history)))

             (unless (string-empty-p swiper-norm-action--macro)
               (let* ((markers
                       (save-excursion
                         (goto-char (point-min)) ;; start from beginning of buffer, downwards

                         (cl-loop
                          for cand in (or ivy-marked-candidates ivy--old-cands) collect
                          (move-marker (make-marker)
                                       (line-beginning-position
                                        (get-text-property 0 'swiper-line-number cand)))))))
                 (evil-with-single-undo
                   (swiper-norm-action--execute markers swiper-norm-action--macro))))))

         (ivy-add-actions 'swiper '(("n" swiper-norm-action "norm")))

         (general-define-key
           :keymaps 'swiper-map
           "M-l" 'swiper-recenter-top-bottom
           "C-l" 'ivy-forward-char-or-partial-or-done
           "C-q" 'swiper-avy
           "C-s" 'swiper-query-replace))
     #+END_SRC

**** ivy-yasnippet
     use ivy to select a snippet candidate.

     #+BEGIN_SRC emacs-lisp
       (use-package ivy-yasnippet
         :ensure t
         :defer  t
         :after ivy
         :init
         (leader/set-keys
           "is" 'ivy-yasnippet)

         (general-define-key
           :states 'insert
           "C-M-i" 'ivy-yasnippet))
     #+END_SRC

**** counsel-pydoc
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'python
         (use-package counsel-pydoc
           :ensure t
           :defer  t
           :after  counsel
           :init
           (leader/set-keys-for-major-mode 'python-mode
             "hd" 'counsel-pydoc)))
     #+END_SRC

**** counsel-ggtags
     #+BEGIN_SRC emacs-lisp
       (use-package counsel-gtags
         :ensure t
         :defer  t
         :after counsel
         :init
         (leader/set-keys
           "Tg" 'counsel-gtags-find-definition
           "TG" 'counsel-gtags-find-reference
           "Ts" 'counsel-gtags-find-symbol
           "Tf" 'counsel-gtags-find-file
           "Tn" 'counsel-gtags-go-forward
           "TN" 'counsel-gtags-go-backward
           "Tc" 'counsel-gtags-create-tags
           "Tu" 'counsel-gtags-update-tags
           "TT" 'counsel-gtags-dwim))
     #+END_SRC

**** counsel-tramp
     select a remote system to connect to, using ivy.

     #+BEGIN_SRC emacs-lisp
       (use-package counsel-tramp
         :ensure t
         :defer  t
         :after counsel
         :init
         (leader/set-keys
           "f@" 'counsel-tramp))
     #+END_SRC

**** counsel-css
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'css-mode
         (use-package counsel-css
           :ensure t
           :defer  t
           :after counsel
           :config
           (leader/set-keys-for-major-mode '(css-mode less-css-mode)
             "g" 'counsel-css)))
     #+END_SRC

**** counsel-web
     like [[*engine-mode][engine-mode]] except runs queries asynchronously and displays results using an ivy
     session.

     #+BEGIN_SRC emacs-lisp
       (use-package counsel-web
         :straight (counsel-web :type git :host github :repo "mnewt/counsel-web")
         :defer  t
         :after counsel
         :commands (counsel-web-suggest ;; async
                    counsel-web-search
                    counsel-web-thing-at-point)
         :init
         (setq counsel-web-search-action #'browse-url)

         (leader/set-keys
           "se RET"   'counsel-web-search
           "se M-RET" 'counsel-web-suggest
           "se TAB"   'counsel-web-thing-at-point))
     #+END_SRC

**** counsel-word-clock
     see the time from anywhere in the world... I'll probably never use this.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package counsel-word-clock
         :straight (counsel-word-clock :type git :host github :repo "kchenphy/counsel-world-clock")
         :defer  t
         :after  counsel)
     #+END_SRC

**** helm-make
     don't be fooled, helm make works with both helm and ivy.

     #+BEGIN_SRC emacs-lisp
       (use-package helm-make
         :ensure t
         :defer  t
         :init
         (setq helm-make-completion-method 'ivy)

         (leader/set-keys
           "c SPC" 'helm-make-projectile
           "cm"    'helm-make))
     #+END_SRC

**** flx
     optimizes ivy search ordering for fuzzy searches.

     #+BEGIN_SRC emacs-lisp
       (use-package flx
         :ensure t
         :defer  t)
     #+END_SRC

**** smex
     show recently accessed commands at the top of M-x.

     #+BEGIN_SRC emacs-lisp
       (use-package smex
         :ensure t
         :defer  t
         :config
         (setq smex-save-file (var! "smex-save.el")))
     #+END_SRC

**** ivy-lsp
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'lsp-mode
         (use-package lsp-ivy
           :ensure t
           :defer  t
           :init
           (leader/set-keys-for-mode 'lsp-mode
             "jy" 'lsp-ivy-workspace-symbol
             "jY" 'lsp-ivy-global-workspace-symbol)))
     #+END_SRC

*** ibuffer
**** ibuffer
     #+BEGIN_SRC emacs-lisp
       (use-package ibuffer
         :defer t
         :hook (ibuffer-mode . hl-line-mode)
         :init
         (leader/set-keys
           "bm" 'ibuffer)

         :config
         (defvar ibuffer-show-buffer-icons nil
           "whether to show icons alongside the buffer")

         (setq ibuffer-filter-group-name-face '(:inherit (font-lock-string-face bold))
               ibuffer-title-face '(:inherit (font-lock-type-face)))

         (evil-set-initial-state 'ibuffer-mode 'motion)

         (setq mohkale-ibuffer-filter-map (make-sparse-keymap))

         (general-define-key
           :keymaps 'mohkale-ibuffer-filter-map
           "TAB"    'ibuffer-exchange-filters
           "RET"    'ibuffer-filter-by-mode
           "DEL"    'ibuffer-delete-saved-filters
           "M-DEL"  'ibuffer-delete-saved-filter-groups
           "!"      'ibuffer-negate-filter
           "&"      'ibuffer-and-filter
           "|"      'ibuffer-or-filter
           "*"      'ibuffer-filter-by-starred-name
           "."      'ibuffer-filter-by-file-extension
           ","      'ibuffer-filter-by-used-mode
           "/"      'ibuffer-filter-disable
           "\\"     'ibuffer-clear-filter-groups
           "<"      'ibuffer-filter-by-size-lt
           ">"      'ibuffer-filter-by-size-gt
           "a"      'ibuffer-add-saved-filters
           "b"      'ibuffer-filter-by-basename
           "c"      'ibuffer-filter-by-content
           "e"      'ibuffer-filter-by-predicate
           "f"      'ibuffer-filter-by-filename  ; regexp
           "d"      'ibuffer-filter-by-directory ; regexp
           "D"      'ibuffer-filter-by-directory-path
           "g"      'ibuffer-filters-to-filter-group
           "("      'ibuffer-filters-to-filter-group
           "i"      'ibuffer-filter-by-modified
           "m"      'ibuffer-filter-by-used-mode
           "M"      'ibuffer-filter-by-derived-mode
           "n"      'ibuffer-filter-by-name
           "o"      'ibuffer-or-filter
           "p"      'ibuffer-pop-filter
           "P"      'ibuffer-pop-filter-group
           "u"      'ibuffer-decompose-filter
           "U"      'ibuffer-decompose-filter-group
           "r"      'ibuffer-switch-to-saved-filters
           "R"      'ibuffer-switch-to-saved-filter-groups
           "v"      'ibuffer-filter-by-visiting-file
           "w"      'ibuffer-save-filters
           "W"      'ibuffer-save-filter-groups
           "x"      'ibuffer-exchange-filters
           "<down>" 'ibuffer-pop-filter-group
           "<up>"   'ibuffer-pop-filter)

         (leader/set-keys-for-major-mode 'ibuffer-mode
           ;; unbound:
           ;;  * ibuffer-do-print
           "1"   'ibuffer-visit-buffer-1-window
           "+"   'ibuffer-add-to-tmp-show
           "-"   'ibuffer-add-to-tmp-hide
           "."   'hydra-ibuffer/body
           "/"    mohkale-ibuffer-filter-map
           "RET" 'ibuffer-do-view-horizontally
           "A"   'ibuffer-auto-mode
           "E"   'ibuffer-do-view-and-eval
           "e"   'ibuffer-do-eval
           "R"   'ibuffer-redisplay
           "r"   'ibuffer-do-rename-uniquely
           "S"   'ibuffer-do-query-replace
           "s"   'ibuffer-do-save
           ;; "s"   'ibuffer-do-replace-regexp
           "T"   'ibuffer-visit-tags-table
           "f"   'ibuffer-find-file
           "|"   'ibuffer-do-shell-command-pipe-replace
           "~"   'ibuffer-do-toggle-modified

           "g"  "jump/goto"
           "gg" 'ibuffer-jump-to-buffer
           "gf" 'ibuffer-jump-to-filter-group

           "/" "filter"

           "m"  "mark"
           "mm" 'ibuffer-toggle-marks
           "m/" 'ibuffer-mark-by-file-name-regexp
           ;; "m M-/" 'ibuffer-mark-by-name-regexp
           "mo" 'ibuffer-mark-old-buffers
           "ml" 'ibuffer-mark-by-locked
           "mb" 'ibuffer-mark-by-content-regexp
           "mM" 'ibuffer-mark-by-mode-regexp
           "md" 'ibuffer-mark-dired-buffers
           "mh" 'ibuffer-mark-help-buffers
           "mn" 'ibuffer-mark-dissociated-buffers
           "mN" 'ibuffer-mark-unsaved-buffers
           "m*" 'ibuffer-mark-modified-buffers
           "ms" 'ibuffer-mark-special-buffers
           "m%" 'ibuffer-mark-read-only-buffers
           "mz" 'ibuffer-mark-compressed-file-buffers)

         (general-unbind
           :keymaps 'ibuffer-mode-map
           "+" "-" "0" "f" "SPC" "S-SPC" ">" "<" "?" "h" "X" "F" "C-d" "C-t"
           "b" "n" "g" "p" "w" "s" "`" "," "*" "/" "A" "C-c" "C-x" "M-s" "M-g"
           "M-n" "M-p" "M-{" "M-}" "M-o" "M-DEL" "%")

         (general-define-key
           :keymaps 'ibuffer-mode-map
           :states  'motion
           "TAB"       'ibuffer-forward-filter-group
           "<S-tab>"   'ibuffer-backward-filter-group
           "<backtab>" 'ibuffer-backward-filter-group
           ;; "D" 'ibuffer-mark-for-delete-backwards
           "D"       'ibuffer-do-delete
           "M"       'ibuffer-do-toggle-modified
           "="       'ibuffer-diff-with-file
           "o"       'ibuffer-visit-buffer-other-window
           "M-o"     'ibuffer-visit-buffer-other-frame
           "M-RET"   'ibuffer-visit-buffer-other-window-noselect
           "RET"     'ibuffer-visit-buffer
           "O"       'ibuffer-do-occur
           "gr"      'ibuffer-update
           "gR"      'ibuffer-do-revert
           "gw"      'ibuffer-do-save
           ;; "R" 'ibuffer-do-revert
           "R"       'ibuffer-do-toggle-read-only
           "r"       'ibuffer-change-marks
           "S"       'ibuffer-toggle-sorting-mode
           "sa"      'ibuffer-do-sort-by-alphabetic
           "sf"      'ibuffer-do-sort-by-filename/process
           "si"      'ibuffer-invert-sorting
           "sm"      'ibuffer-do-sort-by-major-mode
           "ss"      'ibuffer-do-sort-by-size
           "sr"      'ibuffer-do-sort-by-recency
           "v"       'ibuffer-do-view
           "V"       'ibuffer-do-view-other-frame
           "("       'ibuffer-switch-format
           "p"       'ibuffer-yank
           "C-y"     'ibuffer-yank
           "C-/"      mohkale-ibuffer-filter-map
           "C-j"     'ibuffer-forward-line
           "C-k"     'ibuffer-backward-line
           "M-j"     'ibuffer-forward-filter-group
           "M-k"     'ibuffer-backward-filter-group
           "C-S-J"   'ibuffer-forward-next-marked
           "C-S-K"   'ibuffer-backwards-next-marked
           "C-M-S-k" 'ibuffer-do-kill-lines
           "C-M-d"   'ibuffer-do-kill-lines
           "C-M-k"   'ibuffer-kill-line
           "M-d"     'ibuffer-kill-line
           "S-DEL"   'ibuffer-bury-buffer
           ;; "C-s" 'ibuffer-do-isearch
           "C-s"     'ibuffer-do-isearch-regexp
           "yn"      'ibuffer-copy-buffername-as-kill)

         ;;; https://www.emacswiki.org/emacs/IbufferMode
         ;;  _                                                          _       _     _
         ;; | |__  _   _ _ __ ___   __ _ _ __        _ __ ___  __ _  __| | __ _| |__ | | ___
         ;; | '_ \| | | | '_ ` _ \ / _` | '_ \ _____| '__/ _ \/ _` |/ _` |/ _` | '_ \| |/ _ \
         ;; | | | | |_| | | | | | | (_| | | | |_____| | |  __/ (_| | (_| | (_| | |_) | |  __/
         ;; |_| |_|\__,_|_| |_| |_|\__,_|_| |_|     |_|  \___|\__,_|\__,_|\__,_|_.__/|_|\___|
         ;;

         (defun ibuffer--human-readable-file-sizes-to-bytes (string)
           "Convert a human-readable file size into bytes."
           ;; (interactive)
           (let ((decimal (string-to-number string)))
             (cond
              ((string-suffix-p "G" string t) (* 1000000000 decimal))
              ((string-suffix-p "M" string t) (* 1000000    decimal))
              ((string-suffix-p "K" string t) (* 1000       decimal))
              (t                                            decimal))))

         (defun ibuffer--bytes-to-human-readable-file-sizes (bytes)
           "Convert number of bytes to human-readable file size."
           ;; (interactive)
           (cond
            ((> bytes 1000000000) (format "%10.1fG" (/ bytes 1000000000.0)))
            ((> bytes 100000000)  (format "%10.0fM" (/ bytes 1000000.0)))
            ((> bytes 1000000)    (format "%10.1fM" (/ bytes 1000000.0)))
            ((> bytes 100000)     (format "%10.0fk" (/ bytes 1000.0)))
            ((> bytes 1000)       (format "%10.1fk" (/ bytes 1000.0)))
            (t                    (format "%10d"       bytes))))

         ;; Use human readable Size column instead of original one
         (define-ibuffer-column size-human-readable
           (:name "Size"
            :inline t
            :summarizer
            (lambda (column-strings)
              (let ((total 0))
                (dolist (string column-strings)
                  (setq total
                        ;; like, ewww ...
                        (+ (float (ibuffer--human-readable-file-sizes-to-bytes
                                   string))
                           total)))
                (ibuffer--bytes-to-human-readable-file-sizes total))))
           (ibuffer--bytes-to-human-readable-file-sizes (buffer-size)))

         ;; Source [[https://github.com/seagle0128/.emacs.d/blob/master/lisp/init-ibuffer.el][seagle0128]]
         (define-ibuffer-column icon (:name "  ")
           (let ((icon (if (and (buffer-file-name)
                                (all-the-icons-auto-mode-match?))
                           (all-the-icons-icon-for-file
                            (file-name-nondirectory (buffer-file-name))
                            :v-adjust -0.05)
                         (all-the-icons-icon-for-mode major-mode :v-adjust -0.05))))
             (when (symbolp icon)
               (setq icon (all-the-icons-faicon "file-o"
                           :face 'all-the-icons-dsilver
                           :height 0.8 :v-adjust 0.0)))
             icon))

         (setq ibuffer-formats
               `((mark modified read-only locked
                       " "
                       ,@(when ibuffer-show-buffer-icons
                           (list '(icon 2 2 :left :elide)
                                  (propertize " " 'display `(space :align-to 8))))
                       (name 20 20 :left :elide)
                       " "
                       (size-human-readable 11 -1 :right)
                       " "
                       (mode 16 16 :left :elide)
                       " " filename-and-process)
                 (mark " "
                       ,@(when ibuffer-show-buffer-icons
                           (list '(icon 2 2 :left :elide)
                                 (propertize " " 'display `(space :align-to 8))))

                       (name 20 20)
                       " "
                       filename))))
     #+END_SRC

**** ibuffer-filters
     #+BEGIN_SRC emacs-lisp
       (use-package ibuf-ext
         :commands (ibuffer-filter-by-directory-path)
         :config
         (define-ibuffer-filter directory-path
             "Toggle current view to buffers with file or directory name matching QUALIFIER."
           (:description "filename"
            :reader (file-truename
                     (read-directory-name "List files from file/directory name: ")))
           (ibuffer-awhen (or (buffer-local-value 'buffer-file-name buf)
                              (buffer-local-value 'dired-directory buf))
             ;; (message "qual: %s, it: %s" qualifier (file-truename it))
             (string-prefix-p qualifier (file-truename it)))))
     #+END_SRC

**** ibuffer-vc
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'ibuffer
         (use-package ibuffer-vc
           :ensure t
           :defer  t
           :after ibuffer
           :commands ibuffer-vc
           :init
           (general-define-key
             :keymaps 'ibuffer-mode-map
             "sv" 'ibuffer-vc
             ")" 'ibuffer-vc)

           :config
           (defalias 'ibuffer-vc #'ibuffer-vc-set-filter-groups-by-vc-root)))
     #+END_SRC

**** ibuffer-tramp
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'ibuffer
         (use-package ibuffer-tramp
           :ensure t
           :defer  t
           :after ibuffer
           :commands (ibuffer-tramp)
           :init
           (general-define-key
             :keymaps 'ibuffer-mode-map
             "s@" 'ibuffer-tramp)

           :config
           (defalias 'ibuffer-tramp #'ibuffer-tramp-set-filter-groups-by-tramp-connection)))
     #+END_SRC

**** ibuffer-persp
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'ibuffer
         (use-package ibuffer-persp
           :straight (ibuffer-persp :type built-in)
           :defer t
           :commands (ibuffer-persp-current
                      ibuffer-persp-other)
           :init
           (general-define-key
             :keymaps 'ibuffer-mode-map
             "sp" 'ibuffer-persp-current
             "sP" 'ibuffer-persp-other)

           ;; (with-eval-after-load 'persp-mode
           ;;   (leader/set-keys "bm" 'ibuffer-persp))
           :config
           (defalias 'ibuffer-persp-current #'ibuffer-persp-set-filter-groups-by-persp-name-not-nil)
           (defalias 'ibuffer-persp-other #'ibuffer-persp-set-filter-groups-by-other-persp-name-not-nil)))
     #+END_SRC

**** ibuffer-projectile
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'ibuffer
         (use-package ibuffer-projectile
           :ensure t
           :defer  t
           :commands (ibuffer-projectile-mode)
           ;; :hook (ibuffer-mode . ibuffer-projectile-mode)
           :config
           (setq ibuffer-projectile-prefix
                 (if (all-the-icons-available-p)
                     (concat
                      (all-the-icons-octicon "file-directory"
                                             :face ibuffer-filter-group-name-face
                                             :v-adjust -0.05)
                      " ")
                   "Project: "))

           (defun ibuffer-projectile-hook (&rest _)
             (ibuffer-projectile-set-filter-groups))

           (define-minor-mode ibuffer-projectile-mode
             "Generate ibuffer filters for projectile projects."
             :lighter nil
             :global  t
             (if ibuffer-projectile-mode
                 (progn
                   (add-hook 'ibuffer-hook #'ibuffer-projectile-hook)
                   (ibuffer-projectile-set-filter-groups))
               (remove-hook 'ibuffer-hook #'ibuffer-projectile-hook)

               (let ((ibuf (get-buffer "*Ibuffer*")))
                 (when ibuf
                   (with-current-buffer ibuf
                     (setq ibuffer-filter-groups
                           (seq-filter
                            (lambda (x)
                              (not (assoc 'projectile-root x)))
                            ibuffer-filter-groups))
                     (ibuffer-update nil t))))))))
     #+END_SRC

*** imenu
    see (and jump to) key points of interest in the current buffer using your completion framework
    of choice.

    #+BEGIN_SRC emacs-lisp
      (use-package imenu
        :defer t
        :commands (imenu-list
                   imenu-anywhere)
        :init
        (leader/set-keys
          "ji" 'imenu
          "jI" 'imenu-anywhere
          "bi" 'imenu-list)

        :config
        (use-package imenu-list
          :ensure t
          :defer  t
          :config
          (evil-set-initial-state 'imenu-list-major-mode 'motion)

          (general-define-key
            :states 'motion
            :keymaps 'imenu-list-major-mode-map
            "gr" 'imenu-list-refresh
            "o" 'imenu-list-display-entry))

        (use-package imenu-anywhere
          :ensure t
          :defer  t))
    #+END_SRC

*** flyspell
    on the fly spell checker. spawns an aspell subprocess and passes any words you write
    to it; any mispellings or unknown words will be highlighted to indicate they're mispelled.

    #+BEGIN_SRC emacs-lisp
      (use-package flyspell
        :init
        (evil-ex-define-cmd "spell" #'flyspell-buffer)

        :config
        ;; I've only tested this on window/cygwin but aspell appears to be quite broken :P
        ;;   * I can't specify a path to any directory not within my home directory.
        ;;   * I can't specify any absolute path, even when that path is within my home directory.
        ;;   * If I want to reference a file in a subdirectory of my home directory, the path must begin with a
        ;;     slash.
        ;; THIS IS WAY TOO UNINTUITIVE.
        (setq ispell-personal-dictionary
              (file-relative-name (etc! "/ispell/dict.txt") "~"))

        (leader/with-prefix mohkale-minor-mode-leader-key
          (leader/set-keys-for-mode 'flyspell-mode
            "."  'hydra-flyspell/body
            "cb" 'flyspell-buffer
            "cr" 'flyspell-region
            "cw" 'flyspell-word))

        (use-package flyspell-correct-ivy
          :ensure t
          :defer  t
          :init
          ;; NOTE wrapper works backwards through the buffer by default.
          ;;      pass a two prefix args to check forward.
          (setq flyspell-correct-interface #'flyspell-correct-ivy)

          (leader/with-prefix mohkale-minor-mode-leader-key
            (leader/set-keys-for-mode 'flyspell-mode
              mohkale-minor-mode-leader-key 'flyspell-correct-wrapper))))
    #+END_SRC

**** ispell
    #+BEGIN_SRC emacs-lisp
      (use-package ispell
        :defer t
        :config
        (defun ispell--prevent-absolute-path (func &rest args)
          (cl-letf (((symbol-function 'expand-file-name)
                     (lambda (_) _)))
            (apply func args)))

        (advice-add 'ispell-internal-change-dictionary :around
                    #'ispell--prevent-absolute-path)
        (advice-add 'flyspell-large-region :around
                    #'ispell--prevent-absolute-path))
    #+END_SRC

*** ein - emacs-ipython-notebook
    org mode is 100% better... prove me wrong :P

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package ein
        :ensure t
        :defer  t
        :init
        (with-eval-after-load 'org
          (push '(ein . t) org-babel-load-languages))

        :config
        (defun evil-write--ein-save-buffer (&rest args)
          (when (derived-mode-p 'ein:notebook-mode 'ein:notebook-multilang-mode)
            (call-interactively 'ein:notebook-save-notebook-command)
            t))

        (advice-add 'evil-write :before-until #'evil-write--ein-save-buffer)

        (leader/set-keys-for-major-mode 'ein:notebooklist-mode
          "f" 'ein:file-open
          "n" 'ein:notebook-open
          "r" 'ein:notebooklist-reload)

        (general-define-key
          :keymaps 'ein:notebooklist-mode-map
          "gr" 'ein:notebooklist-reload
          "<S-tab>"   'widget-backward
          "<backtab>" 'widget-backward
          "TAB"       'widget-forward
          "<tab>"     'widget-forward

          "gn" 'ein:notebooklist-next-item
          "gN" 'ein:notebooklist-prev-item
          "gp" 'ein:notebooklist-prev-item)

        (dolist (mode '(ein:notebook-mode ein:notebook-multilang-mode))
          (leader/set-keys-for-major-mode mode
            "." 'hydra-ein/body
            "'" 'ein:edit-cell-contents
            leader-major-mode-key 'ein:worksheet-execute-cell

            "c" 'ein:notebook-close
            "f" 'ein:file-open
            "F" 'ein:notebook-open
            "i" 'ein:inspect-object
            "m" 'ein:pytools-request-tooltip-or-help
            "o" 'ein:worksheet-toggle-output
            "p" 'ein:worksheet-yank-cell
            "r" 'ein:notebook-rename-command
            "R" 'ein:notebook-restart-session-command
            ;; "R" 'ein:notebook-reconnect-session-command
            "s" 'ein:notebook-scratchsheet-open
            "w" 'ein:notebook-save-notebook-command
            "y" 'ein:worksheet-copy-cell

            "ts" 'ein:worksheet-toggle-slide-type
            "tc" 'ein:worksheet-toggle-cell-type
            "tC" 'ein:worksheet-change-cell-type
            "gg" 'ein:pytools-jump-to-source-command
            "gb" 'ein:pytools-jump-back-command
            "dc" 'ein:worksheet-kill-cell
            "do" 'ein:worksheet-clear-output
            "dO" 'ein:worksheet-clear-all-output
            "dk" 'ein:notebook-kill-kernel-then-close-command
            "dz" 'ein:notebook-kernel-interrupt-command

            "TAB" 'ein:completer-complete))

        (general-define-key
          :keymaps 'ein:notebook-mode-map
          "<C-down>" nil
          "<C-up>"   nil

          "<C-return>" 'ein:worksheet-execute-cell
          "<S-return>" 'ein:worksheet-execute-cell-and-goto-next)

        (general-define-key
          :keymaps 'ein:notebook-mode-map
          :states  leader-norm-states
          "go" 'ein:worksheet-insert-cell-above
          "gO" 'ein:worksheet-insert-cell-below
          "gJ" 'ein:worksheet-merge-cell
          ;; "gs" 'ein:worksheet-split-cell-at-point
          "gj" 'ein:worksheet-goto-next-input
          "gk" 'ein:worksheet-goto-prev-input
          "gc" 'ein:worksheet-kill-cell)

        (general-define-key
          :keymaps 'ein:notebook-multilang-mode-map
          "<M-down>" 'ein:worksheet-move-cell-down
          "<M-up>"   'ein:worksheet-move-cell-up))
    #+END_SRC

*** lorem-ipsum
    insert placeholder text in the lorem-ipsum-dolor format.

    #+BEGIN_SRC emacs-lisp
      (use-package lorem-ipsum
        :ensure nil
        :defer  t
        :commands (Lorem-ipsum-insert-list
                   Lorem-ipsum-insert-paragraphs
                   Lorem-ipsum-insert-sentences)
        :init
        (leader/set-keys
          "il"  "lorem-ipsum"
          "ill" 'Lorem-ipsum-insert-list
          "ilp" 'Lorem-ipsum-insert-paragraphs
          "ils" 'Lorem-ipsum-insert-sentences))
    #+END_SRC

*** language-server
**** lsp-mode
     #+BEGIN_SRC emacs-lisp
       (use-package lsp-mode
         :ensure t
         :defer  t
         ;; never use lsp-mode, use lsp.
         :config
         (setq lsp-prefer-flymake             nil
               lsp-enable-snippet             nil
               lsp-enable-symbol-highlighting nil
               mohkale-lsp-map (make-sparse-keymap)
               lsp-session-file (var! "lsp/session")
               lsp-server-install-dir (var! "lsp/servers"))

         (leader/with-prefix mohkale--server-leader-key
           (leader/set-keys-for-mode 'lsp-mode
             "" "server"

             "?"   'lsp-describe-session
             "|"   'lsp-describe-thing-at-point
             "e"   'lsp-execute-code-action
             "h"   'lsp-document-highlight
             "DEL" 'lsp-disconnect

             "w"  "workspace"
             "wR" 'lsp-restart-workspace
             "wa" 'lsp-workspace-folders-add
             "wr" 'lsp-workspace-folders-remove
             "ws" 'lsp-workspace-folders-switch

             "l"  "lens"
             "ll" 'lsp-lens-mode
             "ls" 'lsp-lens-show
             "lh" 'lsp-lens-hide

             "r"  "refactor"
             "rr" 'lsp-format-buffer
             "ri" 'lsp-organize-imports
             "rc" 'lsp-rename

             "g"  "goto"
             "gg" 'lsp-goto-type-definition
             "gG" 'lsp-goto-implementation
             "gF" 'lsp-find-implementation
             "gf" 'lsp-find-type-definition)))
     #+END_SRC

***** lsp-ui
      UI enhancements for lsp sessions... tries to make emacs more like VS Code. Boooooo!!!

      #+BEGIN_SRC emacs-lisp
        (with-eval-after-load 'lsp-mode
          (use-package lsp-ui
            :ensure t
            :defer  t
            ;; :hook (lsp-mode-hook . lsp-ui-mode)
            :commands (lsp-ui-mode)
            :config
            ;; only really installed for flycheck support
            (setq lsp-ui-sideline-enable nil
                  lsp-ui-doc-enable nil)

            (leader/with-prefix mohkale--server-leader-key
              (leader/set-keys-for-mode 'lsp-mode
                "p" "peek"
                "pg" 'lsp-ui-peek-find-definitions
                "pG" 'lsp-ui-peek-find-definitions))))
      #+END_SRC

***** company-lsp
      use lsp as a completion backend for company.

      #+BEGIN_SRC emacs-lisp
        (with-eval-after-load 'lsp-mode
          (use-package company-lsp
            :ensure t
            :defer  t
            :commands company-lsp
            :config
            ;; reduces write lag
            (setq company-lsp-cache-candidates t)

            (company/configure-mode (lsp-mode)
              company-lsp)))
      #+END_SRC

**** eglot
     seems cool, but the lack of good documentation and support for flycheck is off putting.
     Also doesn't seem to highlight errors using eldoc when possible, which is a feature I
     quite like from lsp-mode. Give it some time, check back again.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package eglot
         :ensure t
         :defer  t
         :init
         (defalias 'eglot-rename-symbol 'eglot-rename)
         :config
         (setq eglot-ignored-server-capabilites
               '(:documentHighlightProvider))

         ;; ;; add flycheck support: https://github.com/joaotavora/eglot/issues/195
         ;; (defvar-local eglot-flycheck--fc-callback nil)

         ;; (defun eglot-flycheck--point->line-col (buffer beg)
         ;;   (with-current-buffer buffer
         ;;     (save-excursion
         ;;       (goto-char beg)
         ;;       (cons (line-number-at-pos)
         ;;             (- (point)
         ;;                (line-beginning-position))))))

         ;; (defun eglot-flycheck--fm-error->fc-error (err)
         ;;   (pcase-let* ((msg (flymake--diag-text err))
         ;;                (beg (flymake--diag-beg err))
         ;;                (buffer (flymake--diag-buffer err))
         ;;                (`(,line . ,col) (eglot-flycheck--point->line-col buffer beg)))
         ;;     (flycheck-error-new-at
         ;;      line nil ;; TODO: use column and region
         ;;      (pcase (flymake--diag-type err)
         ;;        (':error 'error)
         ;;        (':warning 'warning)
         ;;        (':note 'info))
         ;;      msg
         ;;      :id "eglot-flycheck"
         ;;      ;; :checker
         ;;      :buffer buffer
         ;;      :filename (buffer-file-name buffer))))

         ;; (cl-defun eglot-flycheck--flymake-handle-result (flymake-errors &key region)
         ;;   (funcall eglot-flycheck--fc-callback
         ;;            'finished
         ;;            (mapcar #'eglot-flycheck--fm-error->fc-error flymake-errors)))

         ;; (cl-defun eglot-flycheck-checker (checker callback)
         ;;   (setq eglot-flycheck--fc-callback callback)
         ;;   (eglot-flymake-backend #'eglot-flycheck--flymake-handle-result))

         ;; (flycheck-define-generic-checker
         ;;  'eglot-checker
         ;;  "eglot flycheck checker"
         ;;  :start #'eglot-flycheck-checker
         ;;  :modes (eglot--all-major-modes))
         )
     #+END_SRC

*** macro/kmacro/edmacro
    #+BEGIN_SRC emacs-lisp
      (leader/set-keys
        "k"  "macros/lisp")

      (use-package kmacro
        :init
        (leader/with-prefix "k"
          (leader/set-keys
            ;; 'edit-kbd-macro ;; any named macro
            ;; 'apply-macro-to-region-lines
            "s" 'name-last-kbd-macro
            "i" 'insert-kbd-macro
            "q" 'kbd-macro-query ;; prompt at macro point

            "c"  "counter"
            "cs" 'kmacro-set-counter
            "c=" 'kmacro-set-counter
            "cc" 'kmacro-insert-counter
            "ci" 'kmacro-insert-counter
            "ca" 'kmacro-add-counter
            "c+" 'kmacro-add-counter
            "cf" 'kmacro-set-format)))

      (use-package edmacro
        :defer t
        :commands (edmacro-mode)
        :config
        (leader/with-prefix "k"
          (leader/set-keys
            ;; 'kmacro-edit-lossage ;; edit last 300 strokes as macro
            ;; 'kmacro-step-edit-macro ;; debug last macro
            "SPC" 'kmacro-edit-macro ;; last defined
            "b"   'kmacro-bind-to-key))

        :config
        (leader/set-keys-for-major-mode 'edmacro-mode
          "," 'edmacro-finish-edit
          "i" 'edmacro-insert-key))
    #+END_SRC

*** minibuffer
    #+BEGIN_SRC emacs-lisp
      (general-define-key
        :keymaps 'minibuffer-local-map
        "M-j" 'next-history-element
        "M-k" 'previous-history-element
        "C-j" 'previous-matching-history-element
        "C-k" 'next-matching-history-element
        "C-h" 'backward-char
        "C-l" (defun minibuffer-forward-char-or-exit ()
                (interactive)
                (call-interactively (if (eolp)
                                        'exit-minibuffer
                                      'forward-char)))

        "C-a" 'move-beginning-of-line
        "C-e" 'move-end-of-line
        "C-v" 'quoted-insert
        "C-M-q" 'quit-window
        "M-DEL" 'kill-whole-line

        ;; "M-n" nil
        ;; "M-p" nil
        ;; "M-r" nil
        "C-w" 'backward-kill-word
        "C-?" 'minibuffer-completion-help
        ;; for some reason.. I can't bind Meta keys
        "M-h" 'backward-kill-sentence
        "M-l" 'kill-sentence)

      (general-define-key
        :keymaps 'minibuffer-local-must-match-map
        "TAB" 'minibuffer-complete
        "<C-tab>" 'minibuffer-complete-and-exit
        "C-j" nil)

      (general-define-key
        :keymaps '(minibuffer-local-map
                   minibuffer-local-must-match-map
                   minibuffer-inactive-mode-map
                   minibuffer-local-ns-map
                   minibuffer-local-completion-map)
         "<escape>" 'abort-recursive-edit)
    #+END_SRC

    Some more sage advice from the demigods at [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][doom]].

    #+BEGIN_SRC emacs-lisp
      (defun defer-garbage-collection+ ()
        (setq gc-cons-threshold most-positive-fixnum))

      (defun restore-garbage-collection+ ()
        ;; Deferred so that commands launched immediately after will enjoy the
        ;; benefits.
        (run-at-time
         1 nil (lambda () (setq gc-cons-threshold default-gc-cons-threshold))))

      (add-hook 'minibuffer-setup-hook #'defer-garbage-collection+)
      (add-hook 'minibuffer-exit-hook #'restore-garbage-collection+)
    #+END_SRC

*** miniedit
    write the minibuffer contents to a buffer. edit, then paste new contents back to minibuffer.

    #+BEGIN_SRC emacs-lisp
      (use-package miniedit
        :defer t
        :delight (miniedit-mode "MiniEdit")
        :commands (miniedit
                   miniedit-install
                   miniedit-install-for-xemacs
                   miniedit-introduction
                   miniedit-quick-start)
        :init
        (general-define-key
          :keymaps '(minibuffer-local-map
                     minibuffer-local-ns-map
                     minibuffer-local-completion-map
                     minibuffer-local-must-match-map)
          "C-M-<return>" 'miniedit)

        ;; ;; can't seem to change major mode without miniedit mode
        ;; ;; being removed :(
        ;; (add-hook 'miniedit-mode-hook initial-major-mode)
        :config
        (setq miniedit-show-help-p nil) ;; thanks... but no thanks

        (leader/with-prefix leader-major-mode-prefix
          (leader/set-keys-for-mode 'miniedit-mode
            "," 'exit-recursive-edit)))
    #+END_SRC

*** occur
    see all occurences of a search query in the current buffer, with support to jumping
    to the next or previous query and even editing them on the fly.

    #+BEGIN_SRC emacs-lisp
      (use-package replace
        :straight (replace :type built-in)
        :defer t
        :config
        ;; occur-mode-display-occurrence
        (advice-add 'occur-mode-display-occurrence :around
                    #'restore-default-display-buffer-actions)

        (leader/set-keys-for-major-mode '(occur-mode occur-edit-mode)
          "e" 'occur-edit-mode
          "R" 'occur-rename-buffer
          "g" 'occur-mode-goto-occurrence
          "G" 'occur-mode-goto-occurrence-other-window
          "l" 'occur-mode-display-occurrence)

        (leader/set-keys-for-major-mode 'occur-edit-mode
          "," 'occur-cease-edit)

        (defun evil-adjust-occur-next ()
          (interactive)
          (with-evil-adjust-to-eol
            (funcall-interactively 'occur-next)))

        (defun evil-adjust-occur-prev ()
          (interactive)
          (with-evil-adjust-to-eol
            (funcall-interactively 'occur-prev)))

        (evil-set-initial-state 'occur-mode 'motion)
        (general-define-key
          :keymaps 'occur-mode-map
          :states  'motion
          ;; occur-mode-mouse-goto
          "RET" 'occur-mode-goto-occurrence
          "o" 'occur-mode-goto-occurrence-other-window
          "s" 'occur-mode-display-occurrence

          "j"  'evil-adjust-occur-next
          "k"  'evil-adjust-occur-prev
          "gj" 'evil-next-line
          "gk" 'evil-previous-line

          "R" 'occur-rename-buffer
          "q" nil)

        (evil-set-initial-state 'occur-edit-mode 'normal)
        (general-define-key
          :states  'normal
          :keymaps 'occur-edit-mode-map
          ;; occur-mode-mouse-goto
          "RET" 'occur-mode-goto-occurrence
          "go"  'occur-mode-goto-occurrence-other-window
          "gO"  'occur-mode-display-occurrence
          "j"   'evil-adjust-occur-next
          "k"   'evil-adjust-occur-prev
          [remap quit-window] 'occur-cease-edit))
    #+END_SRC

*** open-junk-file
    create temporary files labelled with todays date and other information.

    #+BEGIN_SRC emacs-lisp
      (use-package open-junk-file
        :defer t
        :commands (open-junk-file
                   goto-junk-file-directory
                   goto-todays-junk-file-directory)
        :init
        (leader/set-keys
          "fJ" 'open-junk-file)

        :config
        (setq open-junk-file-format (var! "junk-files/%Y/%m/%d-%H%M%S"))

        (defun goto-junk-file-directory ()
          (interactive)
          (let ((directory junk-file-directory))
            (if (f-directory-p directory)
                (find-file directory)
              (if (file-exists-p directory)
                  (message "junk directory appears to be created as a file: %s" directory)
                (when (y-or-n-p (format "junk file directory '%s' doesn't seem to exist. make it: "
                                        directory))
                  (make-directory (expand-file-name directory) t)
                  (find-file directory))))))

        (defun goto-todays-junk-file-directory ()
          (interactive)
          (let* ((filename  (format-time-string open-junk-file-format))
                 (directory (file-name-directory filename)))
            (if (f-directory-p directory)
                (find-file directory)
              (if (file-exists-p directory)
                  (message "junk file directory appears to be created as a file: %s" directory)
                (when (y-or-n-p (format "junk file directory '%s' doesn't seem to exist. make it: "
                                        directory))
                  (make-directory (expand-file-name directory) t)
                  (find-file directory))))))

        (defun open-junk-file--fix-read-file-name-with-directory-wrapper (func &rest args)
          "ivy read-file-name doesn't seem to handle initial values with directory components
      very well. this wrapper function strips out the directory component of the default
      junk file name and passes it as the dir argument to read-file-name."

          (cl-letf* (((symbol-function 'actual-read-file-name)
                      (symbol-function 'read-file-name))
                     ((symbol-function 'read-file-name)
                      (lambda (prompt &optional dir default-file-name mustmatch initial predicate)
                        (let ((dirname  (file-name-directory    initial))
                              (basename (file-name-nondirectory initial)))
                          ;; for some reason, this doesn't work unless I set default-filename and initial
                          ;; to basename, and even when I do so, the full path still appears an option :(
                          (actual-read-file-name prompt dirname basename mustmatch basename predicate)))))
            (apply func args)))

        (advice-add 'open-junk-file :around #'open-junk-file--fix-read-file-name-with-directory-wrapper))
    #+END_SRC

*** olivetti
    A nice writing environment for emacs :)

    #+BEGIN_SRC emacs-lisp
      (use-package olivetti
        :ensure t
        :defer  t
        :commands olivetti-setup-buffer
        :hook (olivetti-mode . olivetti-setup-buffer)
        :init
        (leader/set-keys
          "M'" 'olivetti-mode)

        (defvar olivetti-hide-fringe+ nil
          "when true, olivetti mode will hide the window fringe.")

        (general-define-key
          :keymaps 'olivetti-mode-map
          "C-c >" #'olivetti-expand
          "C-c <" #'olivetti-shrink)

        :config
        (add-hook 'olivetti-mode-hook
                  (defun olivetti-setup-buffer ()
                    "hide line numbers and the fringe."
                    (display-line-numbers-mode
                     (if olivetti-mode -1 +1))

                    (eval
                     `(set-window-fringes
                       (selected-window)
                       ,@(if (and olivetti-mode
                                  olivetti-hide-fringe+)
                             '(0 0)
                           '(8 8))))))

        (leader/set-keys
          (concat mohkale-minor-mode-leader-key "-") 'olivetti-set-width))
    #+END_SRC

*** outline-mode
    #+BEGIN_SRC emacs-lisp
      (use-package outline
        :straight (outline :type built-in)
        :defer t
        :config
        (advice-add 'outline-up-heading :around
                    (defun outline-up-heading--goto-current-first+ (func arg &optional invisible-ok)
                      "make `outline-up-heading' goto the current heading first
      unless already there."
                      (unless (outline-on-heading-p invisible-ok)
                        (outline-backward-same-level 0)
                        (when arg
                          (setq arg (if (> arg 0) (- arg 1) (+ arg 1)))))

                      (when arg
                        (apply func arg invisible-ok))))

        (defun outline-folded-p+ (&optional pos)
          (save-excursion
            (goto-char (line-end-position))
            (outline-invisible-p)))

        (defun outline-toggle-show-children+ ()
          (interactive)
          (if (outline-folded-p+)
              (outline-show-subtree)
            (outline-hide-subtree)))

        (general-define-key
          :states  'motion
          :keymaps 'outline-mode-map
          "gh" 'outline-up-heading
          "gj" 'outline-next-heading
          "gk" 'outline-previous-heading
          "gl" 'outline-forward-same-level)

        (general-define-key
          :states  'motion
          :keymaps 'outline-mode-map
          :predicate '(outline-on-heading-p)
          [remap evil-shift-right] 'outline-demote
          [remap evil-shift-left]  'outline-promote
          [remap drag-stuff-down]  'outline-move-subtree-down
          [remap drag-stuff-up]    'outline-move-subtree-up
          "TAB"   'outline-toggle-show-children+
          "<tab>" 'outline-toggle-show-children+)

        (leader/set-keys-for-major-mode 'outline-mode
          "m" 'outline-mark-subtree
          "t" 'outline-hide-body ;; show subtree
          "a" 'outline-show-all
          ;; only show outline upto this level.
          "h" 'outline-hide-sublevels
          "l" 'outline-show-branches
          "f" 'outline-hide-other ;; focus
          ;; show remainder of branches in current hidden branch.
          "q" 'outline-show-branches
          "RET" 'outline-insert-heading))
    #+END_SRC

*** package
    #+BEGIN_SRC emacs-lisp
      (use-package package
        :defer t
        :config
        (evil-set-initial-state 'package-menu-mode 'motion)

        (general-define-key
          :keymaps 'package-menu-mode-map
          :states  'motion
          "TAB" 'forward-button
          "<backtab>" 'backward-button
          "RET" 'package-menu-describe-package
          "DEL" 'package-menu-backup-unmark
          "("   'package-menu-toggle-hiding
          "S"   'tabulated-list-sort
          "U"   'package-menu-mark-upgrades
          "d"   'package-menu-mark-delete
          "i"   'package-menu-mark-install
          "u"   'package-menu-mark-unmark
          "x"   'package-menu-execute
          "q"   nil
          "~"   'package-menu-mark-obsolete-for-deletion
          "gr"  'package-menu-refresh)

        (leader/set-keys-for-major-mode 'package-menu-mode
          "h" 'package-menu-hide-package
          "?" 'package-menu-quick-help
          "/" 'package-menu-filter

          "m"  "mark"
          "m~" 'package-menu-mark-obsolete-for-deletion
          "mu" 'package-menu-mark-unmark
          "mi" 'package-menu-mark-install
          "mu" 'package-menu-mark-upgrades
          "md" 'package-menu-mark-delete))
    #+END_SRC

*** page-break-lines
    display ^L lines as horizontal-rules. Like so:



    #+BEGIN_SRC emacs-lisp
      (use-package page-break-lines
        :defer t
        :hook ((org-mode     . page-break-lines-mode)
               (help-mode    . page-break-lines-mode)
               (outline-mode . page-break-lines-mode))
        :diminish
        page-break-lines-mode)
    #+END_SRC

*** paren
    when your point is on a parenthesis, highlight the matching one.

    # TODO look into smart-parens-mode

    #+BEGIN_SRC emacs-lisp
      (use-package paren
        :hook ((prog-mode . show-paren-mode)
               (text-mode . show-paren-mode))
        :init (setq sp-highlight-pair-overlay nil))
    #+END_SRC

*** pcre2el
    convert from emacs regular expressions to perl like regexps and vice versa.

    #+BEGIN_SRC emacs-lisp
      (use-package pcre2el
        :ensure t
        :defer  t
        :init
        (leader/set-keys
          "xr"   "regexp"
          "xrb"  'regexp-builder
          "xr'"  'rxt-convert-to-strings
          "xr/"  'rxt-explain
          "xrc"  'rxt-convert-syntax
          "xrt"  'rxt-toggle-elisp-rx
          "xrx"  'rxt-convert-to-rx

          "xre"  "elisp"
          "xre'" 'rxt-elisp-to-strings
          "xre/" 'rxt-explain-elisp
          "xrep" 'rxt-elisp-to-pcre
          "xret" 'rxt-toggle-elisp-rx
          "xrex" 'rxt-elisp-to-rx

          "xrp"  "PCRE"
          "xrp'" 'rxt-pcre-to-strings
          "xrp/" 'rxt-explain-pcre
          "xrpe" 'rxt-pcre-to-elisp
          "xrpx" 'rxt-pcre-to-rx))
    #+END_SRC

*** pdf-tools
    Use emacs as a quick and dirty pdf viewer.

    #+BEGIN_SRC emacs-lisp
      (use-package pdf-tools
        :ensure t
        :defer  t
        :mode ("\\.pdf$" . pdf-view-mode)
        :hook (pdf-view-mode . hide-mode-line-mode)
        :config
        (setq-default pdf-view-display-size 'fit-page)

        ;; only accepts absolute paths and doesn't automatically append ".exe" when on windows.
        (let ((epdfinfo-program (expand-file-name (var! "pdf-tools/epdfinfo"))))
          (when (windows-p)
            (setq epdfinfo-program (concat epdfinfo-program ".exe")))
          (setq pdf-info-epdfinfo-program epdfinfo-program))

        (evil-set-initial-state 'pdf-view-mode 'motion)

        ;; (pdf-tools-install)

        (general-define-key
          :keymaps 'pdf-view-mode-map
          :states 'motion
          "RET" 'image-next-line
          "o" 'pdf-outline
          ;; TODO make interactive ivy-based outline

          "j" 'pdf-view-next-line-or-next-page-with-prefix
          "k" 'pdf-view-prev-line-or-prev-page-with-prefix
          "gj" 'image-next-line
          "gk" 'image-previous-line

          "h" 'pdf-view-previous-page-command
          "l" 'pdf-view-next-page-command
          "C-j" 'pdf-view-next-page-command
          "C-k" 'pdf-view-previous-page-command
          "]]" 'pdf-view-next-page-command
          "[[" 'pdf-view-previous-page-command

          "gg" 'pdf-view-goto-first-page-with-prefix
          "G"  'pdf-view-goto-page-with-prefix
          "gh" 'beginning-of-buffer
          "gl" 'end-of-buffer
          "H" 'beginning-of-buffer
          "L" 'end-of-buffer

          "=" 'pdf-view-scale-reset
          "+" 'pdf-view-enlarge
          "-" 'pdf-view-shrink

          "C-d" 'pdf-view-scroll-up-or-next-page
          "C-u" 'pdf-view-scroll-down-or-previous-page
          "m" 'pdf-view-position-to-register
          "'" 'pdf-view-jump-to-register
          "`" 'pdf-view-jump-to-register

          "q" nil
          "Q" 'kill-this-buffer
          "ZQ" 'kill-this-buffer
          "ZZ" 'quit-window)

        (general-define-key
          :keymaps 'pdf-view-mode-map
          :states 'visual
          "y" 'pdf-view-kill-ring-save)

        (leader/set-keys-for-major-mode 'pdf-view-mode
          ;; "-" 'pdf-view-fit-height-to-window
          ;; "|" 'pdf-view-fit-width-to-window
          ;; "|" 'pdf-view-fit-page-to-window
          "g" 'pdf-view-goto-label
          "o" 'pdf-occur
          "RET" 'pdf-outline

          "M TAB" 'doc-view-mode
          "Md" 'pdf-view-dark-minor-mode
          "Mm" 'pdf-view-midnight-minor-mode
          "Mp" 'pdf-view-printer-minor-mode

          "zm" 'pdf-view-set-slice-using-mouse
          "zz" 'pdf-view-set-slice-from-bounding-box
          "zr" 'pdf-view-reset-slice)

        (evil-set-initial-state 'pdf-outline-buffer-mode 'motion)

        (general-define-key
          :states  'motion
          :keymaps 'pdf-outline-buffer-mode-map
          "o" 'pdf-outline-display-link
          "sa" 'show-all
          "ss" 'show-subtree
          "sh" 'hide-subtree
          "sn" 'hide-subtree
          "gh" 'pdf-outline-up-heading
          "gk" 'outline-backward-same-level
          "gj" 'outline-forward-same-level
          "gl" 'outline-next-heading
          "gd" 'outline-hide-entry
          "g SPC" 'pdf-outline-select-pdf-window

          "<C-return>" 'pdf-outline-follow-link
          "M-RET" 'pdf-outline-display-link
          "RET" 'pdf-outline-follow-link-and-quit
          ;; goto current page in the outline window
          "gp" 'pdf-outline-move-to-current-page

          "<C-tab>" 'hide-sublevels
          "<C-up>" 'outline-move-subtree-up
          "<C-down>" 'outline-move-subtree-down)

        (leader/set-keys-for-major-mode 'pdf-outline-buffer-mode
          "f" 'pdf-outline-follow-mode
          "m" 'outline-mark-subtree)

        (evil-set-initial-state 'pdf-occur-buffer-mode 'motion)

        (defvar pdf-occur-buffer-mode-map (make-sparse-keymap))
        (general-define-key
          :states  'motion
          :keymaps 'pdf-occur-buffer-mode-map
          ;; unbound: tablist-export-csv
          "RET" 'pdf-occur-goto-occurrence
          "s" 'pdf-occur-view-occurrence
          "o" 'pdf-occur-view-occurrence
          "d" 'tablist-do-kill-lines
          "x" 'pdf-occur-tablist-do-flagged-delete
          "<backtab>" 'tablist-backward-column
          "DEL" 'tablist-unmark-backward

          [remap evil-first-non-blank] 'tablist-move-to-major-column
          [remap evil-next-line] 'tablist-next-line
          [remap evil-previous-line] 'tablist-previous-line

          "gr" 'pdf-occur-revert-buffer-with-args

          "A" 'pdf-occur-tablist-gather-documents
          "D" 'pdf-occur-tablist-do-delete

          "S" 'tabulated-list-sort
          "gS" 'tablist-revert

          "m" 'tablist-mark-forward
          "~" 'tablist-toggle-marks
          "u" 'tablist-unmark-forward
          "U" 'tablist-unmark-all-marks
          "*m" 'tablist-mark-forward
          "*!" 'tablist-unmark-all-marks
          "*c" 'tablist-change-marks
          "*n" 'tablist-mark-items-numeric
          "*r" 'tablist-mark-items-regexp
          "*%" 'tablist-mark-items-regexp

          "a" 'tablist-flag-forward

          [remap quit-window]  'tablist-quit
          "ZQ" 'tablist-quit
          "ZZ" 'tablist-quit)

        (leader/set-keys-for-major-mode 'pdf-occur-buffer-mode-map
          "/!" 'tablist-negate-filter
          "//" 'tablist-display-filter
          "/=" 'tablist-push-equal-filter
          "/C" 'tablist-clear-filter
          "/D" 'tablist-delete-named-filter
          "/a" 'tablist-push-named-filter
          "/d" 'tablist-deconstruct-named-filter
          "/e" 'tablist-edit-filter
          "/n" 'tablist-push-numeric-filter
          "/p" 'tablist-pop-filter
          "/r" 'tablist-push-regexp-filter
          "/s" 'tablist-name-current-filter
          "/t" 'tablist-toggle-first-filter-logic
          "/z" 'tablist-suspend-filter)

        ;; functions ripped from evil-collection
        (defun pdf-view-next-line-or-next-page-with-prefix (&optional count)
          "'evil' wrapper include a count argument to `pdf-view-next-line-or-next-page'"
          (interactive "p")
          (if count
              (dotimes (_ count nil)
                      (pdf-view-next-line-or-next-page 1))
            (pdf-view-next-line-or-next-page 1)))

        (defun pdf-view-prev-line-or-prev-page-with-prefix (&optional count)
          "'evil' wrapper include a count argument to `pdf-view-previous-line-or-previous-page'"
          (interactive "p")
          (if count
              (dotimes (_ count nil)
                      (pdf-view-previous-line-or-previous-page 1))
            (pdf-view-previous-line-or-previous-page 1)))

        (defun pdf-view-goto-page-with-prefix (&optional page)
          "`evil' wrapper around `pdf-view-last-page'."
          (interactive "P")
          (if page
              (pdf-view-goto-page page)
            (pdf-view-last-page)
            (image-eob)))

        (defun pdf-view-goto-first-page-with-prefix (&optional page)
          "`evil' wrapper around `pdf-view-first-page'."
          (interactive "P")
          (if page
              (pdf-view-goto-page page)
            (pdf-view-first-page)
            (image-bob))))
    #+END_SRC

**** org-pdftools
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'org
         (use-package org-pdftools
           :defer t
           :straight (org-pdftools :type git :host github :repo "fuxialexander/org-pdftools")
           :init
           (org-link-set-parameters "pdftools"
                                    :follow   #'org-pdftools-open
                                    :complete #'org-pdftools-complete-link
                                    :store    #'org-pdftools-store-link
                                    :export   #'org-pdftools-export)

           ;; (setq org-pdftools-root-dir "~/multimedia/pdfs")
           (add-hook 'org-store-link-functions 'org-pdftools-store-link)))
     #+END_SRC

*** persp-mode
    the core backend for spacemacs's layout functionality.

    #+BEGIN_SRC emacs-lisp
      (use-package persp-mode
        :ensure t
        :defer  load-me-now-duration
        :diminish persp-mode

        ;; unbound functions:
        ;;    persp-kill-buffer
        ;;    persp-save-and-kill
        :commands (ivy-find-file-new-perspective
                   switch-to-persp-by-num
                   persp-switch
                   persp-kill-current
                   persp-add-current-buffer
                   persp-remove-current-buffer)

        :init
        (leader/set-keys
          "ba" 'persp-add-current-buffer
          "bA" 'persp-add-buffer
          "br" 'persp-remove-buffer
          "bR" 'persp-remove-current-buffer
          "fl" 'ivy-find-file-new-perspective)

        :config
        (require 'eyebrowse)

        (setq persp-autokill-buffer-on-remove 'kill-weak
              persp-save-dir (var! "perspectives/"))

        (persp-mode +1)

        (defun ivy-find-file-new-perspective--action (file)
          (let* ((name (if current-prefix-arg
                           (let (done value)
                             (while (not done)
                               (setq value (read-string "Name for new perspective: "))
                               (if (not (persp-with-name-exists-p value))
                                   (setq done t) ;; break loop, valid name encountered
                                 (unless (y-or-n-p (format "persp with name '%s' already exists. try again: "
                                                           value))
                                   (setq done t)) ;; user no longer wishes to create persp
                                 (setq value nil) ;; unbind in case value being returned
                                 ))
                             value)
                         (file-name-nondirectory (string-trim-right file "/")))))
            (when name
              (persp-add-new name)
              (persp-switch name)
              (let ((buffer (find-file file)))
                (switch-to-buffer buffer)
                (persp-add-buffer buffer)))))

        (defun ivy-find-file-new-perspective ()
          (interactive)
          (require 'counsel)
          (counsel--find-file-1
           "New Persp File: " nil
           #'ivy-find-file-new-perspective--action
           ;; 'ivy-find-file-new-perspective
           ;; with another value, dirs aren't colored
           'counsel-find-file))

        (defun switch-to-persp-by-num (index)
          "switch to a perspective based on it's position in (persp-persps)
      the first position is assumed to be associated with a perspective name `none'.
      if a perspective at the given index doesn't exist, it's assumed you wish to
      create a new one, so you'll be prompted to do so at the largest available index."
          (let* ((persp-list (nreverse (persp-persps)))
                 (persp-count (length persp-list)))
            ;; last value is nil persp with name none
            (if (>= index persp-count)
                (when (yes-or-no-p (format "no layout exists at %d, would you like to make a new layout:"
                                           (1+ persp-count)))
                  (call-interactively 'persp-add-new))
              (let ((current-persp (get-current-persp))
                    (dest-persp    (nth index persp-list)))
                (unless (string-equal (safe-persp-name dest-persp)
                                      (safe-persp-name current-persp))
                  (persp-switch (safe-persp-name dest-persp)))))))

        (defvar persp--copying-p nil
          "true if persp-add-new is called with intent to copy current persp")

        (defun persp-add-new--after (&rest args)
          "hook which is run immeadiately after `persp-add-new'
      this function sets the current persp to the new persp... unless
      `persp-add-new' wasn't invoked interactively. It also kills all
      displayed windows and returns to the home buffer... unless the
      previous persp is being copied."
          (let ((persp-list (nreverse (persp-persps)))
                (start-persp (get-current-persp)))
            (persp-switch (safe-persp-name (car (last persp-list))))

            (unless persp--copying-p
              (kill-all-windows-and-return-to-home))

            (unless (called-interactively-p)
              (persp-switch (safe-persp-name start-persp)))))

        (advice-add 'persp-add-new :after #'persp-add-new--after)
        (advice-add 'persp-copy :around (lambda (func &rest args)
                                          (let ((persp--copying-p t))
                                            (apply func args))))

        (defun mohkale//persp-kill-wrapper (func &rest args)
          "function which wraps around persp-kill
      this function will ensure after a perspective is killed, the next
      perspective you reach will be the one immeadiately before the erased
      one. Not really necessary, but when you try to delete 3 perspectives
      in a row, this'll make things easier. Besides, this is what you expect
      to happen."
          (let* ((perspectives (nreverse (persp-persps)))
                 (current-persp (get-current-persp))
                 (current-index (cl-position current-persp perspectives))
                 (next-persp (when (and current-index
                                        (not (zerop current-index)))
                               (nth (- current-index 1) perspectives))))
            (apply func args)
            (when next-persp
              (persp-switch (persp-name next-persp)))))

        (advice-add 'persp-kill :around #'mohkale//persp-kill-wrapper)

        (defun persp-kill-current ()
          "kill the current perspective"
          (interactive)
          (persp-kill (safe-persp-name (get-current-persp))))

        ;; (defun spacemacs//layout-contains-buffer-p (buffer)
        ;;   "returns true if the given buffer is in the current layout"
        ;;   (not (spacemacs//layout-not-contains-buffer-p buffer)))

        (defun persp-add-current-buffer ()
          "adds current buffer to current perspective"
          (interactive)
          (persp-add-buffer (current-buffer)))

        (defun persp-remove-current-buffer ()
          "removes current buffer from current persp"
          (interactive)
          (persp-remove-buffer (current-buffer)))

        (defun persp-move-layout-left ()
          (interactive)
          ;; (let* ((current-persp (get-current-persp))
          ;;        (current-persp-num (progn
          ;;                             (let (value)
          ;;                               (dolist (persp)))))
          ;;        ))
          (message "not yet implemented") ;; TODO implement
          )

        (defun persp-move-layout-right ()
          (interactive)
          (message "not yet implemented") ;; TODO implement
          )

        ;; thank you spacemacs for giving us perspective mode with eyebrowse... ergo, layouts :)
        ;; https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bspacemacs/spacemacs-layouts/funcs.el
        ;; the following is just a lazy translation of the spacemacs implementation from above for my config.
        ;; some vocabulary notes:
        ;;   * a workspace is a list of eyebrowse window configurations
        ;;   * a layout is a perspective-mode perspective which has an associated workspace.
        ;; for further elaborations on what those terms mean, see the README for perspective-mode and eyebrowse.

        ;; XXXX TBH I don't really understand what most of this does, a lot of it I just copied and pasted from
        ;;      spacemacs and changed spacemacs to layouts... if spacemacs ever realeases this as a standalone
        ;;      package, like they did with spaceline, make sure to switch to that. In the meantime, the following
        ;;      uses the same license as spacemacs... I.E. GPL v3
        ;;      Reference Commit: b252d252b0e93249b51400f60a0c69a59aa140a4

        (defun layouts//get-persp-workspace (&optional persp frame)
          "Get the correct workspace parameters for perspective.
      PERSP is the perspective, and defaults to the current perspective.
      FRAME is the frame where the parameters are expected to be used, and
      defaults to the current frame."
          (let ((param-names (if (display-graphic-p frame)
                                 '(gui-eyebrowse-window-configs
                                   gui-eyebrowse-current-slot
                                   gui-eyebrowse-last-slot)
                               '(term-eyebrowse-window-configs
                                 term-eyebrowse-current-slot
                                 term-eyebrowse-last-slot))))
            (--map (persp-parameter it persp) param-names)))

        (defun layouts//set-persp-workspace (workspace-params &optional persp frame)
          "Set workspace parameters for perspective.
      WORKSPACE-PARAMS should be a list containing 3 elements in this order:
      - window-configs, as returned by (eyebrowse--get 'window-configs)
      - current-slot, as returned by (eyebrowse--get 'current-slot)
      - last-slot, as returned by (eyebrowse--get 'last-slot)
      PERSP is the perspective, and defaults to the current perspective.
      FRAME is the frame where the parameters came from, and defaults to the
      current frame.
      Each perspective has two sets of workspace parameters: one set for
      graphical frames, and one set for terminal frames."
          (let ((param-names (if (display-graphic-p frame)
                                 '(gui-eyebrowse-window-configs
                                   gui-eyebrowse-current-slot
                                   gui-eyebrowse-last-slot)
                               '(term-eyebrowse-window-configs
                                 term-eyebrowse-current-slot
                                 term-eyebrowse-last-slot))))
            (--zip-with (set-persp-parameter it other persp)
                        param-names workspace-params)))

        ;;  _                 _
        ;; | |__   ___   ___ | | _____
        ;; | '_ \ / _ \ / _ \| |/ / __|
        ;; | | | | (_) | (_) |   <\__ \
        ;; |_| |_|\___/ \___/|_|\_\___/
        ;;

        ;; spacemacs/save-eyebrowse-for-perspective
        (defun layouts//save-eyebrowse-for-perspective (&optional frame)
          "save FRAME's eyebrowse workspace to FRAME's perspective.
      FRAME defaults to the current frame."
          (layouts//set-persp-workspace (list (eyebrowse--get 'window-configs frame)
                                              (eyebrowse--get 'current-slot frame)
                                              (eyebrowse--get 'last-slot frame))
                                        (get-frame-persp frame)
                                        frame))

        (add-hook 'eyebrowse-post-window-switch-hook #'layouts//save-eyebrowse-for-perspective)

        ;; spacemacs/update-eyebrowse-for-perspective
        (defun layouts//update-eyebrowse-for-perspective (&rest _args)
          "update & save current frame's eyebrowse workspace to its perspective"
          (let* ((current-slot (eyebrowse--get 'current-slot))
                 (current-tag (nth 2 (assoc current-slot (eyebrowse--get 'window-configs)))))
            (eyebrowse--update-window-config-element
             (eyebrowse--current-window-config current-slot current-tag)))
          (layouts//save-eyebrowse-for-perspective))

        (add-hook 'persp-before-switch-functions #'layouts//update-eyebrowse-for-perspective)
        (add-hook 'persp-before-save-state-to-file-functions #'layouts//update-eyebrowse-for-perspective)

        ;; spacemacs/load-eyebrowse-for-perspective
        (defun layouts//load-eyebrowse-for-perspective (type &optional frame)
          "load an eyebrowse workspace according to a perspective's parameters.
      FRAME's perspective is the perspective that is considered, defaulting to
      the current frame's perspective.
      If the perspective doesn't have a workspace, create one."
          (when (eq type 'frame)
            (let* ((workspace-params (layouts//get-persp-workspace (get-frame-persp frame) frame))
                   (window-configs (nth 0 workspace-params))
                   (current-slot (nth 1 workspace-params))
                   (last-slot (nth 2 workspace-params)))
              (if window-configs
                  (progn
                    (eyebrowse--set 'window-configs window-configs frame)
                    (eyebrowse--set 'current-slot current-slot frame)
                    (eyebrowse--set 'last-slot last-slot frame)
                    (eyebrowse--load-window-config current-slot))
                (eyebrowse--set 'window-configs nil frame)
                (eyebrowse-init frame)
                (layouts//save-eyebrowse-for-perspective frame)))))

        (add-hook 'persp-activated-functions #'layouts//load-eyebrowse-for-perspective)

        ;; spacemacs/load-eyebrowse-after-loading-layout
        (defun layouts//load-eyebrowse-after-perspective-load (_state-file _persp-hash _persp-names)
          "bridge between `persp-after-load-state-functions' and
      `layouts//load-eyebrowse-for-perspective'.
      _PHASH is the hash were the loaded perspectives were placed, and
      PERSP-NAMES are the names of these perspectives."
          (let ((cur-persp (get-current-persp)))
            ;; load eyebrowse for current perspective only if it was one of the loaded
            ;; perspectives
            (when (member (or (and cur-persp (persp-name cur-persp))
                              persp-nil-name)
                          persp-names)
              (layouts//load-eyebrowse-for-perspective 'frame))))

        (add-hook 'persp-after-load-state-functions #'layouts//load-eyebrowse-after-perspective-load))
    #+END_SRC


*** piper
    #+BEGIN_SRC emacs-lisp
      (use-package piper
        :defer t
        :straight (emacs-piper :type git :host gitlab :repo "howardabrams/emacs-piper")
        :commands (piper-ui)
        :init
        (leader/with-prefix "|"
          (leader/set-keys
            ""    "piper"
            "RET" 'piper-ui
            "|"   'piper
            "o"   'piper-other
            "@"   'piper-remote))

        :config
        (defalias 'piper-ui #'piper-user-interface))
    #+END_SRC

*** proced
    edit processes, like windows task-manager but within emacs :)

    #+BEGIN_SRC emacs-lisp
      (use-package proced
        :config
        (evil-set-initial-state 'proced-mode 'motion)

        (leader/set-keys-for-major-mode 'proced-mode
          "m"  "mark"
          "ma" 'proced-mark-all
          "mu" 'proced-unmark-all
          "mp" 'proced-mark-parents
          "mc" 'proced-mark-children
          "mt" 'proced-toggle-marks
          "mm" 'proced-toggle-marks

          "k" 'proced-send-signal)

        (general-define-key
          :states  'motion
          :keymaps 'proced-mode-map

          "q"      nil
          "C-?"    'proced-help

          "<C-SPC>" 'proced-mark
          "<DEL>"   'proced-unmark-backward
          "a" 'proced-mark
          "A" 'proced-mark-all
          "u" 'proced-unmark
          "U" 'proced-unmark-all
          "p" 'proced-mark-parents
          "P" 'proced-mark-children
          "M" 'proced-toggle-marks

          "x"   'proced-send-signal
          "C-k" 'proced-send-signal

          "<M-SPC>" 'proced-toggle-tree

          "r" 'proced-refine
          "R" 'proced-renice

          "o" 'proced-omit-processes ;; marked

          "<C-M-SPC>" 'proced-format-interactive

          "sS" 'proced-sort-interactive
          "sc" 'proced-sort-pcpu
          "sm" 'proced-sort-pmem
          "sp" 'proced-sort-pid
          "ss" 'proced-sort-start
          "st" 'proced-sort-time
          "su" 'proced-sort-user
          "S"  'proced-filter-interactive))
    #+END_SRC

*** process-menu
    #+BEGIN_SRC emacs-lisp
      (use-package simple
        :straight (simple :type built-in)
        :defer t
        :config
        (evil-set-initial-state 'process-menu-mode 'motion)

        (general-define-key
          :states  'motion
          :keymaps 'process-menu-mode-map
          "d" 'process-menu-delete-process

          "TAB"   'forward-button
          "S-TAB" 'backward-button
          "C-j"   'forward-button
          "C-k"   'backward-button))
    #+END_SRC

*** projectile
**** projectile
     #+BEGIN_SRC emacs-lisp
       (use-package projectile
         :ensure t
         :defer  10
         :delight ""
         :hook (prog-mode . projectile-mode)
         :commands (project-has-file-p
                    when-project-has-file-p
                    projectile-ivy-persp-switch-project
                    projectile-show-and-copy-project-dir)
         :init
         (leader/set-keys
           "p"  "projectile"
           "p!" 'projectile-run-shell-command-in-root
           "p%" 'projectile-replace-regexp
           "p&" 'projectile-run-async-shell-command-in-root
           "pa" 'projectile-toggle-between-implementation-and-test
           "pb" 'projectile-switch-to-buffer
           "pc" 'projectile-compile-project
           "ph" 'projectile-dired ;; dired in project home directory
           "pd" 'projectile-find-dir
           "pD" 'projectile-discover-projects-in-directory
           "pf" 'projectile-find-file
           "pF" 'projectile-find-file-in-known-projects
           "pG" 'projectile-regenerate-tags
           "pg" 'projectile-find-tag
           "pI" 'projectile-invalidate-cache
           "pk" 'projectile-kill-buffers
           "pl" 'projectile-ivy-persp-switch-project
           "py" 'projectile-show-and-copy-project-dir
           "pp" 'projectile-run-project
           "pr" 'projectile-recentf
           "p[" 'projectile-previous-project-buffer
           "p]" 'projectile-next-project-buffer
           "pt" 'projectile-test-project
           "pso" 'projectile-multi-occur
           "psR" 'projectile-replace
           ;; "pv"  'projectile-edit-dir-locals
           "fvp" 'projectile-edit-dir-locals
           "p TAB" 'projectile-find-other-file
           "p DEL" 'projectile-browse-dirty-projects
           "p RET" 'projectile-find-file-dwim
           "p M-RET" 'projectile-find-file-dwim-other-window

           ;; "px"  "execute"
           ;; "pxe" 'projectile-run-eshell
           ;; "pxi" 'projectile-run-ielm
           ;; "pxt" 'projectile-run-term
           ;; "pxs" 'projectile-run-shell
           ;; "pxv" 'projectile-run-vterm
           "pv" 'projectile-run-vterm
           )

         (advice-add 'delete-buffer-file :after (lambda (&rest r)
                                                  (when (projectile-project-p)
                                                    (call-interactively 'projectile-invalidate-cache))))
         :config
         (projectile-register-project-type 'rake '("rakefile")
                                           :compile "rake build"
                                           :test    "rake test"
                                           :run     "rake run"
                                           :test-suffix ".spec")

         (projectile-register-project-type 'pipenv '("Pipfile")
                                           :test "pipenv py -m pytest")

         (defun projectile-ensure-no-trailing-slash-in-root (func &rest args)
           (cl-letf* (((symbol-function 'true-projectile-project-root)
                       (symbol-function 'projectile-project-root))
                      ((symbol-function 'projectile-project-root)
                       (lambda (&rest args)
                         ;; TODO maybe don't hardcode file name seperator
                         (string-remove-suffix "/"
                                               (apply 'true-projectile-project-root args)))))
             (apply func args)))

         (setq projectile-project-search-path '("~/programming/repos/")
               projectile-tags-backend 'xref ;; opt into gtags
               projectile-indexing-method 'alien ;; never use native
               projectile-tags-command "ctags -Re -f \"%s\" %s \"%s\""
               projectile-cache-file (var! "projectile/cache.el")
               projectile-known-projects-file (var! "projectile/known-projects.el"))

         (advice-add 'projectile-regenerate-tags :around #'projectile-ensure-no-trailing-slash-in-root)

         (when (windows-p)
           ;; fixes search glitches on windows when using cygwin... also strips out leading ./ because
           ;; ivy seems to recognise ./ paths as distinct from their non ./ counterparts... maybe that's
           ;; projectiles fault... who knows. also exclude special emacs backup files from search results.
           (setq projectile-generic-command "find . -type f -not -iname '#*#' -print | cut -c3- | tr '\\n' '\\0'"))

         (defun projectile-ivy-persp-switch-project (arg)
           (interactive "P")
           (ivy-read "Switch to Project Perspective: "
                     (if (projectile-project-p)
                         (cons (abbreviate-file-name (projectile-project-root))
                               (projectile-relevant-known-projects))
                       projectile-known-projects)
                     :action (lambda (project)
                               (let ((persp-reset-windows-on-nil-window-conf t)
                                     (project-name (file-name-nondirectory
                                                    (string-remove-suffix "/" project))))
                                 (persp-switch project-name)
                                 (projectile-switch-project-by-name project)))))

         (defun projectile-cleanup--shut-up-please (func &rest args)
           "I don't need to know when you've done nothing... thnx tho :P"
           (cl-letf* (((symbol-function 'actual-message)
                       (symbol-function 'message))
                      ((symbol-function 'message)
                       (lambda (format &rest args)
                         (if (string-equal format
                                           "No projects needed to be removed.")
                             (apply 'format format args)
                           (apply 'actual-message format args)))))
             (apply func args)))

         (advice-add 'projectile-cleanup-known-projects :around #'projectile-cleanup--shut-up-please)

         (defun projectile-compile--double-prefix-means-run-comint (func &optional args)
           "allow running compilation interactively when multiple prefixes are given.
       with two prefixes (C-u C-u) runs default compilation command in interactive
       compilation buffer. with three prompts for command and then runs it in an
       interactive compilation buffer."
           (let ((prefix current-prefix-arg))
             (if (and (consp prefix)
                      (setq prefix (car prefix))
                      (>= prefix 16))
                 (cl-letf* (((symbol-function 'actual-compile)
                             (symbol-function 'compile))
                            ((symbol-function 'compile)
                             (lambda (command &optional comint)
                               (actual-compile command t))))
                   (funcall func (if (eq prefix 16) nil '(4))))
               (funcall func prefix))))

         (advice-add 'projectile-run-project     :around #'projectile-compile--double-prefix-means-run-comint)
         (advice-add 'projectile-compile-project :around #'projectile-compile--double-prefix-means-run-comint)
         (advice-add 'projectile-test-project    :around #'projectile-compile--double-prefix-means-run-comint)

         (defun projectile-show-and-copy-project-dir (&optional prefix)
           (interactive "P")
           (if (not (projectile-project-p))
               (message "you're not currently in a project")
             (let ((path (projectile-project-root)))
               (when prefix
                 (if (and (consp prefix) (eq (car prefix) 4))
                     (insert path)
                   (save-excursion
                     (insert path))))
               (message (abbreviate-file-name path))
               (kill-new path))))

         (defun project-has-file-p (&rest files)
           (let ((project-dir (projectile-project-p)))
             (and project-dir
                  (cl-loop
                   for file in files
                   when (file-exists-p (concat project-dir file))
                   return t))))

         (defmacro when-project-has-file-p (file &rest body)
           `(when (project-has-file-p ,file)
              ,@body)))
     #+END_SRC

**** counsel-projectile
     needs to be loaded after ivy and projectile, including the init function.

     #+BEGIN_SRC emacs-lisp
       (use-package counsel-projectile
         :ensure t
         :defer  t
         ;; :hook (projectile-mode . counsel-projectile-mode)
         :init
         (setq counsel-projectile-org-capture-templates-first-p nil)

         (general-define-key
           [remap counsel-org-capture] 'counsel-projectile-org-capture)

         (leader/set-keys
           ;; 'counsel-projectile-org-agenda
           "fp"    'counsel-projectile-switch-project
           "pP"    'counsel-projectile-switch-project
           "pf"    'counsel-projectile-find-file
           "pd"    'counsel-projectile-find-dir
           "pb"    'counsel-projectile-switch-to-buffer
           "p SPC" 'counsel-projectile

           "ps"  "search"
           "psg" 'counsel-projectile-grep
           "psv" 'counsel-projectile-git-grep
           "psa" 'counsel-projectile-ag
           "psr" 'counsel-projectile-rg))
     #+END_SRC

*** rake
    #+BEGIN_SRC emacs-lisp
      (use-package rake
        :ensure t
        :defer  t
        :commands (rake-refresh)
        :init
        (leader/set-keys
          "cr" 'rake
          "cR" 'rake-rerun)

        :config
        (setq rake-completion-system 'ivy-read
              rake-cache-file (var! "rake.cache"))

        (defalias 'rake-refresh #'rake-regenerate-cache))
    #+END_SRC

*** restclient
**** restclient-mode
     #+BEGIN_SRC emacs-lisp
       (use-package restclient
         :ensure t
         :defer  t
         :commands (restclient)
         :init
         (leader/set-keys
           "ar" 'restclient)

         :config
         (let ((leader leader-major-mode-key))
           (leader/set-keys-for-major-mode 'restclient-mode
             "RET"   '("execute-current" . restclient-http-send-current)
             "M-RET" '("execute-current-raw" . restclient-http-send-current-raw)
             leader  '("execute-current-same-window" . restclient-http-send-current-stay-in-window)
             "y"     '("yank-curl-command" . restclient-copy-curl-command)
             "m"     'restclient-mark-current
             "n"     'restclient-narrow-to-current
             "w"     'widen))

         (general-define-key
           :states 'motion
           :keymaps 'restclient-mode-map
           "gj" 'restclient-jump-next
           "gk" 'restclient-jump-prev)

         (general-define-key
           :states  'normal
           :keymaps 'restclient-outline-mode-map
           "TAB"   'restclient-toggle-body-visibility-or-indent
           "g TAB" 'restclient-toggle-body-visibility-or-indent)

         (add-hook 'restclient-response-mode-hook
                   'evil-motion-state)

         (push (rx "*HTTP Response*") whitespace-exempt-buffers)

         (defun restclient ()
           "create a new buffer in restclient mode"
           (interactive)
           (let ((buffer (create-new-empty-buffer "restclient")))
             (with-current-buffer buffer
               (restclient-mode))
             (display-buffer buffer))))
     #+END_SRC

**** company-restclient
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'restclient
         (use-package company-restclient
           :ensure t
           :defer  t
           :commands (company-restclient)
           :config
           (company/configure-mode (restclient-mode :major t)
             company-restclient)))
     #+END_SRC

**** org-babel-restclient
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'restclient
         (use-package ob-restclient
           :ensure t
           :defer  t
           :init
           (with-eval-after-load 'org
             (org-babel-do-load-languages
              'org-babel-load-languages
              '((restclient . t))))))
     #+END_SRC

*** save-place
    remembers the cursor position in open files... so when I reopen them I'm taken to that point
    immeadiately.

    #+BEGIN_SRC emacs-lisp
      (if (emacs>= "25.1")
          (save-place-mode +1)
        (require 'saveplace)
        (setq-default save-place t))

      (setq save-place-forget-unreadable-files nil
            save-place-ignore-files-regexp (rx
                                            (or "COMMIT_EDITMSG"
                                                "svn-commit"
                                                (and "hg-editor-" (one-or-more num))
                                                (and (or ".txt" ".tmp") eol)
                                                (and bol (or "/tmp/"))
                                                (and "bzr_log." (one-or-more num)))))
    #+END_SRC

*** server
    #+BEGIN_SRC emacs-lisp
      (use-package server
        :demand t
        :commands (server-kill-clients-for-buffer
                   server-header-mode--toggle-show-headers)
        :init
        (leader/set-keys
          "t1" '("toggle-client-headers"       . server-header-mode--toggle-show-headers)
          "t2" '("toggle-client-headers-local" . server-header-mode--toggle-show-headers-local))

        :config
        ;; see [[http://emacshorrors.com/posts/determining-if-the-server-is-started-or-the-wonders-of-server-running-p.html][emacs-horrors]] for why this is sometimes useless :(
        (or (server-running-p) (server-start))

        ;; see [[https://superuser.com/questions/295156/how-to-set-the-exit-status-for-emacsclienti][here]].
        (defun server-kill-clients-for-buffer (&optional prefix)
          "Sends error exit command to every client for the current buffer."
          (interactive "P")
          (if (not server-buffer-clients)
              (error "current buffer has no server clients")
            (dolist (proc server-buffer-clients)
              (server-send-string proc "-error die"))
            (unless prefix (kill-buffer))))

        (defalias 'server-abort #'server-kill-clients-for-buffer)

        (advice-add 'server-edit :before
                    (defun server-edit--auto-save-on-exit (&rest args)
                      "automatically save file before server exit"
                      (save-buffer)))

        (defvar server-header-mode-show-header t
          "when true, any new buffers in which `server-header-mode' is activated
      will have the header shown.")

        (defun server-header-mode--toggle-show-headers (&optional arg local)
          (interactive "P")
          (let ((value (cond
                        (arg
                         (not (zerop (prefix-numeric-value arg))))
                        (t (not server-header-mode-show-header)))))
            (if local
                (setq-local server-header-mode-show-header value)
              (setq server-header-mode-show-header value))

            (toggle-buffer-header arg)

            (message "%s client headers in %s"
                     (if server-header-mode-show-header
                         (propertize "showing" 'face 'compilation-info)
                       (propertize "hiding" 'face 'compilation-error))
                     (if local
                         "the current buffer"
                       "all buffers"))))

        (defun server-header-mode--toggle-show-headers-local (&optional arg)
          (interactive "P")
          (server-header-mode--toggle-show-headers arg t))

        ;; add ,, and ,q like bindings in server edit sessions, like org-edit-src-code
        (define-minor-mode server-header-mode
          "a dummy minor mode for files being edited by `server'.
      makes it easier to bind keys (& leaders :grinning: for them)."
          nil
          "ServerEdit"
          '(([remap evil-write] . server-edit)
            ([remap evil-save-and-close] . server-edit)
            ([remap evil-quit-all-with-error-code] . server-abort))
          (when (and server-header-mode
                     server-header-mode-show-header)
            (setq header-line-format
                  (substitute-command-keys
                   "Editing an emacsclient sesssion.  Exit with '\\[server-edit]' or abort with '\\[server-abort]'"))))

        (add-hook 'server-switch-hook
                  (defun server-switch--enable-server-header-mode ()
                    (when server-buffer-clients
                      (unless (or (bound-and-true-p magit-mode)
                                  (bound-and-true-p git-commit-mode))
                        (server-header-mode)))))

        (add-hook 'server-done-hook (lambda () (server-header-mode -1)))

        (leader/with-major-mode-prefix
          (leader/set-keys-for-mode 'server-header-mode
            "," 'server-edit
            "q" 'server-abort)))
    #+END_SRC

**** edit-server
     invoke emacs-client from a browser... EPIC!!!

     #+BEGIN_SRC emacs-lisp
       (defvar mohkale-browser-edit-package 'edit-with-emacs
         "The extension with which I connect emacs to my browser.
       Set to atomic to use atomic-chrome and edit-with-emacs to use
       edit-with-emacs.

       Personally I prefer edit-with-emacs because it lets you a cancel
       an edit session and revert to the original (or last saved) text.
       It also has the option of binding M-<enter> in chrome to edit with
       emacs.

       Atomic chrome reflects changes live, which is pretty cool if you
       expect emacs to crash whilst writing... but otherwise isn't too
       useful.")

       (defvar mohkale-browser-edit-mode initial-major-mode
         "default major mode for a browser edit session.")

       (defvar mohkale-browser-edit-mode-alist
         `(("^github.com/" . ,#'markdown-mode)
           ("^gitlab.com/" . ,#'markdown-mode))
         "association list of url regexps against mode-functions.")

       (cond
        ((eq mohkale-browser-edit-package 'edit-with-emacs)
         (use-package edit-server
           :ensure t
           :demand t
           :delight
           (edit-server-edit-mode "ESE") ;; emacs server edit
           :init
           (setq edit-server-new-frame nil  ;; prefer current frame
                 edit-server-default-major-mode mohkale-browser-edit-mode
                 edit-server-url-major-mode-alist mohkale-browser-edit-mode-alist)

           (edit-server-start)
           :config
           (leader/with-major-mode-prefix
             (leader/set-keys-for-mode 'edit-server-edit-mode
               "s" 'edit-server-save
               "," 'edit-server-done
               "q" 'edit-server-abort)))

         ;; fixes issues with non conventional input components likes gmails compose box
         (use-package edit-server-htmlize
           :ensure t
           :defer  t
           :hook ((edit-server-start . edit-server-maybe-dehtmlize-buffer)
                  (edit-server-done  . edit-server-maybe-htmlize-buffer))))

        ((eq mohkale-browser-edit-package 'atomic)
         (use-package atomic-chrome
           :ensure t
           :demand t
           :delight
           (atomic-chrome-edit-mode "Atomic")
           :init
           (setq atomic-chrome-default-major-mode   mohkale-browser-edit-mode
                 atomic-chrome-url-major-mode-alist mohkale-browser-edit-mode-alist)

           (atomic-chrome-start-server)
           :config
           (leader/with-major-mode-prefix
             (leader/set-keys-for-mode 'atomic-chrome-edit-mode
               "s" 'atomic-chrome-send-buffer-text
               "," 'atomic-chrome-close-current-buffer))))

        (mohkale-browser-edit-package
         (message "unknown browser extension package: %s"
                  mohkale-browser-edit-package)))
     #+END_SRC

*** simple
    #+BEGIN_SRC emacs-lisp
      (use-package simple
        :straight (simple :type built-in)
        :defer t
        :commands (smart-universal-argument
                   universal-argument-batch-increment
                   universal-argument-batch-decrement)
        :config
        (push 'messages-buffer-mode whitespace-exempt-modes)

        (defmacro defun-universal-argument-operation (name docstring &rest body)
          `(defun ,name ()
             ,docstring
             (interactive)
             (prefix-command-preserve-state)
             (if (not prefix-arg)
                 (universal-argument)
               ,@body)

             (when prefix-arg
               (universal-argument--mode))))
        (put 'defun-universal-argument-operation 'lisp-indent-function 'defun)

        (defun-universal-argument-operation smart-universal-argument
          "combine both universal-argument and universal-argument-more
      into a single invokeable command. for some reason, calling simply
      more before a regular prefix has been specified, will result in no
      overall prefix being set :("
          (universal-argument-more prefix-arg))

        (let ((universal-argument-increment-by 4))
          ;; I'm not sure why universal-argument-more multiplies
          ;; the prefix arg by a factor of 4. I mean, 4 to 16 is
          ;; fine, but 16 to 64 is pretty unlikely to be what you
          ;; wanted. Adding by 4 would be more useful, especially
          ;; if you're using it to gauge indents.
          (defun-universal-argument-operation universal-argument-batch-increment
            (format "increment the current prefix-arg by %d."
                    universal-argument-increment-by)
            (let* ((prefix-value (prefix-numeric-value prefix-arg)))
              (setq prefix-arg
                    (+ prefix-value universal-argument-increment-by))))

          (defun-universal-argument-operation universal-argument-batch-decrement
            (format "decrement the current prefix-arg by %d."
                    universal-argument-increment-by)
            (let* ((prefix-value (prefix-numeric-value prefix-arg)))
              (setq prefix-arg (- prefix-value universal-argument-increment-by)))))

        (leader/set-keys
          "i TAB"       "indent"
          "i TAB <tab>" 'indent-region
          "i TAB RET"   'split-line
          "i TAB SPC"   'just-one-space
          "i TAB r"     'indent-relative
          "i TAB R"     'indent-relative-first-indent-point
          "i TAB ."     'hydra-indent/body
          "i TAB n"     'forward-to-indentation
          "i TAB N"     'back-to-indentation)

        ;; force state for buffer if it already exists
        (let ((buffer (get-buffer "*Messages*")))
          (when buffer
            (with-current-buffer buffer
              (evil-motion-state))))

        (general-define-key
          :keymaps 'completion-list-mode-map
          :states  'motion
          "RET" 'choose-completion
          "C-j" 'choose-completion

          "q" nil
          "Q" 'delete-completion-window

          "j" 'next-completion
          "k" 'previous-completion
          "n" 'next-completion
          "p" 'previous-completion
          "N" 'previous-completion))
    #+END_SRC

*** sudo-edit
    any machine with SSH makes this kind of obsolete :P.

    #+BEGIN_SRC emacs-lisp
      (use-package sudo-edit
        :ensure t
        :defer  t
        :commands sudo-edit
        :init
        (leader/set-keys
          "fE" 'sudo-edit))
    #+END_SRC

*** rainbow-delimeters
    pretty colors for my lisp parens :)

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters
        :ensure t
        :defer  t
        :hook (prog-mode . rainbow-delimiters-mode)
        :commands rainbow-delimiters-mode)
    #+END_SRC

*** rainbow-mode
    highlights hex color strings in their appropriate color. keep it around... though I'll
    probably never use it.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package rainbow-mode
        :ensure t
        :defer  t)
    #+END_SRC

*** replace
    #+BEGIN_SRC emacs-lisp
      (use-package replace
        :straight (replace :type built-in)
        :defer t
        :config
        (dolist (func '(perform-replace
                        query-replace))
          (advice-add func :around
                      #'restore-default-display-buffer-actions)))
    #+END_SRC

*** regexp-builder
    #+BEGIN_SRC emacs-lisp
      (use-package re-builder
        :config
        (setq reb-re-syntax 'rx)
        ;; (evil-set-initial-state 'reb-lisp-mode 'insert)

        (general-define-key
         :keymaps 'reb-lisp-mode-map
         :states 'normal
         "gj" 'reb-next-match
         "gk" 'reb-prev-match
         [remap quit-window] 'reb-quit)

        (defun reb-save-and-quit+ ()
          "copy regexp and then exit reb."
          (interactive)
          (reb-copy)
          (reb-quit))

        (leader/set-keys-for-major-mode 'reb-lisp-mode
          "," 'reb-save-and-quit+
          "s" 'reb-copy ;; as string
          "q" 'reb-quit

          "b" 'reb-change-target-buffer
          "c" 'reb-toggle-case
          "y" 'reb-copy ;; as string
          "u" 'reb-force-update
          "s" 'reb-enter-subexp-mode
          "TAB" 'reb-change-syntax))
    #+END_SRC

*** tabulated-list-mode
    #+BEGIN_SRC emacs-lisp
      (use-package tabulated-list
        :defer t
        :hook (tabulated-list-mode . hl-line-mode)
        :commands (tabulated-list-next-column)
        :config
        (evil-set-initial-state 'tabulated-list-mode 'motion)

        (defun tabulated-list--get-column-widths ()
          "return a list of all the "
          (mapcar (lambda (x) (+ (nth 1 x)
                                 (or (plist-get (cdr x) :pad-right) 1)))
                  tabulated-list-format))

        (defun tabulated-list--get-column-pivots ()
          (let (prev values)
            (setq values (mapcar (lambda (x)
                                   (let ((new-val (+ x (or prev 0))))
                                     (setq prev new-val)
                                     new-val))
                                 (tabulated-list--get-column-widths)))
            ;; (mapcar (lambda (x) (- x 1)) values)
            values))

        (defun tabulated-list--properties ()
          (let* ((current-column-position (- (point)
                                             (line-beginning-position)))
                 (column-pivots (tabulated-list--get-column-pivots))
                 (column-count (length column-pivots))
                 (preceding-columns (seq-filter
                                     (lambda (x)
                                       (<= x current-column-position))
                                     column-pivots))
                 (following-columns (nthcdr (length preceding-columns)
                                            column-pivots))
                 (current-column (car following-columns))
                 (following-columns (cdr following-columns)))
            `(:current-column-position ,current-column-position
                                       :column-pivots           ,column-pivots
                                       :column-count            ,column-count
                                       :preceding-cols          ,preceding-columns
                                       :current-column          ,current-column
                                       :following-cols          ,following-columns)))

        ;; doesn't work when row contains truncated entries, such as
        ;; buffers with a "name..." entry, because those dots aren't
        ;; included in the width of the column.
        (defun tabulated-list-next-column (&optional count)
          "moves to the next column shown by tabulated list mode"
          (interactive)
          (or count (setq count 1))

          (when tabulated-list-format
            (let* ((properties (tabulated-list--properties))
                   (line-step (floor (/ count
                                        (plist-get properties :column-count)))))
              ;; move however many lines it takes to reach row with desired column
              (unless (zerop line-step)
                (next-line line-step))

              (unless (eobp)
                (cond
                 ((eq (point) (line-end-position))
                  ;; when at the end of the last column, goto next row
                  (next-line)
                  (goto-char (line-beginning-position)))
                 ((not (plist-get properties :following-cols))
                  ;; no next column, goto end of current
                  (goto-char (line-end-position)))
                 (t
                  ;; goto next column from the end of the current one
                  (goto-char (+ (line-beginning-position)
                                (plist-get properties :current-column)))))))))

        (general-unbind
          :keymaps 'tabulated-list-mode-map
          "SPC" "ESC" "0" "<" ">" "?" "g" "h"
          "n" "p" "DEL" "S-SPC" ))
    #+END_SRC

*** tags
    #+BEGIN_SRC emacs-lisp
      (use-package ggtags
        :ensure t
        :defer  t
        :init
        (leader/set-keys
          "T"  "tags"
          "TD" 'ggtags-delete-tags
          "T/" 'ggtags-grep)

        :config
        ;; NOTE ggtags-global-mode is not a global mode... global is
        ;;      for GNU *global* tagging system
        (leader/set-keys-for-major-mode 'ggtags-global-mode
          "r" 'recompile
          "f" 'next-error-follow-minor-mode))
    #+END_SRC

*** tramp
    Transparent ReMote Access Protocol

    #+BEGIN_SRC emacs-lisp
      (use-package tramp
        :defer t
        :config
        ;; google cloud integration... curtesy of:
        ;;   https://qiita.com/tanatana/items/218b19808f2428b125fe
        ;; see [[https://cloud.google.com/sdk/docs/quickstart-windows][here]] for how to install gcloud CLI.
        (push
         '("gcssh"
           (tramp-login-program        "gcloud compute ssh")
           (tramp-login-args           (("%h")))
           (tramp-async-args           (("-q")))
           (tramp-remote-shell         "/bin/sh")
           (tramp-remote-shell-args    ("-c"))
           (tramp-gw-args              (("-o" "GlobalKnownHostsFile=/dev/null")
                                        ("-o" "UserKnownHostsFile=/dev/null")
                                        ("-o" "StrictHostKeyChecking=no")))
           (tramp-default-port         22))
         tramp-methods))
    #+END_SRC

*** tramp-term
    create remote terminal sessions effortlessly... this should be built into term tbh.

    #+BEGIN_SRC emacs-lisp
      (use-package tramp-term
        :ensure t
        :defer  t
        :commands (tramp-term
                   ;; term--use-tramp-term-when-in-tramp-directory
                   )
        :init
        ;; (add-hook 'term :before-until #'term--use-tramp-term-when-in-tramp-directory)
        :config
      ;;   (defun term--use-tramp-term-when-in-tramp-directory (&rest args)
      ;;     "when current buffers is in a tramp path open a tramp term session
      ;; if prefix arg specified, disregard this and open a local term sessions"
      ;;     (when (and (not current-prefix-arg)
      ;;                default-directory
      ;;                (tramp-tramp-file-p default-directory))
      ;;       (tramp-term )
      ;;         )
      ;;     )
        )
    #+END_SRC

*** transpose-frame
    #+BEGIN_SRC emacs-lisp
      (use-package transpose-frame
        :defer t
        :commands (transpose-frame
                   flip-frame
                   flop-frame ;; flip horizontally
                   rotate-frame ;; 180 degrees
                   rotate-frame-clockwise ;; 90 degrees
                   rotate-frame-anti-clockwise ;; 90 degrees
                   )
        :init
        (general-define-key
          :keymaps 'mohkale-window-map
          "C-t"   'transpose-frame
          "t"     'transpose-frame
          "("     'rotate-frame-clockwise
          ")"     'rotate-frame-anti-clockwise
          "*"     'rotate-frame
          "f"     'flip-frame
          "F"     'flop-frame))
    #+END_SRC

*** undo-tree
    #+BEGIN_SRC emacs-lisp
      (use-package undo-tree
        :ensure t
        :defer  t
        :diminish
        :config
        (push 'undo-tree-visualizer-mode
               whitespace-exempt-modes)

        (setq undo-tree-auto-save-history t
              ;; TODO look into undoing within region
              ;; undo-tree-enable-undo-in-region t
              )

        ;;; where do undo-tree auto-saves go.
        (setq undo-tree-history-directory-alist
              `(("." . ,(var! "undo"))))

        (defvar undo-tree-skip-autosave-regex+
          (rx
           (or
            ;; match extensions in filename
            (and (or ".pdf" ".log") eol)
            ;; match exact file paths
            (and
             (or
              ;; wildcard regexp match. any match is a valid match.
              (and "[*Org Src")
              ;; match from the beginning of the line
              (and bol (or
                        (eval dotemacs-var-path)
                        (eval (concat straight-base-dir "straight/"))
                        (eval package-user-dir)
                        (eval external-packages-directory)
                        (eval bookmark-default-file)
                        (eval mohkale-dashboard-banners-directory)))))))
          "don't create an undo-tree auto-save for file if `buffer-file-name' \
      matches this regexp.")

        (advice-add 'undo-tree-save-history :around
                    (defun undo-tree-save-history--respect-ignore+ (func &rest args)
                      "respect `undo-tree-skip-autosave-regex+'.
      also suppresses undo-tree messages relating to saving files."
                      (when (and undo-tree-skip-autosave-regex+
                                 (not (string-match-p undo-tree-skip-autosave-regex+
                                                      buffer-file-name)))
                        (apply func args))))

        (advice-add 'undo-tree-save-history :around
                    (defun undo-tree-save-history--suppress-message+ (func &rest args)
                      (with-no-write-messages (apply func args))))

        (general-unbind
          :keymaps 'undo-tree-map
          "C-/" "C-_" "C-?"))
    #+END_SRC

*** uuidgen
    #+BEGIN_SRC emacs-lisp
      (use-package uuidgen
        :ensure t
        :defer  t
        :commands uuidgen
        :init
        (leader/set-keys
          "iU" 'uuidgen
          ;; "U" '("uuid" . :prefix-command mohkale-insert-uuid-map)
          ;; "U1" 'uuidgen-1
          ;; "U4" 'uuidgen-4
          ;; "UU" 'uuidgen-U
          ))
    #+END_SRC

*** vi-tilde
    display ~ on trailing lines in the fringe. doesn't work with emacs's new builtin line
    numbers mode.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package vi-tilde-fringe
        :ensure t
        :defer  t
        :diminish
        :commands (vi-tilde-fringe-mode global-vi-tilde-fringe-mode)
        :config
        (global-vi-tilde-fringe-mode))
    #+END_SRC

*** view-mode
    #+BEGIN_SRC emacs-lisp
      (use-package view
        :defer t
        :config
        (general-define-key
          :keymaps 'view-mode-map
          :states  'normal
          [remap quit-window] 'View-quit
          "Q" 'View-quit-all
          "G" 'View-scroll-to-buffer-end
          "zq" 'View-exit
          "zk" 'View-kill-and-leave
          "gj" 'View-scroll-line-forward
          "gk" 'View-scroll-line-backward
          ;; "C-d" 'View-scroll-half-page-forward
          ;; "C-u" 'View-scroll-half-page-backward
          "M-d" 'View-scroll-page-forward
          "M-u" 'View-scroll-page-backward))
    #+END_SRC

*** vimish-fold
    #+BEGIN_SRC emacs-lisp
      (use-package vimish-fold
        :straight (vimish-fold :type git :host github :repo "mrkkrp/vimish-fold"
                               ;; :fork (:host github :repo "mohkale/vimish-fold")
                               )
        :hook ((text-mode . vimish-fold-mode)
               (prog-mode . vimish-fold-mode))
        :config
        (setq vimish-fold-allow-nested t)
        (setq vimish-fold-dir (var! "vimish-fold/"))

        (add-hook 'vimish-fold-mode-hook
                  (defun vimish-fold-setup-evil+ ()
                    (if vimish-fold-mode
                        (add-to-list 'evil-fold-list
                                     `((vimish-fold-mode)
                                       :delete     vimish-fold-delete
                                       :open-all   vimish-fold-unfold-all
                                       :close-all  vimish-fold-refold-all
                                       :toggle     vimish-fold-toggle
                                       :open       vimish-fold-unfold
                                       :open-rec   nil
                                       :close      vimish-fold-refold))
                      (setq evil-fold-list (cl-remove-if
                                            (lambda (e) (eq (caar e) 'vimish-fold-mode))
                                            evil-fold-list)))))

        (evil-define-operator vimish-fold-create+ (beg end)
          "Create a fold from the current region.
      See also `evil-delete-fold'."
          (vimish-fold beg end))

        (evil-define-motion vimish-fold-next-fold+ (count)
          "Go to the start of the next fold."
          :type inclusive
          (unless (numberp count)
            (setq count 1))
          (dotimes (_ count nil)
            (vimish-fold-next-fold)))

        (evil-define-motion vimish-fold-prev-fold+ (count)
          "Go to the start of the previous fold."
          :type inclusive
          (unless (numberp count)
            (setq count 1))
          (dotimes (_ count nil)
            (vimish-fold-previous-fold)))

        (general-define-key
          ;; :keymaps 'vimish-fold-mode-map
          :states '(normal motion)
          "zx" 'vimish-fold-toggle
          "zX" 'vimish-fold-toggle-recursively
          "zj" 'vimish-fold-next-fold+
          "zk" 'vimish-fold-prev-fold+
          "zo" 'vimish-fold-unfold
          "zO" 'vimish-fold-unfold-recursively
          "zd" 'vimish-fold-delete
          "zD" 'vimish-fold-delete-all
          "zf" 'vimish-fold-create+)

        ;; (general-define-key
        ;;   :keymaps '(vimish-fold-unfolded-keymap
        ;;              vimish-fold-folded-keymap)
        ;;   "TAB"   'vimish-fold-toggle
        ;;   "<tab>" 'vimish-fold-toggle)
        )
    #+END_SRC

*** visible-mark
    highlight region when mark is active.

    #+BEGIN_SRC emacs-lisp
      (use-package visible-mark
        :ensure t
        :defer  t
        :commands (visible-mark-mode))
    #+END_SRC

*** visual-line
    auto wrap long lines at the end of words.

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package visual-line
        :straight (visual-line :type built-in)
        :defer t
        :delight " Ⓛ")
    #+END_SRC

*** vlc-rc
    #+BEGIN_SRC emacs-lisp
      (use-package vlc-rc
        :straight (vlc-rc :type git :host github :repo "mohkale/vlc-rc")
        :defer t
        ;; can't defer for now, hopefully when use-package
        ;; supports bind-keymap with specific map, change.
        :commands (vlc/dired-add-file
                   vlc/dired-enqueue-file)
        :init
        (setq vlc-rc-map (make-sparse-keymap))

        (leader/with-prefix "v"
          (leader/set-keys
            "" "VLC"
            "" vlc-rc-map

            "s" "set"
            "t" "toggle"))

        (general-define-key
          :keymaps 'dired-mode-map
          :states '(normal motion)
          "v"  nil
          "vv" 'vlc/dired-add-file
          "vq" 'vlc/dired-enqueue-file)

        (general-define-key
          :keymaps 'vlc-rc-map
          "C-." 'hydra-vlc-rc/body))
    #+END_SRC

*** vterm
    #+BEGIN_SRC emacs-lisp
      (use-package vterm
        :ensure t
        :defer  t
        :commands (vterm-toggle
                   vterm-toggle-fullscreen
                   vterm-toggle-new-buffer+)
        :init
        (leader/set-keys
          "av" '("vterm" . vterm-toggle)
          "at" '("vterm-new" . vterm-toggle-new-buffer+)
          "tv" '("toggle-vterm-fullscreen" . vterm-toggle-fullscreen))

        :config
        (push 'vterm-mode whitespace-exempt-modes)
        (evil-set-initial-state 'vterm-mode 'emacs)

        (setq vterm-kill-buffer-on-exit t
              vterm-always-compile-module t
              vterm-buffer-name-string "*vterm: %s*"
              multi-vterm-buffer-name "*vterminal*"
              vterm-keymap-exceptions '("C-SPC" "C-g" "C-c" "M-x"))

        (use-package vterm-toggle
          :ensure t
          :defer  t
          :init
          (defun vterm-toggle-fullscreen (&optional arg)
            (interactive "P")

            (setq vterm-toggle-fullscreen-p
                  (if (not arg)
                      (not vterm-toggle-fullscreen-p)
                    (or (listp arg)
                        (not (zerop arg)))))

            (setq vterm-toggle-reset-window-configration-after-exit vterm-toggle-fullscreen-p)

            (message "vterm fullscreen: %s"
                     (if vterm-toggle-fullscreen-p
                         (propertize "enabled" 'face 'compilation-info)
                       (propertize "disabled" 'face 'compilation-error))))

          :config
          (setq vterm-toggle-cd-auto-create-buffer t)

          (let ((inhibit-message t))
            (vterm-toggle-fullscreen +1)))

        ;; prevent vterm being opened in a new window
        (advice-add 'vterm-toggle--new :override #'vterm)

        (defun vterm-toggle-new-buffer+ ()
          (interactive)
          "create a new vterm buffer using vterm-toggle's interface."
          (let ((current-config (current-window-configuration)))
            (if vterm-toggle-fullscreen-p
                (progn
                  (delete-other-windows)
                  (switch-to-buffer (vterm)))
              (pop-to-buffer (vterm)))

            (setq vterm-toggle--window-configration current-config)))

        (defvar-local vterm-send-escape-to-vterm-p nil
          "Track whether or not we send ESC to `vterm' or `emacs'.")

        (defun vterm-toggle-send-escape (&optional value)
          "toggle whether escape is sent to vterm or to emacs.
      only works with GUI emacs... but good enough, I guess."
          (interactive)
          (let ((sending-to-emacs (or (eq value 'emacs)
                                      vterm-send-escape-to-vterm-p)))
            (general-define-key
             :keymaps 'vterm-mode-map
             "<escape>" (if sending-to-emacs
                            nil
                          'vterm--self-insert))
            (setq vterm-send-escape-to-vterm-p (not sending-to-emacs))

            (message (format "Sending ESC to %s."
                             (if vterm-send-escape-to-vterm-p "vterm" "emacs")))))

        ;; by default, escape is sent to vterm, not emacs.
        (let ((inhibit-message t))
          (vterm-toggle-send-escape 'vterm))

        (defun vterm-send-escape ()
          (interactive)
          (when vterm--term
            (process-send-string vterm--process "\C-[")))

        (defun vterm-send-ctrl-space ()
          (interactive)
          (when vterm--term
            (process-send-string vterm--process "\C-@")))

        (defun vterm-mouse-set-point (&rest args)
          "tmux like mouse handler. on click, switch to copy-mode."
          (interactive)
          (vterm-copy-mode +1)
          (funcall-interactively 'mouse-set-point args))

        ;; source [[https://github.com/akermu/emacs-libvterm#counsel-yank-pop-doesnt-work][emacs-libvterm]].
        (defun vterm-counsel-yank-pop-action (orig-fun &rest args)
          (if (equal major-mode 'vterm-mode)
              (let ((inhibit-read-only t)
                    (yank-undo-function (lambda (_start _end) (vterm-undo))))
                (cl-letf (((symbol-function 'insert-for-yank)
                           (lambda (str) (vterm-send-string str t))))
                  (apply orig-fun args)))
            (apply orig-fun args)))

        (advice-add 'counsel-yank-pop-action :around
                    #'vterm-counsel-yank-pop-action)

        (advice-add 'switch-to-last-buffer :filter-args
                    (defun switch-to-last-buffer--bury-vterm-buffers (&rest args)
                      "prevent `switch-to-last-buffer' oferring vterm.
      unless there's LITERALLY no other buffer you could possibly mean to go to."
                      (let ((buffer (car args))
                            (i 0)
                            (length (length (buffer-list))))
                        (while (and (< i length)
                                    (not buffer))
                          (setq i (1+ i))

                          (with-current-buffer (other-buffer)
                            (if (derived-mode-p 'vterm-mode)
                                (bury-buffer)
                              (setq buffer (current-buffer)))))

                        (list (or buffer
                                  (other-buffer))))))

        (advice-add 'switch-to-last-buffer :before-until
                    (defun switch-to-last-buffer--pop-vterm-window-config ()
                      "when switching to last buffer from a maximized vterm buffer
      instead switch to the window config from before the "
                      (when (and (derived-mode-p 'vterm-mode)
                                 vterm-toggle-fullscreen-p
                                 vterm-toggle--window-configration)
                        (set-window-configuration vterm-toggle--window-configration)
                        (setq vterm-toggle--window-configration nil)
                        t)))

        (general-define-key
         :keymaps 'vterm-mode-map
         "<mouse-1>" 'vterm-mouse-set-point
         "<C-backspace>" 'vterm-send-C-w
         "C-h" 'vterm-send-C-h
         "C-v" 'vterm-send-C-v
         "M-v" 'vterm-copy-mode
         "C-u" 'vterm-send-C-u
         "C-c C-g" 'vterm-send-C-g
         "C-c C-c" 'vterm-send-C-c
         "C-c SPC"   'vterm-send-ctrl-space
         "C-c C-SPC" 'vterm-send-ctrl-space
         "C-ESC" 'vterm-send-escape
         "M-ESC" 'vterm-send-escape

         ;; this is Magic :space_invader:.
         "C-S-n" 'vterm-toggle-forward
         "C-S-p" 'vterm-toggle-backward)

        (general-define-key
         :keymaps 'vterm-copy-mode-map
         :states 'motion
         [remap evil-end-of-line] 'vterm-end-of-line
         "gj" 'vterm-next-prompt
         "gk" 'vterm-previous-prompt
         "RET" 'vterm-copy-mode)

        ;; TMUX compatibility bindings
        (general-define-key
         :states 'emacs
         :prefix leader-nnorm-key
         :keymaps 'vterm-mode-map
         "v" '("copy-mode" . vterm-copy-mode)
         "p" 'vterm-yank)

        (general-define-key
         :prefix leader-nnorm-key
         :states 'motion
         :keymaps 'vterm-copy-mode-map
         "v" 'vterm-copy-mode
         "p" 'vterm-yank)

        (add-hook 'vterm-copy-mode-hook
                  (defun vterm-copy-mode-switch-evil-state (&rest _)
                    (if vterm-copy-mode
                        (evil-change-state 'motion)
                      (evil-change-state 'emacs))))

        (add-hook 'vterm-mode-hook
                  (defun vterm-keep-cursor-on-evil-state-change ()
                    (setq-local evil-move-cursor-back nil)))

        (advice-add 'vterm-send-return :override
                    (defun vterm-send-return-as-ctrl-m ()
                      (when vterm--term
                        (process-send-string vterm--process "\C-m")))))
    #+END_SRC

**** commands
     define elisp commands accessible through the ~vterm_cmd~ shell function.

     #+NAME: vterm-cmds
     | name                   | cmd                              |
     |------------------------+----------------------------------|
     | find-file              | vterm-cmd-find-file              |
     | find-file-other-window | vterm-cmd-find-file-other-window |
     | list-buffers           | vterm-cmd-list-buffers           |
     | message                | message                          |
     | vterm-clear-scrollback | vterm-clear-scrollback           |

     #+BEGIN_SRC emacs-lisp :var cmds=vterm-cmds :results silent
       (with-eval-after-load 'vterm
         (setq vterm-eval-cmds
               (cl-loop for (name cmd) in cmds
                        do (setq cmd-sym (intern cmd))
                        when (string-prefix-p "vterm-cmd" cmd)
                          do (autoload cmd-sym "mohkale-vterm-cmds.el")
                        end

                        collect (list name cmd-sym))))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp :tangle bin/misc/mohkale-vterm-cmds.el
       (defun vterm-cmd-find-file (&rest paths)
         (cl-loop for path in (or paths (list default-directory))
                  do (find-file path)))

       (defun vterm-cmd-find-file-other-window (&rest paths)
         (cl-loop for path in (or paths (list default-directory))
                  do (find-file-other-window path)))

       (defun vterm-cmd-list-buffers ()
         (ibuffer t))

       (provide 'mohkale-vterm-commands)
     #+END_SRC

*** which-key
    show completion candidates for the current key prefix, after a mild delay.

    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :ensure t
        :demand t
        :diminish
        :commands (which-key-M-x+)
        :init
        (leader/set-keys
          "hk" 'which-key-show-top-level
          "h RET" 'which-key-M-x+)

        ;; prefix-completion courtesy of clemara
        ;; see https://with-emacs.com/posts/ui-hacks/prefix-command-completion/
        (defun which-key-M-x-prefix+ (&optional _)
          "Completing read and execute command from prefix-map.

      This command can be used as `prefix-help-command'. The optional
      argument is ignored and only for compatability with
      `which-key-C-h-dispatch' so this command can be bound in
      `which-key-C-h-map', too."
          (interactive)
          (let* ((evs (cond ((which-key--current-prefix)
                             (which-key--current-key-list))
                            (t
                             (butlast (append (this-command-keys-vector) nil)))))
                 (key  (and evs (apply #'vector evs))))
            (which-key-M-x+ key)))

        (setq prefix-help-command #'which-key-M-x-prefix+)

        :config
        (which-key-mode 1)

        ;; order of keys is case insensetive
        (setq which-key-sort-order 'which-key-key-order-alpha
              which-key-echo-keystrokes 0.02)

        (defun which-key-M-x+ (&optional key)
          "Completing read command and execute it.

      Only commands which are bound to keys are considered. If KEY is
      given it should be the prefix-key for which commands should be
      completed. Otherwise read command from top-level. "
          (interactive)
          (let ((cmd (which-key--completing-read-cmd+ key)))
            (when (commandp cmd)
              (which-key--execute-cmd+ cmd))))

        (defun which-key--completing-read-cmd+ (&optional prefix)
          "Completing read command for PREFIX.

      Read commands for PREFIX or top-level if PREFIX not given."
          (which-key--hide-popup-ignore-command)
          (let ((desc
                 (completing-read
                  (if prefix
                      (format "Execute (%s): " (key-description prefix))
                    "Execute: ")
                  (mapcar #'which-key--completing-read-format+
                          (which-key--get-current-bindings prefix)))))
            (intern (car (split-string desc)))))

        (defun which-key--execute-cmd+ (cmd)
          "Execute command CMD as if invoked by key sequence."
          (setq prefix-arg current-prefix-arg)
          (setq this-command cmd)
          (setq real-this-command cmd)
          (command-execute cmd 'record))

        (defun which-key--completing-read-format+ (bnd)
          "Format binding BND for `completing-read'."
          (let* ((key (car bnd))
                 (cmd (cdr bnd))
                 (desc (format "%s (%s)" cmd
                               (propertize key 'face 'which-key-key-face))))
            (which-key--maybe-add-docstring
             (format "%-50s" desc) cmd))))
    #+END_SRC

*** with-editor
    #+BEGIN_SRC emacs-lisp
      (use-package with-editor
        :init
        (leader/with-major-mode-prefix
          (leader/set-keys-for-mode 'with-editor-mode
            ","  'with-editor-finish
            "q"  'with-editor-cancel)))
    #+END_SRC

*** whitespace
    #+BEGIN_SRC emacs-lisp
      (use-package whitespace
        :defer t
        :delight
        (whitespace-mode " ⓦ")
        (global-whitespace-mode " ⓦ"))
    #+END_SRC

*** winner
    undo changes to window configurations.

    #+BEGIN_SRC emacs-lisp
      (use-package winner
        :defer 10
        :init
        (general-define-key
          :keymaps 'mohkale-window-map
          "<left>"  'winner-undo
          "<right>" 'winner-redo)

        :config
        (winner-mode +1))
    #+END_SRC

*** winum
    number windows, to make jumping to them easier.

    #+BEGIN_SRC emacs-lisp
      (use-package winum
        :ensure t
        :demand t
        :after which-key
        :init
        (general-define-key
          :keymaps 'mohkale-window-map
          "1" 'winum-select-window-1
          "2" 'winum-select-window-2
          "3" 'winum-select-window-3
          "4" 'winum-select-window-4
          "5" 'winum-select-window-5
          "6" 'winum-select-window-6
          "7" 'winum-select-window-7
          "8" 'winum-select-window-8
          "9" 'winum-select-window-9
          "0" 'winum-select-window-by-number)

        :config
        (winum-mode)

        ;; reset 1st window number option to window by number
        (push (cons '("\\(.*\\) 1" . "winum-select-window-1")
                    '("\\1 1..9"   . "window-by-number"))
              which-key-replacement-alist)

        ;; hide numbers 2 through to nine
        (push (cons '(nil . "winum-select-window-[2-9]") t)
              which-key-replacement-alist)

        ;; abbreviate 0 value
        (push (cons '("\\(.*\\) 0" . "winum-select-window-by-number")
                    '("\\1 0"      . "window-by-prompt"))
              which-key-replacement-alist))
    #+END_SRC

*** xwin
    #+BEGIN_SRC emacs-lisp
      (use-package x-win
        :straight (x-win :type built-in)
        :defer t
        :config
        (advice-add 'emacs-session-filename :override
                    (defun mohkale-emacs-session-filename (session-id)
                      (concat (var! "x-sessions/session.") session-id))))
    #+END_SRC

*** xref
    cross reference keywords across a number of different backends.

    #+BEGIN_SRC emacs-lisp
      (use-package xref
        :defer t
        :init
        (leader/set-keys
          "jb" 'xref-pop-marker-stack
          "jr" 'xref-find-references
          "js" 'xref-find-apropos
          "jg" 'xref-find-definitions
          ;; "axw" 'xref-find-definitions-other-window
          ;; "axf" 'xref-find-definitions-other-frame
          )

        ;; erase global xref bindings
        (general-define-key
          "M-."   nil ; xref-find-definitions
          "M-,"   nil ; xref-pop-marker-stack
          "M-?"   nil ; xref-find-references
          "C-M-." nil ; xref-find-apropos
          )

        (general-define-key
          :states 'motion
          "[x" 'xref-pop-marker-stack)

        :config
        (evil-set-initial-state 'xref--xref-buffer-mode 'motion)

        (general-define-key
          :keymaps 'xref--xref-buffer-mode-map
          :states 'motion
          "j" 'xref-next-line
          "k" 'xref-prev-line
          "RET" 'xref-goto-xref
          "M-RET" 'xref-show-location-at-point
          "TAB" 'xref-quit-and-goto-xref)

        (leader/set-keys-for-major-mode 'xref--xref-buffer-mode
          "s" 'xref-query-replace-in-results))
    #+END_SRC

*** yasnippet
    yet another snippets tool... but amazingly powerful. :-P
    See the snippet [[https://joaotavora.github.io/yasnippet/snippet-development.html#org6796ab7][dev]] guide at.

**** yasnippet
     #+BEGIN_SRC emacs-lisp
       (use-package yasnippet
         :ensure t
         :defer  load-me-now-duration
         :delight (yas-minor-mode "YAS")
         :commands (yas-expand
                    yas-new-snippet
                    yas-visit-snippet-file)
         :init
         (leader/set-keys
           "iSn" 'yas-new-snippet
           "fS" 'yas-visit-snippet-file)

         (general-define-key
           :states 'insert
           "C-i" 'yas-expand
           "M-I" 'yas-expand)

         :config
         (setq yas-triggers-in-field t
               yasnippet-snippets-dir (etc! "snippets/")
               yas-snippet-dirs '(yasnippet-snippets-dir))

         (yas-global-mode 1)

         (general-define-key
           :keymaps 'yas-keymap
           "<C-return>" 'yas-next-field
           "<C-M-return>" 'yas-prev-field
           "C-l" 'yas-next-field
           "C-h" 'yas-prev-field)

         (leader/set-keys-for-major-mode 'snippet-mode
           "m" 'yas-load-snippet-buffer-and-close
           "l" 'load-snippet-buffer
           "t" 'yas-tryout-snippet))
     #+END_SRC

**** licenses
     use yas to generate and insert license headers for the current buffer.

     #+BEGIN_SRC emacs-lisp
       (use-package mohkale-license
         :defer t
         :commands (insert-license
                    license-reload-profile)
         :init
         (leader/set-keys
           "ia" 'insert-license))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale-license.el
       (require 'yasnippet)

       (defvar license-dir (etc! "licenses")
         "directory in which to find license snippets.")

       (defvar license-dont-be-evil nil
         "append don't be evil clause to licenses.
       see [[https://en.wikipedia.org/wiki/Douglas_Crockford][Douglas Crockford]].")

       (defvar license-last-inserted nil
         "the fully populated last inserted license template.")

       (defun license-load-profile (&optional file)
         (or file
             (setq file (join-path license-dir ".profile")))

         (when (file-exists-p file)
           (with-temp-buffer
             (insert-file-contents file)
             (read (current-buffer)))))

       ;; load initial profile
       (defvar license-profile
         (ignore-errors
           (license-load-profile))
         "alist setting properties to auto insert in a license.
       properties include: last-name, first-name")

       (defun license-get-prop (prop &optional default)
         (or (cdr (assoc prop license-profile))
             default))

       (cl-defun license-get-name
           (&optional default (profile license-profile))
         (let ((first-name (license-get-prop 'first-name))
               (last-name  (license-get-prop 'last-name)))
           (cond
            ((and first-name last-name)
             (concat first-name " " last-name))
            (first-name first-name)
            (last-name last-name)
            (t default))))

       ;;;###autoload
       (defun license-reload-profile ()
         "set `license-profile' by rereading the profile file."
         (interactive)
         (setq license-profile (license-load-profile)))

       (defun license--licenses (&optional dir)
         "return an alist of (basename . file) for all .license files in DIR.
       Where DIR defaults to the current working directory (`default-directory')."
         (cl-loop
          for file in (file-expand-wildcards
                       (concat (if dir
                                   (concat dir "/")
                                 default-directory)
                               "*.license"))
          collect (cons (file-name-base file) file)))

       (defun license--read-license ()
         (let ((licenses (license--licenses license-dir))
               license)
           (when (zerop (length licenses))
             (error "no licenses found in dir: %s" default-directory))

           (if (eq 1 (length licenses))
               (setq license (car licenses))
             (ivy-read "License: "
                       licenses
                       :require-match t
                       :preselect (when license-last-inserted
                                    (car license-last-inserted))
                       :action (lambda (x) (setq license x))))

           (with-temp-buffer
             (insert-file-contents (cdr license))
             (cons (car license)
                   (buffer-substring (point-min) (point-max))))))

       (cl-defmacro with-temp-buffer-and-same-vars ((&rest vars) &rest body)
         "store the values of VARS in current buffer, and then create a
       temp buffer reassigning the values of VARS and then invoking BODY."
         (let* ((current-vars
                 (cl-loop with name = nil
                          for var in vars
                          do (setq name (symbol-name var))
                          collect (list (intern (concat "-current-" name))
                                        var)))
                (assign-vars
                 (cl-loop for var in current-vars
                          collect (list (nth 1 var) (car var)))))
           `(let ,current-vars
              (with-temp-buffer
                (let ,assign-vars
                  ,@body)))))
       (put 'with-temp-buffer-and-same-vars 'lisp-indent-function 'defun)

       (defun license--comment-template (template &optional prefix)
         (with-temp-buffer-and-same-vars
             (comment-start comment-end comment-style
              comment-multi-line comment-add comment-continue)
           (insert template)
           (comment-region (point-min) (point-max) prefix)
           (buffer-substring (point-min) (point-max))))

       ;;;###autoload
       (defun insert-license (&optional prefix)
         "insert a license from the known license list.
       with PREFIX, repeats insertion of the last inserted license."
         (interactive "P")
         (let* ((license
                 (if (and prefix license-last-inserted)
                     license-last-inserted
                   (license--read-license)))
                (comment-multi-line t))
           (yas-expand-snippet
            (license--comment-template (cdr license))
            nil nil
            '((yas-indent-line 'fixed)))

           (setq license-last-inserted license)))

       (provide 'mohkale-license)
     #+END_SRC

***** Types
     :PROPERTIES:
     :header-args+: :shebang :comments none
     :END:

      #+BEGIN_SRC snippet :tangle etc/licenses/GPL-2.0.license
        Copyright (C) `(format-time-string "%Y")`  ${1:`(capitalize (license-get-name "name"))`}

        This program is free software; you can redistribute it and/or
        modify it under the terms of the GNU General Public License
        as published by the Free Software Foundation; either version 2
        of the License, or (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program; if not, write to the Free Software
        Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
      #+END_SRC

      #+BEGIN_SRC snippet :tangle etc/licenses/GPL-3.0.license
        Copyright (C) `(format-time-string "%Y")`  ${1:`(capitalize (license-get-name "name"))`}

        This file is part of ${2:this program}.

        $2 is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        $2 is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with $2.  If not, see <https://www.gnu.org/licenses/>.
      #+END_SRC

      #+BEGIN_SRC snippet :tangle etc/licenses/Apache-2.0.license
        Copyright `(format-time-string "%Y")` ${1:`(capitalize (license-get-name "name"))`}

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing, software
        distributed under the License is distributed on an "AS IS" BASIS,
        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        See the License for the specific language governing permissions and
        limitations under the License.
      #+END_SRC

      #+BEGIN_SRC snippet :tangle etc/licenses/Boost.license
                 Copyright ${1:`(capitalize (license-get-name "name"))`} `(format-time-string "%Y")` - ${2:`(format-time-string "%Y")`}.
        Distributed under the Boost Software License, Version 1.0.
           (See accompanying file LICENSE_1_0.txt or copy at
                 https://www.boost.org/LICENSE_1_0.txt)
      #+END_SRC

      #+BEGIN_SRC snippet :tangle etc/licenses/MIT.license
        Copyright (c) `(format-time-string "%Y")` ${1:`(capitalize (license-get-name "name"))`}

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
      #+END_SRC

      #+BEGIN_SRC snippet :tangle etc/licenses/ISC.license
        Copyright (c) `(format-time-string "%Y")` ${1:`(capitalize (license-get-name "name"))`} ${2:`(license-get-prop 'email "user@your.domain")`}

        Permission to use, copy, modify, and distribute this software for any
        purpose with or without fee is hereby granted, provided that the above
        copyright notice and this permission notice appear in all copies.

        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
        WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
        MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
        ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
        WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
        ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
        OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
      #+END_SRC

      #+BEGIN_SRC snippet :tangle etc/licenses/BSD.license
        Copyright (c) `(format-time-string "%Y")` ${1:`(capitalize (license-get-name "name"))`}

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions
        are met:
        1. Redistributions of source code must retain the above copyright
           notice, this list of conditions and the following disclaimer.
        2. Redistributions in binary form must reproduce the above copyright
           notice, this list of conditions and the following disclaimer in the
           documentation and/or other materials provided with the distribution.

        THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS \`\`AS IS'' AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        SUCH DAMAGE.
      #+END_SRC

      #+BEGIN_SRC snippet :tangle etc/licenses/BSD-3c.license
        Copyright (c) `(format-time-string "%Y")` ${1:`(capitalize (license-get-name "name"))`}

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions
        are met:
        1. Redistributions of source code must retain the above copyright
           notice, this list of conditions and the following disclaimer.
        2. Redistributions in binary form must reproduce the above copyright
           notice, this list of conditions and the following disclaimer in the
           documentation and/or other materials provided with the distribution.
        3. Neither the name of the author nor the names of its contributors may
           be used to endorse or promote products derived from this software

        THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS \`\`AS IS'' AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        SUCH DAMAGE.
      #+END_SRC

**** auto-yasnippet
     allows you to create dynamic/in-place snippets and repeatedly execute them.

     #+BEGIN_SRC emacs-lisp
       (use-package auto-yasnippet
         :ensure t
         :defer  t
         :init
         (leader/set-keys
           "iS"  "auto-yasnippet"
           "iSc" 'aya-create
           "iSe" 'aya-expand
           "iSw" 'aya-persist-snippet)

         (general-define-key
           :states 'insert
           "M-i" 'aya-expand))
     #+END_SRC

*** ycmd
**** ycmd-mode
     #+BEGIN_SRC emacs-lisp
       (use-package ycmd
         :ensure t
         :defer  t
         :delight "YCMD"
         :hook (ycmd-mode . ycmd-eldoc-setup)
         :config
         ;; NOTE to enable ycmd completion, hook ycmd-mode into any desired
         ;;      buffers and include company-ycmd in the company backends for
         ;;      the mode.

         (setq ycmd-global-config (expand-file-name "~/.ycmd-config")
               ycmd-startup-timeout 10
               ycmd-server-command `("python3" "-u" ,(expand-file-name "~/.vim/plugged/YouCompleteMe/third_party/ycmd/ycmd"))
               mohkale-ycmd-map (make-sparse-keymap))

         ;; (ycmd-toggle-force-semantic-completion)

         (leader/with-prefix mohkale--server-leader-key
           (leader/set-keys-for-mode 'ycmd-mode
             ""  "ycmd"
             "y" 'ycmd-mode
             "Y" 'global-ycmd-mode
             "n" 'ycmd-open
             "k" 'ycmd-close
             "v" 'ycmd-version
             "b" 'ycmd-parse-buffer
             "c" 'ycmd-load-conf-file
             "C" 'ycmd-clear-compilation-flag-cache
             "s" 'ycmd-show-debug-info
             "d" 'ycmd-show-documentation
             "l" 'ycmd-toggle-log-enabled
             "r" 'ycmd-restart-semantic-server
             "t" 'ycmd-get-type
             "." 'ycmd-completer ;; completing-read all ycmd requests
             "SPC" 'ycmd-toggle-force-semantic-completion
             "C-r" 'ycmd-refactor-rename
             "C-c" 'ycmd-display-completions

             "g"  "jump"
             "gg" 'ycmd-goto
             "gG" 'ycmd-goto-imprecise
             "gt" 'ycmd-goto-type
             "gd" 'ycmd-goto-definition
             "gD" 'ycmd-goto-declaration
             "gr" 'ycmd-goto-references
             "gi" 'ycmd-goto-include
             "gI" 'ycmd-goto-implementation)))
     #+END_SRC

**** company-ycmd
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'ycmd
         (use-package company-ycmd
           :ensure t
           :defer  t))
     #+END_SRC

**** flycheck-ycmd
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'ycmd
         (use-package flycheck-ycmd
           :ensure t
           :defer  t
           :hook (ycmd-mode . flycheck-ycmd-setup)))
     #+END_SRC

*** vc
    #+BEGIN_SRC emacs-lisp
      (use-package vc
        :defer t
        :commands (vc-annotate              ;; history of current file
                   vc-create-tag
                   vc-delete-file
                   vc-diff                  ;; diff current file
                   vc-dir                   ;; status of directory
                   vc-ediff                 ;; ediff current file
                   vc-ignore                ;; prompt and exclude file
                   vc-log-incoming          ;; log for pull commits
                   vc-log-outgoing          ;; log for push commits
                   vc-merge
                   vc-next-action           ;; makes a commit... annoyingly named
                   vc-print-log             ;; log of commits affecting current file
                   vc-print-root-log        ;; log of all commits in project
                   vc-push
                   vc-region-history        ;; log of commits affecting region in file
                   vc-register              ;; add file
                   vc-retrieve-tag
                   vc-revert                ;; undo changes to working files... permenently
                   vc-revision-other-window ;; view file in previous tag/commit
                   vc-root-diff
                   vc-switch-backend        ;; not using git... for shame :P
                   vc-update-change-log)
        :init
        (leader/with-prefix leader-diff-mode-prefix
          (leader/set-keys
            ;; "=v" 'vc-ediff
            "v" 'vc-diff))

        (push 'vc-annotate-mode whitespace-exempt-modes)
        (push 'vc-git-log-view-mode whitespace-exempt-modes)

        (leader/with-prefix "g"
          (leader/set-keys
            "a" 'vc-annotate
            "r" 'vc-revision-other-window
            "=" 'vc-root-diff
            "v" 'vc-region-history
            "l" 'vc-print-log
            "L" 'vc-print-root-log
            "R" 'vc-rename-file
            "u" 'vc-revert
            "#" 'vc-create-tag
            "d" 'vc-dir))

        :config
        (require 'vc-git) ;; supported

        (advice-add 'vc-region-history :after (lambda (&rest args)
                                                (when (evil-visual-state-p)
                                                  (evil-exit-visual-state))))

        (setq vc-ignore-dir-regexp
              (format "%s\\|%s"
                      vc-ignore-dir-regexp
                      tramp-file-name-regexp))

        ;;; annotations
        ;; pops up a buffer showing the most recent changes for every line
        ;; in the current file alongside the commit which made those changes.
        (evil-set-initial-state 'vc-annotate-mode 'motion)

        (general-define-key
          :states  'motion
          :keymaps 'vc-annotate-mode-map
          "gj" 'vc-annotate-prev-revision ;; older revisions
          "gk" 'vc-annotate-next-revision ;; newer revisions
          "C-t" 'vc-annotate-toggle-annotation-visibility
          "RET" 'vc-annotate-goto-line

          "d" 'vc-annotate-show-diff-revision-at-line
          "D" 'vc-annotate-show-changeset-diff-revision-at-line
          "t" 'vc-annotate-toggle-annotation-visibility)

        (leader/set-keys-for-major-mode 'vc-annotate-mode
          "m"     'vc-next-action
          "l"     'vc-annotate-show-log-revision-at-line
          "d"     'vc-annotate-show-diff-revision-at-line
          "D"     'vc-annotate-show-changeset-diff-revision-at-line
          "t"     'vc-annotate-toggle-annotation-visibility

          "g"     "goto"
          "gg"    'vc-annotate-goto-line
          "gc"    'vc-annotate-revision-at-line
          "gp"    'vc-annotate-revision-previous-to-line
          "gl"    'vc-annotate-show-log-revision-at-line
          "gG"    'vc-annotate-working-revision
          "g SPC" 'vc-annotate-working-revision)

        ;;; vc-directory
        ;; check status of files for an entire directory
        (evil-set-initial-state 'vc-dir-mode 'motion)

        (general-define-key
          :states  'motion
          :keymaps 'vc-dir-mode-map

          "a" 'vc-register ;; git add FILE
          "d" 'vc-diff
          "=" 'vc-diff
          "Q" 'vc-dir-kill-dir-status-process
          "i" 'vc-dir-ignore
          "x" 'vc-dir-kill-line

          ;; vc-dir-search
          "C-s" 'vc-dir-isearch-regexp
          "M-s" 'vc-dir-query-replace-regexp

          "A" 'vc-dir-mark-all-files
          "m" 'vc-dir-mark
          "U" 'vc-dir-unmark-all-files
          "u" 'vc-dir-unmark
          ;; "t" 'vc-dir-toggle-mark ;; mouse event
          "<backspace>" 'vc-dir-unmark-file-up

          "p" 'vc-pull
          "P" 'vc-push

          "o"   'vc-dir-display-file
          "RET" 'vc-dir-find-file

          "gj" 'vc-dir-next-line
          "gk" 'vc-dir-previous-line
          "M-j" 'vc-dir-next-directory
          "M-k" 'vc-dir-previous-directory)

        (leader/set-keys-for-major-mode 'vc-dir-mode
          "i" 'vc-log-incoming
          "o" 'vc-log-incoming
          "l" 'vc-print-log
          "L" 'vc-print-root-log
          "D" 'vc-root-diff
          "d" 'vc-diff
          "h" 'vc-dir-hide-up-to-date
          "u" 'vc-update ;; don't understand
          "m" 'vc-next-action)

        ;;; history + log
        ;; despite being different modes and using different maps, theses both incorporate
        ;; basically the same functions to accomplish the same things, so use the same config
        ;; for both of them.
        (dolist (tuple '((vc-git-region-history-mode . vc-git-region-history-mode-map)
                         ;; opens a log buffer showing all the commits affecting the highlighted
                         ;; region in the current file. It also shows the diffs for each commit.
                         (vc-git-log-view-mode       . vc-git-log-view-mode-map)
                         ;; shows all the previous commits alongside their commit messages
                         ))
          (let ((mode (car tuple))
                (kmap (cdr tuple)))
            (evil-set-initial-state mode 'motion)

            (general-define-key
              ;;; WARN unknown functions
              ;;    * log-view-modify-change-comment
              :states  'motion
              :keymaps kmap

              "q" nil
              "d" 'log-view-diff
              "=" 'log-view-diff
              "o" 'log-view-find-revision ; open current file at current commit

              "<return>" 'log-view-toggle-entry-display
              "<tab>"    'log-view-toggle-entry-display

              ;; move to next message, then reallign to top
              ;; (kbd "C-j") (lambda! (log-view-msg-next)
              ;;               (call-interactively 'evil-scroll-line-to-top))
              "gj" 'log-view-msg-next
              "gk" 'log-view-msg-prev

              "M-j" 'log-view-file-next
              "M-k" 'log-view-file-prev

              "gl" 'diff-hunk-next
              ;; TODO reallign diff to propper location on move down without trapping on a single diff
              ;; (kbd "M-j") (lambda! (diff-hunk-next)
              ;;               (call-interactively 'evil-scroll-line-to-top)
              ;;               (evil-previous-line 3))
              "gh" (lambda! (diff-hunk-prev) (evil-previous-line 3)))

            (leader/set-keys-for-major-mode mode
              "p" 'log-view-diff-changeset
              "a" 'log-view-annotate-version
              "m" 'log-view-toggle-mark-entry
              "s" 'diff-goto-source)))

        ;;; making commits... why name it log :P
        (dolist (tuple '((vc-git-log-edit-mode . vc-git-log-edit-mode-map)))
          (let ((mode (car tuple))
                (kmap (cdr tuple)))
            (evil-set-initial-state mode 'insert)

            (general-define-key
              :states  'normal
              :keymaps kmap
              "C-q" 'log-edit-kill-buffer
              "M-s" 'log-edit-next-comment
              "M-r" 'log-edit-previous-comment
              "C-s" 'log-edit-comment-search-forward
              "C-r" 'log-edit-comment-search-backward
              "M-0" 'evil-beginning-of-line)

            ;; (evil-redirect-digit-argument kmap "0" 'log-edit-beginning-of-line)

            (leader/set-keys-for-major-mode mode
              "d" 'log-edit-show-diff
              "f" 'log-edit-show-files
              "?" 'log-edit-mode-help
              "SPC" 'log-edit-done
              "DEL" 'log-edit-kill-buffer

              "i"  "insert"
              "ic" 'log-edit-insert-changelog
              "if" 'log-edit-insert-filenames
              "iC" 'log-edit-insert-changelog-entries
              "iT" 'log-edit-insert-cvs-rcstemplate
              "it" 'log-edit-insert-cvs-template
              "iF" 'log-edit-insert-filenames-without-changelog
              "im" 'log-edit-insert-message-template

              "t"  "toggle"
              "ta" 'vc-git-log-edit-toggle-amend
              "ts" 'vc-git-log-edit-toggle-signoff))))
    #+END_SRC

**** smerge
     #+BEGIN_SRC emacs-lisp
       (use-package smerge-mode
         :straight (smerge-mode :type built-in)
         :defer t
         :init
         (leader/set-keys
           "gi" 'smerge-mode)

         :config
         (leader/with-prefix "g"
           (leader/set-keys-for-mode 'smerge-mode
             "j" 'smerge-next
             "k" 'smerge-prev
             "c" 'smerge-keep-current
             "m" 'smerge-keep-mine
             "o" 'smerge-keep-other))

         (general-define-key
           :states '(normal motion)
           :keymaps 'smerge-mode-map
           "]g" 'smerge-next
           "[g" 'smerge-prev))
     #+END_SRC


*** ztree
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package ztree
        :ensure t
        :defer  t
        :config
        (evil-set-initial-state 'ztree-mode 'motion)

        (general-define-key
          :states  'motion
          :keymaps 'ztree-mode-map
          "gr"    'ztree-refresh-buffer
          "j"     'ztree-next-line
          "k"     'ztree-previous-line
          "gh"    'ztree-move-up-in-tree
          "gl"    'ztree-next-line
          "RET"   'ztree-dir-open-dired-at-point
          "TAB"   'ztree-perform-action
          "M-TAB" 'ztree-perform-soft-action
          "DEL"   'ztree-move-up-in-tree)

        (leader/set-keys-for-major-mode 'ztree-mode
          "TAB" 'ztree-jump-side
          "n"   'ztree-dir-widen-to-parent
          "w"   'ztree-dir-narrow-to-dir
          "h"   'ztree-dir-toggle-show-filtered-files))
    #+END_SRC

*** hydra
    #+BEGIN_SRC emacs-lisp
      (use-package hydra
        :ensure t
        :defer  t
        :commands defhydra
        :config
        (setq lv-use-separator t))

      (use-package pretty-hydra
        :ensure t
        :defer  t)
    #+END_SRC

** languages
*** elisp
**** elisp-slime-nav
     #+BEGIN_SRC emacs-lisp
       (use-package elisp-slime-nav
         :ensure t
         :defer  t
         :hook (elisp-mode . elisp-slime-nav-mode)
         :config
         (leader/set-keys-for-major-mode 'emacs-lisp-mode
           "gp" 'elisp-slime-nav-find-elisp-thing-at-point
           "h" '("describe-symbol-at-point" . elisp-slime-nav-describe-elisp-thing-at-point)))
     #+END_SRC

**** evil-lisp-state
     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package evil-lisp-state
         :ensure t
         :defer  t
         :init
         (leader/set-keys-for-major-mode 'emacs-lisp-mode
           "el" 'lisp-state-eval-sexp-end-of-line
           "." 'lisp-state-toggle-lisp-state))
     #+END_SRC

**** pp
     #+BEGIN_SRC emacs-lisp
       (use-package pp
         :defer t
         :init
         (leader/with-prefix "k"
           (leader/set-keys
             "m" 'pp-macroexpand-last-sexp
             "M" 'pp-macroexpand-expression
             "x" 'pp-eval-last-sexp
             "X" 'pp-eval-expression))

         (with-eval-after-load 'elisp-mode
           (leader/set-keys-for-major-mode '(emacs-lisp-mode lisp-interaction-mode)
             "eM" 'pp-macroexpand-expression
             "em" 'pp-macroexpand-last-sexp
             "ex" 'pp-eval-last-sexp
             "eX" 'pp-eval-expression)))
     #+END_SRC

**** paredit
     #+BEGIN_SRC emacs-lisp
       (use-package paredit
         :ensure t
         :defer  t
         :hook (emacs-lisp-mode . paredit-mode)
         :config
         (general-define-key
           :keymaps 'paredit-mode-map
           "C-<up>"    nil
           "C-<down>"  nil
           "C-<left>"  nil
           "C-<right>" nil
           "C-("       nil
           "C-)"       nil)

         ;; M-( wraps the next argument in parentheses
         ;; M-) closes the current argument, trims any
         ;;     trailing whitespace and inserts a newline
         ;; M-" same as " but then trims whitespace and inserts a newline
         (general-define-key
           :keymaps 'paredit-mode-map
           :states 'insert
           "<delete>" 'paredit-backward-delete
           "M-<delete>" 'paredit-forward-delete
           "C-<delete>" 'paredit-backward-kill-word
           ;; "C-M-<delete>" 'paredit-forward-kill-word
           ;; damn you windows
           ;; just use paredit forward, then kill backward
           "C-M-k" 'paredit-kill ;; forward body
           "<return>" 'paredit-newline)

         (general-define-key
           :keymaps 'paredit-mode-map
           :states 'normal
           "gSh" '("splice-sexp-forward" . paredit-splice-sexp-killing-backward)
           "gSl" '("splice-sexp-backward" . paredit-splice-sexp-killing-forward))

         (general-define-key
           :keymaps 'paredit-mode-map
           :states '(normal insert)
           ;; movement
           ;; "C-h" 'backward-char
           ;; "C-l" 'forward-char
           "C-j" 'paredit-newline
           "C-M-h" 'paredit-backward
           "C-M-l" 'paredit-forward
           "C-<left>" 'paredit-backward
           "C-<right>" 'paredit-forward

           ;; transformation
           ;;; kill or wrap surrounding parentheses
           "C-S-K" 'paredit-splice-sexp
           "C-S-J" 'paredit-wrap-round
           ;;; include previous or next arguments in current sexp
           "C-S-H" 'paredit-backward-slurp-sexp
           "C-S-L" 'paredit-forward-slurp-sexp
           ;;; exclude previous or next arguments from current sexp
           "C-M-S-H" 'paredit-backward-barf-sexp
           "C-M-S-L" 'paredit-forward-barf-sexp

           "C-S-S" 'paredit-split-sexp
           "C-S-M-J" 'paredit-join-sexps ;; immeadiately with expression b4 point

           ;; splice next argument after point, deleting
           ;; arguments both before and after it
           ;; a cool shortcut, but not really necessary
           ;; "M-r"   'paredit-raise-sexp
           ))
     #+END_SRC

**** elisp-mode
     #+BEGIN_SRC emacs-lisp
       (use-package elisp-mode
         :straight (elisp-mode :type built-in)
         :defer t
         :init
         (add-hook 'emacs-lisp-mode-hook #'electric-pair-mode)

         (leader/with-prefix "k"
           (leader/set-keys
             "e" 'eval-last-sexp
             "k" 'eval-last-sexp
             "(" 'eval-print-last-sexp
             ")" 'eval-replace-last-sexp))

         :config
         ;; show lambda as an actual lambda symbol... pretty cool, if I do say
         ;; so myself.
         (configure-presym! '(lisp-interaction-mode emacs-lisp-mode org-mode)
           "lambda"  ?λ
           "lambda!" "λ!")

         (defun eval-replace-last-sexp (&optional prefix)
           "evaluate then replace the preceding sexp"
           (interactive "p")
           (let* ((sexp (preceding-sexp))
                  (value (eval sexp)))
             (kill-sexp -1)
             (insert (format (if prefix "%s" "%S") value))))

         (evil-set-initial-state 'inferior-emacs-lisp-mode 'emacs) ;; ielm

         ;;   (defun elisp-transcript ()
         ;;     ;; source https://www.emacswiki.org/emacs/LispInteractionMode
         ;;     "Make an Emacs Lisp interactive transcript.
         ;; In a new buffer, make a transcript of the Emacs Lisp code by
         ;; evaluating each line and printing the result under it (/a la/
         ;;   TODO fix last sexp in the buffer isn't transcripted
         ;;   `eval-print-last-sexp')."
         ;;     (interactive)
         ;;     (let* ((eval-expression-print-length nil)
         ;;            (eval-expression-print-level nil)
         ;;            (input-buffer (current-buffer))
         ;;            (dest-buffer (get-buffer-create (concat "*Transcript for "
         ;;                                                    (buffer-name input-buffer)
         ;;                                                    "*"))))
         ;;       (save-current-buffer
         ;;         (set-buffer dest-buffer)
         ;;         (lisp-interaction-mode)
         ;;         (delete-region (point-min) (point-max))
         ;;         (insert-buffer-substring input-buffer) ;; `slurp!'
         ;;         (goto-char (point-min))
         ;;         (forward-sexp 1)
         ;;         (while (> (point-max) (point))
         ;;           (condition-case err
         ;;               (evil-adjust-eval-print-last-sexp)
         ;;             (error
         ;;              (insert (format "%s" err))
         ;;              (newline)))
         ;;           (forward-sexp 1)))
         ;;       (display-buffer dest-buffer)))

         (push '(emacs-lisp-mode . 2) mohkale-indent-config)
         (push '(lisp-interaction-mode . 2) mohkale-indent-config)

         (let ((lisp-modes '(emacs-lisp-mode lisp-interaction-mode)))
           (leader/set-keys-for-major-mode lisp-modes
             "'" 'ielm
             "c" 'emacs-lisp-byte-compile
             "i" 'indent-sexp

             ;; eval
             "e"  "eval"
             "eb" 'eval-buffer
             "ee" 'eval-last-sexp
             "eE" 'eval-replace-last-sexp
             "ef" 'eval-defun
             "er" 'eval-region
             ;; "et" 'elisp-transcript

             ;; jump
             "g" '("goto-definition" . xref-find-definitions)
             "G" '("goto-definition-other-window" . xref-find-definitions-other-window)

             ;; tests
             "t" 'ert
             "T" 'ert-run-tests-interactively))

         (general-define-key
           :keymaps 'lisp-interaction-mode-map
           "C-j" nil
           "C-(" 'eval-print-last-sexp
           "C-)" 'eval-replace-last-sexp))
     #+END_SRC

*** python
**** company-anaconda
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'python
         (use-package company-anaconda
           :ensure t
           :defer  t
           :commands (company-anaconda)
           :init
           (company/configure-mode (python-mode :major t)
             company-anaconda)))
     #+END_SRC

**** anaconda
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'python
         (use-package anaconda-mode
           :ensure t
           :defer  t
           :hook ((python-mode . enable-anaconda-mode+)
                  (anaconda-mode . anaconda-eldoc-mode))
           :commands enable-anaconda-mode+
           :config
           (setq anaconda-mode-installation-directory (var! "anaconda/"))

           (defun enable-anaconda-mode+ ()
             "run anaconda-mode unless you're in a remote file."
             (unless (file-remote-p (buffer-file-name))
               (anaconda-mode +1)))

           (leader/set-keys-for-major-mode 'python-mode
             "TAB" 'anaconda-mode-complete
             "hh" 'anaconda-mode-show-doc

             "ga" 'anaconda-mode-find-assignments
             "gr" 'anaconda-mode-find-references
             "gg" 'anaconda-mode-find-definitions
             "gA" 'anaconda-mode-find-assignments-other-window
             "gR" 'anaconda-mode-find-references-other-window
             "gG" 'anaconda-mode-find-definitions-other-window
             "g M-a" 'anaconda-mode-find-assignments-other-frame
             "g M-r" 'anaconda-mode-find-references-other-frame
             "g M-g" 'anaconda-mode-find-definitions-other-frame)))
     #+END_SRC

**** pyimport
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'python
         (use-package pyimport
           :ensure t
           :defer  t
           :init
           (leader/set-keys-for-major-mode 'python-mode
             "i"  "imports"
             "ii" 'pytimport-remove-unused
             "iu" 'pyimport-insert-missing)))
     #+END_SRC

**** py-isort
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'python
         (use-package py-isort
           :ensure t
           :defer  t
           :init
           (leader/set-keys-for-major-mode 'python-mode
             "i"  "imports"
             "is" 'py-isort-buffer
             "ir" 'py-isort-region)))
     #+END_SRC

**** pip-requirements
     #+BEGIN_SRC emacs-lisp
       (use-package pip-requirements
         :ensure t
         :defer  t
         :mode ("^requirements\\.txt$" . pip-requirements-mode)
         :commands pip-requirements-mode)
     #+END_SRC

**** yapfify
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'python
         (use-package yapfify
           :ensure t
           :defer  t
           :init
           (leader/set-keys-for-major-mode 'python-mode
             "y" 'yapfify-buffer
             "Y" 'yapfify-region)))
     #+END_SRC

**** python-mode
     #+BEGIN_SRC emacs-lisp
       (use-package python
         :straight (python :type built-in)
         :defer t
         :hook (python-mode . flycheck-mode)
         :init
         (defalias 'python-repl 'run-python)
         :config
         (evil-set-initial-state 'inferior-python-mode 'emacs)
         (setq python--prettify-symbols-alist nil)

         (configure-presym! 'python-mode
           "lambda" ?λ)

         (defun python-shell-calculate-command ()
           "python3 -i")

         (general-define-key
           :states 'insert
           :keymaps 'python-mode-map
           "TAB"   'tab-to-tab-stop
           "<tab>" 'tab-to-tab-stop)

         (leader/set-keys-for-major-mode 'python-mode
           "r" 'run-python ;; REPL
           "R" 'python-shell-switch-to-shell
           "m" 'python-mark-defun
           "v" 'python-check
           "s" 'python-describe-at-point
           ;; unbound: python-nav-forward-sexp[-safe]
           ;;          python-nav-backward-sexp[-safe]

           "n"  "navigate"
           "nh" 'python-nav-forward-statement
           "nj" 'python-nav-forward-block
           "nk" 'python-nav-backward-block
           "nl" 'python-nav-backward-statement
           "n(" 'python-nav-backward-up-list
           "n)" 'python-nav-up-list
           "n0" 'python-nav-beginning-of-block
           "n$" 'python-nav-end-of-block
           "nm" 'python-nav-if-name-main

           "n C-0" 'python-nav-beginning-of-statement
           "n C-$" 'python-nav-end-of-statement
           "n M-j" 'python-nav-forward-defun
           "n M-k" 'python-nav-backward-defun
           ;; "n M-0" 'python-nav-beginning-of-defun
           "n M-$" 'python-nav-end-of-defun

           "h"  "help"
           "hp" 'python-eldoc-at-point

           "e"  "eval/exec"
           "ed" 'python-shell-send-defun
           "eb" 'python-shell-send-buffer
           "ef" 'python-shell-send-file
           "er" 'python-shell-send-region
           "ec" 'python-shell-send-string))
     #+END_SRC

*** ruby
    #+BEGIN_SRC emacs-lisp
      (defvar mohkale-ruby-package 'ruby ;; (if (eq system-type 'gnu/linux) 'enh-ruby 'ruby)
        "determine which mode to use for ruby... enh-ruby is really slowing everything down on windows
      also, for some reason, creating a symlink to ruby on cygwin makes the process unrunnable from emacs,
      it just spits out exec error... my loathing towards windows grows :P
      TODO test out performance of enhanced ruby on linux.")

      (defvar mohkale-ruby-use-lsp 'projectile
        "whether to use `lsp-mode' with ruby-mode.
      set to 'projectile to only activate if in a projectile project with a Gemfile.

      NOTE solargraph... and basically every other ruby completion framework is
           useless if your project doesn't have a Gemfile... that means for simple
           scripts like ~/.emacs.d/bin/tangle, solargraph won't be of any use.
      ")

      (setq mohkale-ruby-mode      (intern (concat (symbol-name mohkale-ruby-package) "-mode"))
            mohkale-ruby-mode-hook (intern (concat (symbol-name mohkale-ruby-mode)    "-hook")))

      (push (cons mohkale-ruby-mode 2) mohkale-indent-config)

      (leader/set-keys "Mr" mohkale-ruby-mode)
    #+END_SRC

**** ruby
     #+BEGIN_SRC emacs-lisp
       (use-package ruby-mode
         :if (eq mohkale-ruby-package 'ruby)
         :straight (ruby :type built-in)
         :defer t
         :mode ("\\.rb$" . ruby-mode)
         :interpreter "ruby"
         :config
         (leader/set-keys-for-major-mode 'ruby-mode
           "'" 'ruby-toggle-string-quotes
           "{" 'ruby-toggle-block))
     #+END_SRC

**** enhanced ruby
     #+BEGIN_SRC emacs-lisp
       (use-package enh-ruby-mode
         :if (eq mohkale-ruby-package 'enh-ruby)
         :ensure t
         :defer  t
         :mode ("\\.rb$" . enh-ruby-mode)
         :interpreter "ruby"
         :hook (enh-ruby-mode . flycheck-mode)
         :config
         (setq enh-ruby-deep-indent-paren nil
               enh-ruby-hanging-paren-deep-indent-level 2)

         (leader/set-keys-for-major-mode 'enh-ruby-mode
           "m" 'enh-ruby-mark-defun
           "f" 'enh-ruby-find-file
           "e" 'enh-ruby-find-error

           "i"  "insert"
           "ie" 'enh-ruby-insert-end
           "it" 'enh-ruby-indent-exp
           "i <tab>" 'enh-ruby-indent-exp

           "n"  "navigate"
           "nh" 'enh-ruby-backward-sexp
           "nl" 'enh-ruby-forward-sexp
           "nk" 'enh-ruby-up-sexp
           "n0" 'enh-ruby-beginning-of-block
           "n$" 'enh-ruby-end-of-block
           "n M-0" 'enh-ruby-beginning-of-defun
           "n M-$" 'enh-ruby-end-of-defun)

         (general-define-key
           :keymaps 'enh-ruby-mode-map
           "{" nil
           "}" nil)

         (general-define-key
           :keymaps 'enh-ruby-mode-map
           :states 'insert
           "{" 'enh-ruby-electric-brace
           "}" 'enh-ruby-electric-brace)

         (general-define-key
           :keymaps 'enh-ruby-mode-map
           :states '(normal insert)
           "C-{" 'enh-ruby-toggle-block))
     #+END_SRC

**** solargraph
     language server implementation for ruby.

     #+BEGIN_SRC emacs-lisp
       (add-hook mohkale-ruby-mode-hook
                 (defun ruby-enable-lsp-in-projects (&rest args)
                   (when (eq mohkale-ruby-use-lsp 'projectile)
                     (when-project-has-file-p "Gemfile"
                       (call-interactively 'lsp)))))
     #+END_SRC

**** robe
     WARN robe won't work unless your project contains some identifying gemfile
          so if your not getting any completion help, that's probably why.

     #+BEGIN_SRC emacs-lisp :tangle no
       (with-eval-after-load mohkale-ruby-mode
         (use-package robe
           :ensure t
           :defer  t
           :init
           (add-hook mohkale-ruby-mode-hook
                     (defun ruby-robe-enable-in-projects (&rest args)
                       (unless (eq mohkale-ruby-use-lsp 'projectile)
                         (when-project-has-file-p "Gemfile"
                           (call-interactively 'robe-mode)))))

           :config
           (company/configure-mode (robe-mode)
             company-robe)

           (leader/set-keys-for-major-mode mohkale-ruby-mode
             "rs" 'robe-start ;; REPL
             "h" 'robe-doc

             ;; jumping
             "SPC" 'robe-ask

             "g"  "goto"
             "gg" 'robe-jump
             "gm" 'robe-jump-to-module)))
     #+END_SRC

**** inf-ruby
     #+BEGIN_SRC emacs-lisp
       (use-package inf-ruby
         :ensure t
         :defer  t
         :init
         (defalias 'ruby-repl 'inf-ruby)
         (push 'inf-ruby-mode whitespace-exempt-modes)

         (leader/set-keys-for-major-mode mohkale-ruby-mode
           "r"  "REPL"
           "rr" 'inf-ruby
           "rg" 'inf-ruby-console-gem
           "rz" 'inf-ruby-console-zues
           "ra" 'inf-ruby-console-auto
           "rR" 'inf-ruby-console-rails
           "rk" 'inf-ruby-console-racksh
           "rc" 'inf-ruby-console-script
           "rh" 'inf-ruby-console-hanami))
     #+END_SRC

**** ruby-tools
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load mohkale-ruby-mode
         (use-package ruby-tools
           :ensure t
           :defer  t
           :init
           (add-hook mohkale-ruby-mode-hook #'ruby-tools-mode)

           :config
           (leader/set-keys-for-major-mode mohkale-ruby-mode
             "i"  "insert"
             "i:" 'ruby-tools-to-symbol
             "i{" 'ruby-tools-interpolate
             "i <backspace>" 'ruby-tools-clear-string
             "i\"" 'ruby-tools-to-double-quote-string
             "i'" 'ruby-tools-to-single-quote-string)))
     #+END_SRC

**** bundle
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load mohkale-ruby-mode
         (use-package bundler
           :ensure t
           :defer  t
           :init
           (leader/set-keys-for-major-mode mohkale-ruby-mode
             "b"  "bundler"
             "rb" 'bundle-console
             "bf" 'bundle-open
             "bi" 'bundle-install
             "bu" 'bundle-update
             "bc" 'bundle-check)))
     #+END_SRC

**** ruby-electric
     #+begin_src emacs-lisp
       (with-eval-after-load mohkale-ruby-mode
         (use-package ruby-electric
           :ensure t
           :defer  t
           :init
           (add-hook mohkale-ruby-mode-hook #'ruby-electric-mode)

           :config
           ;;; why poison the standard ruby map instead of using ruby-electric-mode-map?
           (defun ruby-electric-setup-keymap ()
             (general-define-key
               :keymaps 'ruby-mode-map
               " " 'ruby-electric-space
               ;; "{" 'ruby-electric-curlies
               "(" 'ruby-electric-matching-char
               "[" 'ruby-electric-matching-char
               ;; "\"" 'ruby-electric-quote
               ;; "\'" 'ruby-electric-quote
               "|" 'ruby-electric-bar
               (kbd "RET") 'ruby-electric-return
               ;; (kbd "C-j") 'ruby-electric-return
               ;; (kbd "C-m") 'ruby-electric-return
               "}" 'ruby-electric-close-matching-char
               ")" 'ruby-electric-close-matching-char
               "]" 'ruby-electric-close-matching-char))))
     #+end_src

*** HTML
**** web-mode
     #+BEGIN_SRC emacs-lisp
       (use-package web-mode
         :ensure t
         :defer  t
         :mode "\\.erb\\|\\.html"
         :init
         (leader/set-keys "Mh" 'web-mode)

         :config
         (add-hook 'hack-local-variables-hook
                   (defun web-mode-fix-dirlocals+ (&rest _)
                     "see issue #1118."
                     (when (derived-mode-p major-mode 'web-mode)
                       (web-mode-guess-engine-and-content-type))))

         (general-define-key
           :keymaps 'web-mode-map
           :states 'normal
           "<tab>" 'web-mode-fold-or-unfold)

         (leader/set-keys-for-major-mode 'web-mode
           ;; unbound:
           ;;   * web-mode-buffer-highlight
           ;;   * web-mode-element-mute-blanks
           ;;   * web-mode-block-beginning
           ;;   * web-mode-block-end
           ;;   * web-mode-block-insert
           ;;   * web-mode-block-kill
           ;;   * web-mode-block-next
           ;;   * web-mode-block-previous
           ;;   * web-mode-block-select
           ;;   * web-mode-block-transpose
           ;;   * web-mode-navigate
           ;;
           ;; WARN the block commands don't seem to do anything

           ";"     'web-mode-comment-or-uncomment
           "f"     'web-mode-fold-or-unfold
           "l"     'web-mode-file-link
           "b"     'web-mode-element-close ; insert matching tag for body at point
           "M-r"   'web-mode-reload
           "<tab>" 'web-mode-buffer-indent
           "C-M-i" 'web-mode-snippet-insert
           ;; "tw" 'web-mode-whitespace-show

           ;; insert
           "i"  "insert"
           "ia" 'web-mode-attribute-insert
           "ip" 'web-mode-element-wrap ; wrap current element in a new element with name from prompt
           "ic" 'web-mode-element-clone
           "ie" 'web-mode-element-insert
           "ie" 'web-mode-element-insert-at-point ; converts word before point to tag

           ;; refactor/insert
           "r"  "refactor"
           "rs" 'web-mode-tag-attributes-sort
           "r(" 'web-mode-element-extract  ; add linebreak before every tag in body
           "r)" 'web-mode-element-contract ; collapse tag into a single line
           "rn" 'web-mode-dom-normalize
           "ra" 'web-mode-attribute-transpose
           "re" 'web-mode-element-transpose
           "rr" 'web-mode-element-rename
           "rf" 'web-mode-fold-or-unfold
           "rF" 'web-mode-element-children-fold-or-unfold ; collapse the children of current tags body, not body itself

           ;; delete
           "d"  "delete"
           "da" 'web-mode-attribute-kill
           "de" 'web-mode-element-kill
           "dp" 'web-mode-element-vanish ; delete element, but move body up a level instead of erasing it

           ;; DOM
           "D"  "DOM"
           "Da" 'web-mode-dom-apostrophes-replace
           "Ds" 'web-mode-dom-entities-replace
           "Dq" 'web-mode-dom-quotes-replace
           "D/" 'web-mode-dom-xpath
           ; shows the xpath of the current element

           "hd" 'web-mode-dom-errors-show
           "hj" 'web-mode-jshint

           ;; mark
           "m"  "mark"
           "mT" 'web-mode-tag-select
           ; only works while between <>
           "mt" 'web-mode-element-select
           "ma" 'web-mode-attribute-select
           "mb" 'web-mode-element-content-select
           "mm" 'web-mode-mark-and-expand

           ;; navigation
           "n"  "navigate"
           "n0" 'web-mode-element-beginning
           "n$" 'web-mode-element-end
           "nn" 'web-mode-tag-match
           "nh" 'web-mode-element-next
           "nj" 'web-mode-element-child
           "nk" 'web-mode-element-previous
           "nh" 'web-mode-element-parent
           ;; "nt" 'web-mode-dom-traverse

           "na"  "attributes"
           "na0" 'web-mode-attribute-beginning
           "na$" 'web-mode-attribute-end
           "nah" 'web-mode-attribute-previous
           "nal" 'web-mode-attribute-next

           "nt"  "tags"
           "nt0" 'web-mode-tag-beginning
           "nt$" 'web-mode-tag-end
           "nth" 'web-mode-tag-previous
           "ntl" 'web-mode-tag-next))
     #+END_SRC

**** emmet-mode
     #+BEGIN_SRC emacs-lisp
       (use-package emmet-mode
         :ensure t
         :defer  t
         :hook ((web-mode      . emmet-mode)
                (markdown-mode . emmet-mode))
         :config
         (general-define-key
           :keymaps 'emmet-mode-keymap
           "C-j" nil)

         (general-define-key
           :states 'insert
           :keymaps 'emmet-mode-keymap
           "C-i" 'emmet-expand-line
           ;; "TAB" 'emmet-expand-line
           "<tab>"   'emmet-next-edit-point
           "<S-tab>" 'emmet-prev-edit-point)

         (leader/with-major-mode-prefix
           (leader/set-keys-for-mode 'emmet-mode
             "e" "emmet"
             "." 'emmet-expand-line
             ;; "'" 'emmet-preview
             "ee" 'emmet-expand-line
             "ep" 'emmet-preview
             "ew" 'emmet-wrap-with-markup
             "en" 'emmet-next-edit-point
             "eN" 'emmet-prev-edit-point)))
     #+END_SRC

**** company-web
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'web-mode
         (use-package company-web
           :ensure t
           :defer  t
           :config
           (company/configure-mode (web-mode :major t)
             company-web-html company-yasnippet)))
     #+END_SRC

**** simple-httpd
     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package simple-httpd
         :ensure t
         :defer  t
         :config
         (setq httpd-root (var! "simple-httpd/"))
         (setq httpd-port 35343))
     #+END_SRC

**** web-beautify
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'web-mode
         (use-package web-beautify
           :ensure t
           :defer  t
           :init
           (leader/set-keys-for-major-mode 'web-mode
             "rb"  "beautify"
             "rbh" 'web-beautify-htlm
             "rbj" 'web-beautify-js
             "rbc" 'web-beautify-css)))
     #+END_SRC

*** org
    Yes, org mode is it's own language. Even if you don't think it is, it is :P

**** org-agenda
     #+BEGIN_SRC emacs-lisp
       (use-package org-agenda
         :straight (org-agenda :type built-in)
         :defer t
         :config
         (evil-set-initial-state 'org-agenda-mode 'motion)

         (leader/set-keys-for-major-mode 'org-agenda-mode
           "." 'hydra-org-agenda/body
           "A" 'org-agenda-append-agenda
           "C" 'org-agenda-columns

           ;;; filter/search
           "/"  "filter/search"
           "/c" 'org-agenda-filter-by-category
           "/e" 'org-agenda-filter-by-effort
           "//" 'org-agenda-filter-by-regexp
           ;; "/t" 'org-agenda-filter-by-tag
           "/:" 'org-agenda-filter-by-tag
           "/h" 'org-agenda-filter-by-top-headline
           "/R" 'org-agenda-filter-remove-all

           "/?" 'org-agenda-bulk-mark-regexp
           "/a" 'org-agenda-bulk-mark-all
           "/u" 'org-agenda-bulk-unmark-all

           ;;; clock/calendar/diary
           "c"  "clock/calendar"
           "cp" 'org-agenda-date-prompt
           "cc" 'org-agenda-clock-in
           "co" 'org-agenda-clock-out
           "cC" 'org-agenda-clock-out ; alias
           "ct" 'org-timer-set-timer
           "c M-c" 'org-agenda-convert-date

           ;;; agenda minor modes
           "m"  "modes"
           "ma" 'org-agenda-archives-mode
           "md" 'org-agenda-day-view
           "mc" 'org-agenda-clockreport-mode
           "mt" 'org-agenda-entry-text-mode
           "mf" 'org-agenda-follow-mode
           "ml" 'org-agenda-log-mode
           "mw" 'org-agenda-week-view
           "my" 'org-agenda-year-view
           "mm" 'org-agenda-month-view

           ;;; priorities
           "p"  "priority"
           "pp" 'org-agenda-priority
           "pu" 'org-agenda-priority-up
           "pd" 'org-agenda-priority-down)

         (general-define-key
           :keymaps 'org-agenda-mode-map
           :states  'motion
           ;;; globally useful
           [remap quit-window] 'org-agenda-exit
           "." 'org-agenda-goto-today
           "v" 'org-agenda-view-mode-dispatch
           "RET" 'org-agenda-goto
           "TAB" 'org-agenda-switch-to
           "M-c" 'org-agenda-clock-goto ; jumped to clocking task
           "C-t" 'org-agenda-todo
           "M-t" 'org-agenda-show-tags

           ;;; marking
           "C-<SPC>" 'org-agenda-bulk-mark
           "M-<SPC>" 'org-agenda-bulk-unmark
           "C-M-SPC" 'org-agenda-bulk-action

           ;;; undo/redo
           "C-r" 'org-agenda-redo
           "u"   'org-agenda-undo
           "gr"        'org-agenda-redo-all

           ;;; toggle displays
           "gm" 'org-agenda-phases-of-moon
           "C-l" 'org-agenda-log-mode
           "M-l" 'org-agenda-toggle-time-grid
           "M-h" 'org-agenda-holidays
           "M-s" 'org-agenda-sunrise-sunset

           ;; edit org items
           "M-e" 'org-agenda-set-effort
           "C-a" 'org-agenda-archive-default-with-confirmation

           ;;; notes and insertion
           "a"  'org-agenda-add-note
           "c"  'org-agenda-capture
           "gd" 'org-agenda-goto-date
           "gc" 'org-agenda-goto-calendar

           ;;; movement between lines
           ;;; NOTE org-next/prev-line is used by follow-mode
           "k"      'org-agenda-previous-line
           "j"      'org-agenda-next-line
           "<up>"   'org-agenda-previous-line ; alias
           "<down>" 'org-agenda-next-line     ; alias
           "C-j"    'org-agenda-next-item
           "C-k"    'org-agenda-previous-item

           ;;; move through time in blocks
           "f" 'org-agenda-later
           "F" 'org-agenda-earlier

           "C-f" 'org-agenda-follow-mode
           "M-f" 'org-agenda-recenterstates))
     #+END_SRC

**** org-bullets
     #+BEGIN_SRC emacs-lisp
       (use-package org-bullets
         :ensure t
         :defer  t
         :hook (org-mode . org-bullets-mode))
     #+END_SRC

**** org-link-edit
     #+BEGIN_SRC emacs-lisp
       (use-package org-link-edit
         :straight (org-link-edit :type built-in)
         :defer t
         :commands (org-link-edit-forward-slurp
                    org-link-edit-forward-barf
                    org-link-edit-backward-slurp
                    org-link-edit-backward-barf))
     #+END_SRC

**** org-link-minor-mode
     #+BEGIN_SRC emacs-lisp
       (use-package org-link-minor-mode
         :defer t
         :straight (org-link-minor-mode :type git :host github
                    :repo "seanohalpin/org-link-minor-mode")
         :hook ((text-mode . enable-org-link-minor-mode)
                (prog-mode . enable-org-link-minor-mode)
                (conf-mode . enable-org-link-minor-mode))
         :commands ace-link--org-link-minor-mode+
         :init
         (advice-add 'ace-link :around #'ace-link--org-link-minor-mode+)

         (defun enable-org-link-minor-mode (&rest _)
           (unless (derived-mode-p 'major-mode 'org-mode)
             (org-link-minor-mode +1)))

         :config
         (defun ace-link--org-link-minor-mode+ (func &rest args)
           (condition-case err
               (apply func args)
             (error
              (if (bound-and-true-p org-link-minor-mode)
                  (ace-link-org)
                (signal (car err) (cdr err)))))))
     #+END_SRC

**** org-toc
     #+BEGIN_SRC emacs-lisp
       (use-package toc-org
         :ensure t
         :defer  t
         ;; :hook (org-mode . toc-org-mode)
         )
     #+END_SRC

**** org-capture
     #+BEGIN_SRC emacs-lisp
       (use-package org-capture
         :straight (org-capture :type built-in)
         :defer t
         :commands doct
         :config
         (use-package doct
           :straight (doct :host github :repo "progfolio/doct" :branch "master")
           :init
           (setq doct-default-entry-type 'entry))

         (require 'mohkale-org-capture)

         (leader/with-major-mode-prefix
           (leader/set-keys-for-mode 'org-capture-mode
             "," 'org-capture-finalize
             "q" 'org-capture-kill
             "r" 'org-capture-refile))

         ;; for some reason, the header for org-capture specifically uses
         ;; the org-capture-mode-map, meaning my leader key shortcuts won't
         ;; show up in it :(. Fix that here.
         (add-hook 'org-capture-mode-hook
                   (defun org-capture--fix-header (&rest args)
                     (message "setting header")
                     (setq-local
                      header-line-format
                      (substitute-command-keys
                       "Capture buffer. Finish `\\[org-capture-finalize]', \
       refile `\\[org-capture-refile]', abort `\\[org-capture-kill]'.")))))
     #+END_SRC

***** templates
      #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale-org-capture.el
        ;; -*- lisp-indent-function: 'common-lisp-indent-function -*-
        (require 'doct)

        (defun org-capture-create-goto-heading-command (heading &optional heading-regexp)
          "create a function to jump to HEADING, creating HEADING if it doesn't exist.
        This function also smartly reacts to headings containing [/]. By default, if
        [/] has been updated to [0/1], then org is just unable to find it.
        "
          (unless heading-regexp
            (setq heading-regexp (regexp-quote heading))

            (when (string-match-p (rx "[/]") heading-regexp)
              (setq heading-regexp
                    (replace-regexp-in-string
                     (regexp-quote "[/]")
                     "[[[:digit:]]*/[[:digit:]]*\\\\]"
                     heading-regexp))))

          (lambda ()
            (let ((heading-point
                   (ignore-errors
                     (save-excursion
                       (goto-char (point-min))
                       (search-forward-regexp heading-regexp)
                       (line-beginning-position)))))
              (if heading-point
                  (goto-char heading-point)
                (goto-char (point-min))
                (save-excursion
                  (insert heading "\n"))))))

        (defun org-get-link+ ()
          "get the stringified result of `org-store-link'"
          (with-temp-buffer
            (org-insert-link-global)
            (buffer-substring (point-min) (point-max))))

        ;; see also: https://www.gnu.org/software/emacs/manual/html_node/org/Template-expansion.html#Template-expansion
        (setq
         org-capture-templates
         (doct `((:group "TODOs"
                         :type entry
                         :file ,org-default-notes-file
                         :prepend     t
                         :empty-lines 0
                         :function ,(org-capture-create-goto-heading-command "* TODOs [/]")
                         :before-finalize ,#'org-update-parent-todo-statistics
                         :template ("* %{todo-state} %?"
                                    "  %U")
                         :todo-state "TODO"
                         :children (("Todo" :keys "t")
                                    ("Todo with Clipboard"
                                     :keys "T"
                                     :template ("* %{todo-state} %?"
                                                "  %U"
                                                "  %c"))
                                    ("Itinerary"
                                     :keys "d"
                                     :prepend  nil
                                     :function ,(org-capture-create-goto-heading-command "* Itinerary")
                                     :template ("* %{todo-state} %?"))
                                    ("Internship"
                                     :keys "i"
                                     :function ,(org-capture-create-goto-heading-command "* Job Search [/]")
                                     :template ("* %{todo-state} [#%^{Priority|A|B|C}] %(org-get-link+) - %^{Company}"
                                                "  DEADLINE: %^{deadline}t"
                                                "%^{LOCATION}p%^{DURATION}p"
                                                "  %?"))))
                 (:group "education"
                         :type entry
                         :file "university/university.org"
                         :empty-lines 1
                         :children (("Lecture"
                                     :keys "l"
                                     :clock-in t
                                     :template ("* [/] %^{title} %^g"
                                                "  %?"))))))

         ;; templates for projectile-projects.
         counsel-projectile-org-capture-templates
         (doct `(("[${name}] Task"
                  :keys "p"
                  :template ("* TODO %?"
                             "  %U")
                  :file ,(join-path org-projectile-projects-directory "${name}.org")))))

        (provide 'mohkale-org-capture)
      #+END_SRC

**** mohkale-org
     #+BEGIN_SRC emacs-lisp
       (use-package mohkale-org
         :commands (org-outline-smart-up-level
                    org-openable-p
                    org-find-file
                    org-normal-return
                    org-clever-return)
         :init
         (leader/set-keys "oo" 'org-find-file))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp :tangle bin/mohkale/mohkale-org.el
       (defun org-outline-smart-up-level ()
         "when at a heading, move to parent
       otherwise move to current heading."
         (interactive)
         (call-interactively (if (org-at-heading-p)
                                 'outline-up-heading
                               'outline-previous-heading)))

       (defun org-openable-p ()
         (org-element-lineage
          (org-element-context)
          '(footnote-definition
            footnote-reference
            headline
            ;; inlinetask
            link
            timestamp)
          t))

       (defun org-normal-return ()
         (interactive)
         (call-interactively
          (cond
           ((org-openable-p) 'org-open-at-point)
           (t 'evil-ret))))

       (defvar org-clever-return--insert-headings nil
         "when true, returning from the end of a heading
       inserts a heading.")

       (defun org-clever-return (&optional above)
         "depending on the local state, inserts a heading, a table row an item or newline.
       this function is functionally similair to the result of evil-org-eol-call-anon, but
       instead of checking the line after moving to the end of it (which doesn't work for
       folded lines, such as headings), it checks before moving and then inserts the right
       items depending on how things looked where you were."
         (interactive)
         (cl-letf (((symbol-function 'evil-open)
                    (lambda () (call-interactively
                           (if above
                               'evil-open-above
                             'evil-open-below))))
                   ((symbol-function 'fallback-action)
                    (lambda (&optional interactive)
                      (when (and (line-empty-p)
                                 (not (zerop (column-number (point)))))
                        ;; don't leave a trailing indent on current line unecessarily
                        (remove-all-trailing-whitespace (line-beginning-position)
                                                        (line-end-position)))
                      (if (and interactive (not above))
                          (funcall-interactively
                           'newline-and-indent)
                        (evil-open)))))
           (if (and current-prefix-arg (listp current-prefix-arg))
               ;; when called with simple prefix, goto
               ;; fallaback action.
               (let ((current-prefix-arg nil))
                 (fallback-action))
             (cond ((org-table-p)
                    (org-table-insert-row (not above))
                    (evil-insert nil))

                   ((and org-clever-return--insert-headings
                         (org-at-heading-p))
                    (evil-open)
                    (org-insert-heading))

                   ((org-at-item-p)
                    ;; position of cursor dictates where new point goes
                    (if above
                        (goto-char (line-beginning-position))
                      (goto-char (line-end-position)))
                    (org-insert-item)
                    (evil-append nil))

                   (t (fallback-action (called-interactively-p)))))))

       ;;; org-find-file
       (defvar org-find-file-last-file nil
         "the last file found through `org-find-file'.")

       (defun org-find-file--generate-candidate (file)
         (let ((relative (file-relative-name file dotemacs-org-path)))
           (if (string-prefix-p ".." relative)
               (cons file file)
             (cons relative file))))

       (defun org-find-file (&optional arg initial-input)
         "find an org file.
       By default this function simply finds the default notes file, as indicated
       by `org-default-notes-file'. When ARG is non-nil, you are instead prompted
       interactively with all org files known to emacs (through `dotemacs-org-path',
       `dotemacs-agenda-files' etc.) and then allowed to select which one to visit.
       "
         (interactive "P")
         (if (not arg)
             (progn
               (find-file org-default-notes-file)
               (setq org-find-file-last-file
                     (org-find-file--generate-candidate org-default-notes-file)))
           (ivy-read "Find file: "
                     (cl-loop
                      for file in (cl-remove-duplicates
                                   (append (file-expand-wildcards (org! "*.org"))
                                           (file-expand-wildcards (org! "**/*.org"))
                                           org-agenda-files)
                                   :test (lambda (x y) (or (null y) (equal x y)))
                                   :from-end t)
                      collect (org-find-file--generate-candidate file))
                     :initial-input initial-input
                     :require-match t
                     :preselect (or org-find-file-last-file
                                    (car (org-find-file--generate-candidate
                                          org-default-notes-file)))
                     :action #'org-find-file-action
                     :caller 'org-find-file)))

       ;; actions for org find file
       (defun org-find-file-action (file)
         (find-file file))

       (defun org-find-file-other-window (file)
         (find-file-other-window file))

       (defun org-find-file-other-frame (file)
         (find-file-other-frame file))

       ;; convert cons back to file path
       (defun org-find-file--filter-args (file)
         (setq file (car file))
         (setq org-find-file-last-file (car file)
               file (org! (cdr file)))
         (list file))

       (dolist (func '(org-find-file-action
                       org-find-file-other-window
                       org-find-file-other-frame))
         (advice-add func :filter-args #'org-find-file--filter-args))

       (ivy-set-actions
        'org-find-file
        '(("j" org-find-file-other-window "other window")
          ("f" org-find-file-other-frame  "other frame")))
     #+END_SRC

**** org-mode
     #+BEGIN_SRC emacs-lisp
       (use-package org
         :straight (org :type built-in)
         :defer t
         :hook ((org-mode . display-line-numbers-mode)
                (org-mode . hl-todo-mode))
         :init
         ;;; leader keys outside of org mode
         (leader/set-keys
           "o"  "org"
           "oc" 'org-capture
           "oa" 'org-agenda
           "ol" 'org-store-link
           "oi" 'org-insert-link-global
           "oy" 'org-copy-subtree
           "oY" 'org-cut-subtree
           "on" 'org-next-link
           "op" 'org-previous-link)

         (add-hook 'org-mode-hook
                   (lambda (&rest _)
                     (modify-syntax-entry ?< "_" org-mode-syntax-table)
                     (modify-syntax-entry ?> "_" org-mode-syntax-table)))

         :config
         (setq-default org-src-window-setup 'current-window
                       org-babel-python-command "python3"
                       org-ditaa-jar-path (var! "org/bin/ditaa.jar")
                       org-ditaa-eps-jar-path (var! "org/bin/ditaaEps.jar")
                       org-plantuml-jar-path (var! "org/bin/plantuml.jar")



                       org-todo-keywords '((sequence "TODO" "DOING" "VERIFY" "|" "DONE" "DELAGATED" "SKIPPED"))
                       org-refile-targets '((nil :maxlevel . 9)
                                            (org-agenda-files :maxlevel . 9))
                       org-log-done 'time ; record when a TODO item is done.
                       org-outline-path-complete-in-steps nil ; refile in a single go
                       org-refile-use-outline-path t  ; show full paths for refiling
                       org-cycle-separator-lines 0 ; prevents weird coloring of collapsed trees
                       org-log-into-drawer "LOGBOOK" ; where org-add-note stores notes

                       ;; break org-cycle-seperator-lines from working automatically
                       ;; org-blank-before-new-entry '((heading . nil) (plain-list-item . auto))

                       ;; native tabs are slow and unreliable... :sad:
                       ;; org-src-tab-acts-natively t ;; tab is native to block language

                       org-agenda-files (append
                                         (file-expand-wildcards (org! "*.org"))
                                         (file-expand-wildcards (org! "university/*.org")))

                       org-archive-location (concat (org! "archive.org") "::* %s")
                       )

         (setq org-archive-file-header-format
               "# -*- mode: org; coding: utf-8-unix -*-
       ,#+TITLE: Archive
       ,#+STARTUP: content")

         ;; Initialised here to prevent org from defining a bunch of keys I won't
         ;; end up using :P
         (setq org-read-date-minibuffer-local-map (make-sparse-keymap))
         (set-keymap-parent org-read-date-minibuffer-local-map minibuffer-local-map)

         ;; switch to insert state when capturing org templates
         (add-hook 'org-capture-mode-hook (lambda () (evil-insert nil)) t)

         (advice-add 'org-edit-src-code :after
                     (lambda (&rest args)
                       "prevents org mode from restoring the window config before
       source code edit. when you run `org-edit-src-code' the window configuration
       from before the edit is saved, and when you exit the session it's restored.
       Any windows/buffers you open while in an edit get erased. This prevents that
       happening."
                       (setq org-src--saved-temp-window-config nil)))

         (let ((lob-file (etc! "babel-lib.org")))
           (when (file-exists-p lob-file)
             (org-babel-lob-ingest lob-file)))

         (advice-add 'org-edit-src-code :before (lambda (&rest args)
                                                  (unless (eq evil-state 'normal)
                                                    (evil-normal-state))))

         ;;  _
         ;; | | __ _ _ __   __ _ _   _  __ _  __ _  ___  ___
         ;; | |/ _` | '_ \ / _` | | | |/ _` |/ _` |/ _ \/ __|
         ;; | | (_| | | | | (_| | |_| | (_| | (_| |  __/\__ \
         ;; |_|\__,_|_| |_|\__, |\__,_|\__,_|\__, |\___||___/
         ;;                |___/             |___/

         (org-babel-do-load-languages 'org-babel-load-languages
          '((emacs-lisp . t)
            (awk        . t)
            (C          . t)
            (awk        . t)
            (haskell    . t)
            (latex      . t)
            (java       . t)
            (js         . t)
            (ditaa      . t)
            (plantuml   . t)
            (python     . t)
            (ruby       . t)
            (sed        . t)
            (shell      . t)
            (R          . t)))

         ;;             _ _       _     _           _ _
         ;;   _____   _(_) |     | |__ (_)_ __   __| (_)_ __   __ _ ___
         ;;  / _ \ \ / / | |_____| '_ \| | '_ \ / _` | | '_ \ / _` / __|
         ;; |  __/\ V /| | |_____| |_) | | | | | (_| | | | | | (_| \__ \
         ;;  \___| \_/ |_|_|     |_.__/|_|_| |_|\__,_|_|_| |_|\__, |___/
         ;;                                                   |___/

         (defmacro evil-org-eol-call-anon (&rest body)
           "define an anonymous function running body at the end of the line"
           `(lambda! (end-of-visual-line) ,@body (evil-append nil)))

         (general-define-key
           :keymaps 'org-mode-map
           :states 'insert
           "<return>" 'org-clever-return
           "DEL" 'org-delete-backward-char
           "<S-backspace>" 'org-delete-char)

         (general-define-key
           :keymaps 'org-mode-map
           :states 'normal
           "RET" 'org-normal-return
           "o" (lambda!
                 (let ((org-clever-return--insert-headings t))
                   (org-clever-return nil)))
           "O" (lambda!
                 (let ((org-clever-return--insert-headings t))
                   (org-clever-return t)))
           "M-u" 'org-metaleft
           "M-i" 'org-metadown
           "M-o" 'org-metaup
           "M-p" 'org-metaright
           "M-U" 'org-shiftmetaleft
           "M-I" 'org-shiftmetadown
           "M-O" 'org-shiftmetaup
           "M-P" 'org-shiftmetaright)

         (general-define-key
           :keymaps 'org-mode-map
           :states '(normal insert)
           ;; NOTE meta keys insert headings with changed priority, shift keys insert todo headings
           ;; FIXME prefix arg doesn't work
           "C-<return>"   (evil-org-eol-call-anon
                           (org-insert-heading nil))

           "C-M-<return>" (evil-org-eol-call-anon
                           (org-insert-heading nil)
                           (if current-prefix-arg
                               (org-metaleft)
                             (org-metaright)))

           "C-S-<return>"   (evil-org-eol-call-anon
                             (org-insert-todo-heading nil))

           "C-S-M-<return>" (evil-org-eol-call-anon
                             (org-insert-todo-heading nil)
                             (if current-prefix-arg
                                 (org-metaleft)
                               (org-metaright)))

           "C-." 'org-toggle-heading)

         (general-unbind
           :keymaps 'org-mode-map
           ;; "C-M-<return>" 'org-meta-return
           "<C-tab>" "M-S-<return>" "C-e" "M-e" "M-h" "C-j")

         (evil-set-command-property 'org-outline-smart-up-level :jump t)
         (evil-set-command-property 'org-forward-heading-same-level :jump t)
         (evil-set-command-property 'org-backward-heading-same-level :jump t)
         (evil-set-command-property 'org-next-visible-heading :jump t)

         (general-define-key
           ;; most bindings stolen from: https://github.com/edwtjo/evil-org-mode
           :keymaps 'org-mode-map
           :states '(normal visual)
           "gh" 'org-outline-smart-up-level
           "gj" 'org-forward-heading-same-level
           "gk" 'org-backward-heading-same-level
           "gl" 'outline-next-visible-heading
           "g." 'hydra-org-navigate/body
           "$" 'org-end-of-line
           "^" 'org-beginning-of-line)

         (general-define-key
           :keymaps 'org-mode-map
           :states  'visual
           "gb" 'org-babel-mark-block
           "gB" 'org-mark-element)

         (general-define-key
           :keymaps 'org-mode-map
           :states '(normal visual)
           :predicate '(or (org-table-p t)
                           (org-at-heading-p)
                           (org-at-item-p))
           [remap drag-stuff-down] 'org-metadown
           [remap drag-stuff-up]   'org-metaup)

         ;; navigate throught tables or lists with tab in insert state.
         (general-define-key
           :keymaps 'org-mode-map
           :states 'insert
           :predicate '(or (org-table-p t)
                           (org-at-heading-p)
                           (org-at-item-p))
           "<tab>"   'org-cycle
           "TAB"     'org-cycle
           "<S-tab>" 'org-shifttab)

         (general-define-key
           :keymaps 'org-mode-map
           :states '(normal visual emacs)
           "<tab>"   'org-cycle
           "TAB"     'org-cycle
           "<S-tab>" 'org-shifttab)

         (general-define-key
           :keymaps 'org-mode-map
           :states '(normal insert visual)
           :predicate '(org-at-heading-p)
           [remap evil-shift-right] 'org-demote-subtree
           [remap evil-shift-left]  'org-promote-subtree)

         (defmacro org-read-date-command (name &rest body)
           "define a function for use in the calendar buffer for `calendar-read-date'."
           `(defun ,(intern (concat "org-read-date-" (symbol-name name) "+")) ()
              ,(when (stringp (car body))
                 (concat (pop body) "\nThis function was generated by `org-read-date-command'."))
              (interactive)
              (org-eval-in-calendar (quote (progn ,@body)))))
         (put 'org-read-date-command 'lisp-indent-function 'defun)

         (general-define-key
           :keymaps 'org-read-date-minibuffer-local-map
           ;; haven't implemented backward year, or forward year... cause when will
           ;; I ever need those.
           "C-M-j" 'exit-minibuffer
           "C-j" (org-read-date-command forward-week   (calendar-forward-week 1))
           "C-k" (org-read-date-command backward-week  (calendar-backward-week 1))
           "C-h" (org-read-date-command backward-day   (calendar-backward-day 1))
           "C-l" (org-read-date-command forward-day    (calendar-forward-day 1))
           "C-n" (org-read-date-command forward-month  (calendar-forward-month 1))
           "C-p" (org-read-date-command backward-month (calendar-backward-month 1))
           "<"   (org-read-date-command scroll-left    (calendar-scroll-left 1))
           ">"   (org-read-date-command scroll-right   (calendar-scroll-right 1))
           "!"   (org-read-date-command view-diary     (diary-view-entries))
           "."   (org-read-date-command goto-today
                   "when at end of prompt, goto today in calendar."
                   (if (looking-back "^[^:]+: "
                                     (let ((inhibit-field-text-motion t))
                                       (line-beginning-position)))
                       (org-eval-in-calendar '(calendar-goto-today))
                     (insert "."))))

         ;;  _                _                _
         ;; | | ___  __ _  __| | ___ _ __     | | _____ _   _ ___
         ;; | |/ _ \/ _` |/ _` |/ _ \ '__|____| |/ / _ \ | | / __|
         ;; | |  __/ (_| | (_| |  __/ | |_____|   <  __/ |_| \__ \
         ;; |_|\___|\__,_|\__,_|\___|_|       |_|\_\___|\__, |___/
         ;;                                             |___/

         (leader/set-keys-for-major-mode 'org-mode
           "RET" 'org-ctrl-c-ret
           "TAB" 'org-todo
           "SPC" 'org-display-outline-path
           "!" 'org-time-stamp-inactive
           "'" 'org-edit-special
           "*" 'org-ctrl-c-star
           "," 'org-ctrl-c-ctrl-c
           "-" 'org-ctrl-c-minus
           "." 'org-time-stamp
           "/" 'org-sparse-tree
           ":" 'org-set-tags-command
           "#" 'org-priority
           "`" 'org-toggle-latex-fragment
           "^" 'org-sort
           "A" 'org-agenda
           "a" 'org-archive-subtree
           "b" 'org-tree-to-indirect-buffer
           ;; "C" 'evil-org-recompute-clocks
           "D" 'org-insert-drawer
           "d" 'org-deadline
           "f" 'org-set-effort
           "i" 'org-clock-in
           "H" 'org-shiftleft
           "J" 'org-shiftdown
           "K" 'org-shitup
           "L" 'org-shiftright
           "l" 'org-insert-link
           "N" 'org-add-note
           "o" 'org-clock-out
           "O" 'org-sort
           "p" 'org-set-property
           "P" 'org-pomodoro
           "q" 'org-set-tags-command
           "r" 'org-refile
           "R" 'org-refile-goto-last-stored
           "s" 'org-schedule
           "T" 'org-show-todo-tree
           "U" 'org-update-all-dblocks
           "u" 'org-dblock-update
           ;; "C-h" 'org-shiftcontrolleft
           ;; "C-j" 'org-shiftcontroldown
           ;; "C-k" 'org-shiftcontrolup
           ;; "C-l" 'org-shiftcontrolright
           "M-a" 'org-attach
           "M-c" 'org-columns
           "M-p" 'org-delete-property

           "c"  "clock/calendar"
           "c<" 'org-date-from-calendar
           "c>" 'org-goto-calendar
           "cC" 'org-clock-out
           "cc" 'org-clock-in
           ;; "cf" 'org-clock-modify-effort-estimate
           "cg" 'org-clock-goto
           "ch" 'org-clock-remove-overlays
           "ci" 'org-timer-item
           "cr" 'org-clock-report
           "cs" 'org-clock-display
           "c." 'hydra-org-clock/body
           "c C-c" 'org-clock-cancel

           "e"  "export"
           "ee" 'org-export-dispatch
           "eh" 'org-html-export-to-html

           "h"  "headings"
           "hI" 'org-insert-heading
           "hi" 'org-insert-heading-after-current
           "hs" 'org-insert-subheading

           "I"  "insert"
           "Ia" 'org-attach
           "If" 'org-footnote-new
           ;; "Ik" 'insert-keybinding-org
           "It" 'org-table-create
           ;; "Is" 'org-download-screenshot
           ;; "Iy" 'org-download-yank

           "m"  "mark/move"
           "ms" 'org-mark-subtree
           "me" 'org-mark-element
           "mb" 'org-babel-mark-block
           "mm." 'hydra-org-navigate/body

           "n"  "narrow"
           "nb" 'org-narrow-to-block
           "ns" 'org-narrow-to-subtree
           "ne" 'org-narrow-to-element
           "nw" 'widen

           "S"  "subtrees"
           "Sh" 'org-promote-subtree
           "Sj" 'org-move-subtree-down
           "Sk" 'org-move-subtree-up
           "Sl" 'org-demote-subtree

           "t" "tables"
           "t'"  'org-table-edit-field
           "ta"  'org-table-align
           "tb"  'org-table-blank-field
           "tc"  'org-table-convert
           "tE"  'org-table-export
           "te"  'org-table-eval-formula
           "tH"  'org-table-move-column-left
           "th"  'org-table-previous-field
           "tI"  'org-table-import
           "tJ"  'org-table-move-row-down
           "tj"  'org-table-next-row
           "tK"  'org-table-move-row-up
           "tL"  'org-table-move-column-right
           "tl"  'org-table-next-field
           "tN"  'org-table-create-with-table.el
           "tn"  'org-table-create
           "tp"  'org-plot/gnuplot
           "tr"  'org-table-recalculate
           "ts"  'org-table-sort-lines
           "tw"  'org-table-wrap-region

           "td"  "delete"
           "tdc" 'org-table-delete-column
           "tdr" 'org-table-delete-row

           "ti"  "insert"
           "tic" 'org-table-insert-column
           "ti-" 'org-table-hline-and-move
           "tih" 'org-table-insert-hline
           "tir" 'org-table-insert-row

           "tt"  "toggle"
           "ttf" 'org-table-toggle-formula-debugger
           "tto" 'org-table-toggle-coordinate-overlays

           ;; "x"  "text"
           ;; "xb" 'org-bold
           ;; "xc" 'org-code
           ;; "xi" 'org-italic
           ;; "xr" 'org-clear
           ;; "xs" 'org-strike-through
           ;; "xu" 'org-underline
           ;; "xv" 'org-verbose
           ))
     #+END_SRC

**** org-src
     #+BEGIN_SRC emacs-lisp
       (use-package org-src
         :straight (org-src :type built-in)
         :defer t
         :config
         (general-define-key
           :keymaps 'org-src-mode-map
           [remap evil-write] 'org-edit-src-save
           [remap evil-quit] 'org-edit-src-abort
           ;; save and then quit
           [remap evil-save-and-close] 'org-edit-src-exit
           [remap evil-save-modified-and-close] 'org-edit-src-exit)

         (leader/with-major-mode-prefix
           (leader/set-keys-for-mode 'org-src-mode
             "," 'org-edit-src-exit
             "q" 'org-edit-src-abort
             "s" 'org-edit-src-save)))
     #+END_SRC

**** org-projectile
     deprecated in favour of [[*counsel-projectile][counsel-projectile]].

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package org-projectile
         :ensure t
         :defer  t
         :commands (org-projectile-find-todo-file
                    org-projectile-project-todo-entry)
         :init
         (with-eval-after-load 'org
           (add-to-list 'org-capture-templates (org-projectile-project-todo-entry) t)

           (setq org-confirm-elisp-link-function nil
                 org-agenda-files (append org-agenda-files
                                          (delq nil (mapcar (lambda (file) (when (file-exists-p file) file))
                                                            (org-projectile-todo-files))))))

         (leader/set-keys
           "op" 'org-projectile-find-todo-file
           ;; "op" 'org-projectile-goto-location-for-project
           "po" '("org-projectile-goto-todos" . org-projectile-goto-location-for-project)
           ;; "pO" 'org-projectile-helm-template-or-project
           )

         :config
         (setq org-projectile-projects-directory (org! "projects/")
               org-projectile-projects-file      (org! "projects/global.org")

               org-projectile-per-project-filepath
               (defun mohkale--org-projectile-path (project-path)
                 (let* ((project-path (replace-regexp-in-string "/$" "" project-path)))
                   (concat (file-name-nondirectory project-path) ".org"))))

         (org-projectile-per-project)
         (defun org-projectile-find-todo-file (&optional prefix)
           "find the org file for a given project
       by default it'll be the current project. If you're not in a project
       or you pass a PREFIX value, then you'll be prompted for which project
       to visit the TODO file for."
           (interactive "P")
           (let ((project-root (projectile-project-root)))
             (when (or prefix (not project-root))
               (setq project-root
                     ;; (completing-read "Project: " (projectile-relevant-known-projects))
                     (projectile-completing-read
                      "Project: " (occ-get-categories org-projectile-strategy))))

             (when project-root
               (let ((file (org-projectile-get-project-todo-file project-root)))
                 (when (or (file-exists-p file)
                           (y-or-n-p (format "Project TODO file '%s' doesn't exist, make now: "
                                             file)))
                   (find-file file)))))))
     #+END_SRC

**** org-live-latex-mode
     #+BEGIN_SRC emacs-lisp
       (use-package org-live-latex-mode
         :defer t
         :commands org-live-latex-mode
         :init
         (with-eval-after-load 'org
           (add-to-list 'org-latex-packages-alist '("" "mathdots"))
           (add-to-list 'org-latex-packages-alist '("" "fourier"))

           (when (host! 'desktop)
             (setq org-format-latex-options
                   (plist-put
                    org-format-latex-options
                    :scale 1.5)))))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp :tangle bin/misc/org-live-latex-mode.el
       ;;; org-live-latex-mode.el --- render latex as you write -*- lexical-binding: t -*-

       ;; Copyright (C) 2015-2019  Free Software Foundation, Inc.

       ;; Author: Mohsin Kaleem <mohkalsin@gmail.com>
       ;; Version: 0.0.1
       ;; Package-Requires: ((emacs "26.3"))
       ;; Keywords: org

       (defvar org-live-latex-last nil
         "Holds last fragment/environment you were on.")

       (defvar org-live-latex-toggle-delay 0.5
         "delay after which the fragment at point will be derendered.")

       (defun org-live-latex--get-current-latex-fragment ()
         "Return the overlay associated with the image under point."
         (car (--select (eq (overlay-get it 'org-overlay-type) 'org-latex-overlay)
                        (overlays-at (point)))))

       (defun org-live-latex-in-fragment-p ()
         "Return the point where the latex fragment begins, if inside
       a latex fragment. Else return false"
         (let* ((el (org-element-context))
                (el-type (car el)))
           (and (or (eq 'latex-fragment el-type)
                    (eq 'latex-environment el-type))
                (org-element-property :begin el))))

       (defun org-live-latex-toggle-auto ()
         (interactive)
         (while-no-input
           (run-with-idle-timer org-live-latex-toggle-delay
                                nil 'org-live-latex-toggle-helper)))

       (defun org-live-latex--new-fragment-p (new-fragment-point)
         "true when we were on a fragmet, but have moved to a new fragment.
       NEW-FRAGMENT-POINT is expected to be the return value of
       `org-live-latex-in-fragment-p'."
         (and
          ;; fragment we were on
          org-live-latex-last
          ;; and are on a fragment now
          new-fragment-point
          ;; but not on the last one this is a little tricky. as you edit the
          ;; fragment, it is not equal to the last one. We use the begin
          ;; property which is less likely to change for the comparison.
          (not (= new-fragment-point
                  org-live-latex-last))))

       (defun org-live-latex--exit-fragment-p (new-fragment-point)
         "true when we've exited the body of a fragment we were on.
       See also: `org-live-latex--new-fragment-p'."
         (and
          ;; not on a fragment now
          (not new-fragment-point)
          ;; but we were on one
          org-live-latex-last))

       (defun org-live-latex--enter-fragment-p (new-fragment-point)
         "true when we've entered a fragment, but were not in one before.
       See also: `org-live-latex--new-fragment-p'."
         (and
          ;; we were not one one
          (not org-live-latex-last)
          ;; but now we are
          new-fragment-point))

       (defun org-live-latex-toggle-helper ()
         "Toggle a latex fragment image."
         (ignore-errors
           (when (eq major-mode 'org-mode)
             (let* ((begin (org-live-latex-in-fragment-p)))
               (cond
                ;; were on a fragment and now on a new fragment
                ((org-live-latex--new-fragment-p begin)
                 ;; go back to last one and put image back on
                 (save-excursion
                   (goto-char org-live-latex-last)
                   (when (org-live-latex-in-fragment-p) (org-toggle-latex-fragment))
                   ;; now remove current imagea
                   (goto-char begin)
                   (let ((ov (org-live-latex--get-current-latex-fragment)))
                     (when ov
                       (delete-overlay ov)))
                   ;; and save new fragment
                   (setq org-live-latex-last begin)))

                ;; were on a fragment and now are not on a fragment
                ((org-live-latex--exit-fragment-p begin)
                 ;; put image back on
                 (save-excursion
                   (goto-char org-live-latex-last)
                   (when (org-live-latex-in-fragment-p)
                     (org-toggle-latex-fragment)))

                 ;; unset last fragment
                 (setq org-live-latex-last nil))

                ;; were not on a fragment, and now are
                ((org-live-latex--enter-fragment-p begin)
                 (save-excursion
                   (goto-char begin)
                   ;; remove image
                   (let ((ov (org-live-latex--get-current-latex-fragment)))
                     (when ov
                       (delete-overlay ov)))
                   (setq org-live-latex-last begin)))
                ;; else not on a fragment
                ((not begin)
                 (setq org-live-latex-last nil)))))))

       ;; (setq org-live-latex-toggle-helper (byte-compile 'org-live-latex-toggle-helper))
       ;; (setq org-live-latex-toggle-auto   (byte-compile 'org-live-latex-toggle-auto))

       (define-minor-mode org-live-latex-mode
         "Toggle org-live-latex-mode
       When this minor-mode is active alongside `org-mode', latex fragments are automatically
       rendered as their written. Returning `point' to a fragment will delete the overlay
       providing an affect similair to `prettify-symbols-mode'.

       This mode was basically copied and pasted from:
       https://ivanaf.com/automatic_latex_fragment_toggling_in_org-mode.html
       "
         :lighter " OLL"
         (if org-live-latex-mode
             (progn
               (if (eq major-mode 'org-mode)
                   (progn
                     (make-variable-buffer-local 'post-command-hook)
                     (add-hook 'post-command-hook 'org-live-latex-toggle-auto))
                 (setq org-live-latex-mode nil)
                 (user-error "org-live-latex-mode can only be active in org-mode buffers.")))

           (remove-hook 'post-command-hook 'org-live-latex-toggle-auto)
           (when (eq post-command-hook
                     (default-value 'post-command-hook))
             (kill-local-variable 'post-command-hook))))

     #+END_SRC


**** org-ql
     lisp like query language for org mode.

     #+BEGIN_SRC emacs-lisp
       (use-package org-ql
         ;; :ensure t
         :straight t
         :defer  t
         :commands (ivy-org-ql-query
                    ivy-org-ql-query-picklink
                    ivy-org-ql-query-goto
                    ivy-org-ql-query-insert-link)
         :init
         (leader/set-keys
           "oq" 'ivy-org-ql-query)

         :config
         ;; basically all of ivy-org-ql was just copied and pasted from
         ;; here: https://github.com/alphapapa/org-ql/issues/63
         (defvar ivy-org-ql-query-collect-timer nil)
         (defun ivy-org-ql-query-collect (input)
           (when ivy-org-ql-query-collect-timer
             (cancel-timer ivy-org-ql-query-collect-timer))
           (if (< (length input) 4)
               (list "" (format "%d chars more" (- 4 (length input))))
             (setq ivy-org-ql-query-collect-timer
                   (run-with-timer
                    0.25 nil
                    `(lambda ()
                       (let ((files (org-agenda-files))
                             (query (org-ql--plain-query  ,input)))
                         (when query
                           (ignore-errors
                             (setq ivy--all-candidates
                                   (or
                                    (org-ql-select files query
                                      :action (lambda ()
                                                (propertize (org-get-heading t)
                                                            'marker (copy-marker (point)))))
                                    '("" "Search no results!")))
                             (setq ivy--old-cands ivy--all-candidates)
                             (ivy--exhibit)))))))
             nil))

         (defun ivy-org-ql-query ()
           (interactive)
           (ivy-read "Org query: " #'ivy-org-ql-query-collect
                     :dynamic-collection t
                     :initial-input (ivy-org-ql-query-string)
                     :action #'ivy-org-ql-query-goto))

         (defun ivy-org-ql-query-picklink ()
           (interactive)
           (ivy-read "Org query: " #'ivy-org-ql-query-collect
                     :dynamic-collection t
                     :initial-input (ivy-org-ql-query-string)
                     :action #'ivy-org-ql-query-insert-link))

         (defun ivy-org-ql-query-string ()
           (when mark-active
             (buffer-substring-no-properties
              (region-beginning) (region-end))))

         (defun ivy-org-ql-query-goto (headline)
           (interactive)
           (let ((marker (get-text-property 0 'marker headline)))
             (when (markerp marker)
               (switch-to-buffer (marker-buffer marker))
               (goto-char marker)
               (org-show-entry))))

         (defun ivy-org-ql-query-insert-link (headline &optional link-type breadcrumbs)
           (interactive)
           (let ((marker (get-text-property 0 'marker headline))
                 store-link)
             (when (markerp marker)
               (org-with-point-at marker
                 (let* ((id (org-id-get (point) t))
                        (attach-dir (org-attach-dir t))
                        (breadcrumbs
                         (when breadcrumbs
                           (let ((s (org-format-outline-path
                                     (org-get-outline-path)
                                     (1- (frame-width))
                                     nil org-picklink-breadcrumbs-separator)))
                             (if (eq "" s) "" (concat s org-picklink-breadcrumbs-separator)))))
                        (item (concat (or breadcrumbs "") (org-entry-get (point) "ITEM")))
                        (link
                         (cl-case link-type
                           (attach (list :link attach-dir :description (concat item "(ATTACH)") :type "file"))
                           (t (list :link (concat "id:" id) :description item :type "id")))))
                   (setq store-link link)))
               (org-insert-link nil (plist-get store-link :link) (plist-get store-link :description))
               (cond ((org-in-item-p)
                      (call-interactively #'org-insert-item))
                     (t (insert " ")))))))
     #+END_SRC

**** org-man
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'org-mode
         (use-package org-man
           :straight (org-man :type built-in)
           :defer nil
           :config
           (setq org-man-command mohkale-man-command)))
     #+END_SRC

*** JSON
    #+BEGIN_SRC emacs-lisp
      (use-package json-mode
        :ensure t
        :defer  t
        :mode "\\.json$"
        :hook (json-mode . flycheck-mode)

        :config
        (leader/set-keys-for-major-mode 'json-mode
          "b" 'json-mode-beautify
          "/" 'json-mode-kill-path
          "t" 'json-toggle-boolean
          "<backspace>" 'json-nullify-sexp))
    #+END_SRC

*** vimscript
    #+BEGIN_SRC emacs-lisp
      (use-package vimrc-mode
        :ensure t
        :defer  t
        :mode "\\.vim"
        :hook (vimrc-mode . flycheck-mode)
        :delight (vimrc-mode "vim"))
    #+END_SRC

*** sql
**** sql
     #+BEGIN_SRC emacs-lisp
       (use-package sql
         :ensure t
         :defer  t
         :mode ("\\.sql" . sql-mode)
         :hook (sql-mode . flycheck-mode)
         :config
         (setq sql-sqlite-options '("-interactive"))
         (push 'sql-interactive-mode whitespace-exempt-modes)

         (evil-set-initial-state 'sql-interactive-mode 'emacs)

         ;; see [here](https://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client)
         ;; for a guide on how to make quick database access easier. or if you've already got
         ;; an interactive session running, use sql-save-connection to append it to a local
         ;; variable from which you can just paste it in here.
         (leader/set-keys-for-major-mode 'sql-mode
           "0" 'sql-beginning-of-statement
           "$" 'sql-end-of-statement
           "i" 'sql-show-sqli-buffer
           "t" 'sql-toggle-pop-to-buffer-after-send-region

           "e"  "eval"
           "eb" 'sql-send-buffer
           "ep" 'sql-send-paragraph
           "er" 'sql-send-region
           "es" 'sql-send-string

           "l"  "list"
           "ll" 'sql-list-all
           "lt" 'sql-list-table)

         (leader/set-keys-for-major-mode 'sql-interactive-mode
           "t" 'sql-list-table
           "a" 'sql-list-all))

     #+END_SRC

**** sqlup
     upcases SQL specific keywords after completing them.

     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'sql
         (use-package sqlup-mode
           :ensure t
           :defer  t
           :hook ((sql-mode . sqlup-mode)
                  (sql-interactive-mode . sqlup-mode))
           :config
           (leader/set-keys-for-major-mode 'sql-mode
             "u"  "upcase"
             "ur" 'sqlup-capitalize-keywords-in-region
             "ub" 'sqlup-capitalize-keywords-in-buffer)

           (push "name" sqlup-blacklist)))
     #+END_SRC

**** sqlite-dump
     converts an sqlite database file into the SQL schema required to reproduce it.

     #+BEGIN_SRC emacs-lisp
       (use-package sqlite-dump
         :defer t
         :commands (sqlite-dump))
     #+END_SRC

*** YAML
    #+BEGIN_SRC emacs-lisp
      (use-package yaml-mode
        :ensure t
        :defer  t
        :mode "\\.yaml"
        :hook (yaml-mode . flycheck-mode)
        :config
        (general-define-key
          :keymaps 'yaml-mode-map
          :states 'insert
          "<tab>" 'yaml-indent-line)

        (leader/set-keys-for-major-mode 'yaml-mode
          "n" 'yaml-narrow-to-block-literal
          "f" 'yaml-fill-paragraph
          "v" 'yaml-mode-version)

        (push '(yaml-mode . 2) mohkale-indent-config))
    #+END_SRC

*** csv
    #+BEGIN_SRC emacs-lisp
      (use-package csv-mode
        :ensure t
        :defer  t
        :init
        (setq csv-separators '("," ":" ";" "\t"))

        :config
        (general-define-key
          :keymaps 'csv-mode-map
          "<tab>"     'csv-forward-field
          "<backtab>" 'csv-backward-field)

        (leader/set-keys-for-major-mode 'csv-mode
          "a"  'csv-align-fields
          "d"  'csv-kill-fields
          "i"  'csv-toggle-invisibility
          "r"  'csv-reverse-region
          "t"  'csv-transpose
          "u"  'csv-unalign-fields

          "s" "sort"
          "sf" 'csv-sort-fields
          "sn" 'csv-sort-numeric-fields
          "so" 'csv-toggle-descending

          "v" "yank"
          "vf" 'csv-yank-fields
          "vt" 'csv-yank-as-new-table))
    #+END_SRC

*** yarn
    #+BEGIN_SRC emacs-lisp
      (use-package yarn-mode
        :ensure t)
    #+END_SRC

*** shell-script
**** company-shell
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'sh-script
         (use-package company-shell
           :ensure t
           :defer  t
           :config
           (company/configure-mode (sh-mode :major t)
             company-shell company-shell-env)))
     #+END_SRC

**** shell-script-mode
     #+BEGIN_SRC emacs-lisp
       (use-package sh-script
         :straight (sh-script :type built-in)
         :defer t
         :hook ((sh-script-mode . electric-pair-mode)
                (sh-script-mode . flycheck-mode))
         :config
         (leader/set-keys-for-major-mode 'sh-mode
           ":" 'sh-set-shell
           "0" 'sh-beginning-of-command
           "$" 'sh-end-of-command
           "!" 'executable-interpret
           "b" 'sh-show-shell
           "\\" 'sh-backslash-region

           "er" 'sh-execute-region
           "ej" 'sh-send-line-or-region-and-step

           "i=" 'sh-assignment
           "ic" 'sh-case
           "id" 'sh-cd-here
           "if" 'sh-for
           "i TAB" 'sh-if
           "il" 'sh-indexed-loop
           "io" 'sh-while-getopts
           "ir" 'sh-repeat
           "is" 'sh-select
           "it" 'sh-tmp-file
           "iu" 'sh-until
           "iw" 'sh-while
           "i(" 'sh-function
           "i+" 'sh-add

           "TAB"   "indent"
           "TAB -" 'sh-learn-line-indent
           "TAB =" 'sh-set-indent
           "TAB |" 'sh-learn-buffer-indent
           "TAB ?" 'sh-show-indent)

         (advice-add 'sh-set-shell :around 'inhibit-messages-wrapper))
     #+END_SRC

*** ssh
    #+BEGIN_SRC emacs-lisp
      (use-package ssh-config-mode
        :ensure t
        :defer  t
        :delight (ssh-config-mode "SSH")
        :config
        ;; TODO advise last host to behave like org mode
        (general-define-key
          :keymaps '(ssh-config-mode-map
                     ssh-known-hosts-mode-map)
          :states 'motion
          "gj" 'ssh-config-host-next
          "gk" 'ssh-config-host-prev))
    #+END_SRC

*** makefile
    #+BEGIN_SRC emacs-lisp
      (use-package make-mode
        :straight (makefile-mode :type built-in)
        :defer t
        :config
        (defun makefile--enable-evil-motion-state (&rest _)
          (evil-motion-state +1))

        ;; tabs for indentation, spaces for allignment
        (advice-add 'makefile-backslash-region :around
                    (defun makefile-backslash-region--no-tabs (func &rest args)
                      (let (indent-tabs-mode)
                        (apply func args))))

        (advice-add #'makefile-switch-to-browser          :after #'makefile--enable-evil-motion-state)
        (advice-add #'makefile-create-up-to-date-overview :after #'makefile--enable-evil-motion-state)

        (general-define-key
          :keymaps 'makefile-mode-map
          :states 'insert
          "TAB" 'indent-for-tab-command
          "<tab>" 'indent-for-tab-command)

        (general-define-key
          :keymaps 'makefile-mode-map
          :states 'motion
          "gj" 'makefile-next-dependency
          "gk" 'makefile-previous-dependency)

        (general-define-key
          :states  'motion
          :keymaps 'makefile-browser-map
          "j" 'makefile-browser-next-line
          "k" 'makefile-browser-previous-line

          "t"     'makefile-browser-toggle
          "TAB"   'makefile-browser-toggle
          "<tab>" 'makefile-browser-toggle
          "RET"   'makefile-browser-insert-continuation

          "I" 'makefile-browser-insert-selection-and-quit
          "i" 'makefile-browser-insert-selection

          [remap quit-window] 'makefile-browser-quit)

        (leader/set-keys-for-major-mode '(makefile-automake-mode
                                          makefile-bsdmake-mode
                                          makefile-gmake-mode
                                          makefile-imake-mode
                                          makefile-mode
                                          makefile-makepp-mode)
          "b" 'makefile-switch-to-browser
          "o" 'makefile-create-up-to-date-overview
          "p" 'makefile-pickup-everything
          "f" 'makefile-pickup-filenames-as-targets

          ":"   'makefile-insert-target-ref
          "C-:" 'makefile-insert-target-ref

          "\\"  'makefile-backslash-region
          "TAB" 'makefile-insert-gmake-function))
    #+END_SRC

*** Markdown
**** gh-md
     #+BEGIN_SRC emacs-lisp
       (use-package gh-md
         :ensure t
         :defer  t
         :init
         (leader/set-keys-for-major-mode 'markdown-mode
           "r" 'gh-md-render-buffer
           "R" 'gh-md-render-region))
     #+END_SRC

**** markdown-mode
     #+BEGIN_SRC emacs-lisp
       (use-package markdown-mode
         :ensure t
         :defer  t
         :hook ((markdown-mode . display-line-numbers-mode)
                (markdown-mode . flycheck-mode))
         :config
         (setq markdown-indent-on-enter 'indent-and-new-item)

         (general-define-key
           :keymaps 'markdown-mode-map
           :states 'motion
           "gh" 'markdown-up-heading
           "gj" 'markdown-outline-next
           "gk" 'markdown-outline-previous
           "gl" 'markdown-outline-next-same-level
           "}" 'markdown-forward-paragraph
           "{" 'markdown-backward-paragraph)

         (general-define-key
           :keymaps 'markdown-mode-map
           :states 'insert
           "RET"      'markdown-enter-key
           "<return>" 'markdown-enter-key)

         (general-define-key
           :keymaps 'markdown-mode-map
           :states '(normal insert)
           "C-<return>" 'markdown-insert-list-item)

         (general-define-key
           :keymaps 'markdown-mode-map
           :states '(insert normal)
           :predicate '(markdown-list-item-at-point-p)
           [remap drag-stuff-down]  'markdown-move-down
           [remap drag-stuff-up]    'markdown-move-up)

         (general-define-key
           :keymaps 'markdown-mode-map
           :states '(insert normal)
           :predicate '(or (markdown-list-item-at-point-p)
                           (markdown-on-heading-p))
           [remap evil-shift-right] 'markdown-demote
           [remap evil-shift-left]  'markdown-promote)

         (general-define-key
           :keymaps 'markdown-mode-map
           :states '(insert normal)
           :predicate '(or (markdown--table-at-point-p)
                           (markdown-on-heading-p))
           "<tab>"           'markdown-cycle
           "<S-iso-lefttab>" 'markdown-shifttab
           "<S-tab>"         'markdown-shifttab
           "<backtab>"       'markdown-shifttab)

         (advice-add 'markdown-insert-list-item :before
                     (defun markdown-insert-list-item--adjust-line+ (&rest args)
                       "by default, inserting a new list item goes below the current item."
                       (when (markdown-list-item-at-point-p)
                         (save-excursion
                           (goto-char (line-end-position))
                           (newline))

                         (markdown-forward-paragraph))))

         (advice-add 'markdown-insert-list-item :after
                     (defun markdown-insert-list-item--force-evil-insert+ (&rest args)
                       (if (eq (char-before)
                               ?\ )
                           (evil-insert nil)
                         (evil-append nil))))

         ;;; evil-markdown-mode (Somelauw/evil-markdown)
         (with-eval-after-load 'evil
           (evil-declare-motion 'markdown-forward-paragraph)
           (evil-declare-motion 'markdown-backward-paragraph)

           ;; heading
           (evil-declare-motion 'markdown-forward-same-level)
           (evil-declare-motion 'markdown-backward-same-level)
           (evil-declare-motion 'markdown-up-heading)
           (evil-declare-motion 'markdown-next-heading)
           (evil-declare-motion 'markdown-previous-heading)
           (evil-declare-motion 'markdown-next-visible-heading)
           (evil-declare-motion 'markdown-previous-visible-heading)

           ;; other
           (evil-declare-motion 'markdown-beginning-of-block)
           (evil-declare-motion 'markdown-beginning-of-defun)
           (evil-declare-motion 'markdown-end-of-block)
           (evil-declare-motion 'markdown-end-of-block-element)
           (evil-declare-motion 'markdown-end-of-defun)
           (evil-declare-motion 'markdown-next-visible-heading)
           (evil-declare-motion 'markdown-next-link)
           (evil-declare-motion 'markdown-previous-visible-heading)
           (evil-declare-motion 'markdown-previous-link)

           ;; non-repeatible
           (evil-declare-change-repeat 'markdown-cycle)
           (evil-declare-change-repeat 'markdown-shifttab))

         ;;; leader keys
         (leader/set-keys-for-major-mode 'markdown-mode
         ;;; unbound commands:
         ;;;  * markdown-outdent-region
         ;;;  * markdown-indent-region
         ;;;  * markdown-outline-previous-same-level


           "h" 'markdown-up
           "j" 'markdown-next
           "k" 'markdown-previous
           "l" 'markdown-outline-next-same-level
           "g" 'markdown-next-link
           "G" 'markdown-previous-link
           "}" 'markdown-forward-block
           "{" 'markdown-backward-block
           "SPC" 'markdown-do
           "'" 'markdown-edit-code-block
           "f" 'markdown-follow-thing-at-point
           ">" 'markdown-blockquote-region
           "TAB" 'markdown-pre-region ;; preformat

           ;; complete/checks
           "c"  "check/complete"
           "cc" 'markdown-complete
           "cb" 'markdown-complete-buffer
           "cr" 'markdown-check-refs
           "cR" 'markdown-unused-refs
           "cl" 'markdown-cleanup-list-numbers

           "o" 'markdown-open
           "e" 'markdown-export
           "p" 'markdown-preview
           "v" 'markdown-export-and-preview
           "O" 'markdown-other-window

           ;; insert
           "i"  "insert"
           "i TAB" 'markdown-insert-image
           "i*" 'markdown-insert-list-item
           "i!" 'markdown-insert-header-setext-1
           "i-" 'markdown-insert-hr
           "i1" 'markdown-insert-header-atx-1
           "i2" 'markdown-insert-header-atx-2
           "i3" 'markdown-insert-header-atx-3
           "i4" 'markdown-insert-header-atx-4
           "i5" 'markdown-insert-header-atx-5
           "i6" 'markdown-insert-header-atx-6
           "i@" 'markdown-insert-header-setext-2
           "iC" 'markdown-insert-gfm-code-block
           "iH" 'markdown-insert-header-setext-dwim
           "i[" 'markdown-insert-gfm-checkbox
           "ib" 'markdown-insert-bold
           "ic" 'markdown-insert-code
           "ie" 'markdown-insert-italic
           "if" 'markdown-insert-footnote
           "ii" 'markdown-insert-italic
           "ik" 'markdown-insert-kbd
           "ip" 'markdown-insert-pre
           "iq" 'markdown-insert-blockquote
           "is" 'markdown-insert-strike-through

           "ih"  "header"
           "ih!" 'markdown-insert-header-setext-1
           "ih1" 'markdown-insert-header-atx-1
           "ih2" 'markdown-insert-header-atx-2
           "ih3" 'markdown-insert-header-atx-3
           "ih4" 'markdown-insert-header-atx-4
           "ih5" 'markdown-insert-header-atx-5
           "ih6" 'markdown-insert-header-atx-6
           "ih@" 'markdown-insert-header-setext-2
           "ihH" 'markdown-insert-header-setext-dwim
           "ihh" 'markdown-insert-header-dwim
           "ihs" 'markdown-insert-header-setext-2
           "iht" 'markdown-insert-header-setext-1

           "il"  "link"
           "ill" 'markdown-insert-link
           "ilf" 'markdown-insert-footnote
           "ilu" 'markdown-insert-uri
           "ilw" 'markdown-insert-wiki-link

           ;; delete/kill
           "d"  "delete"
           "dd" 'markdown-kill-thing-at-point
           "db" 'markdown-kill-block
           "do" 'markdown-kill-outline
           "dy" 'markdown-kill-ring-save

           ;; toggles
           "M"  "toggle"
           "Mm" 'markdown-toggle-math
           "Mf" 'markdown-toggle-fontify-code-blocks-natively
           "Mi" 'markdown-toggle-inline-images
           "Mu" 'markdown-toggle-url-hiding
           "Mm" 'markdown-toggle-markup-hiding
           "Mc" 'markdown-toggle-gfm-checkbox
           "Ml" 'markdown-live-preview-mode

           ;; narrowing
           "n"  "narrow"
           "nb" 'markdown-narrow-to-block
           "np" 'markdown-narrow-to-page
           "ns" 'markdown-narrow-to-subtree
           "nw" 'widen

           ;; marks
           "m"  "mark"
           "ms" 'markdown-mark-subtree
           "mb" 'markdown-mark-block

           ;; table
           "t"  "table"
           "ts" 'markdown-table-sort-lines
           "tT" 'markdown-table-transpose
           "tt" 'markdown-insert-table
           "tn" 'markdown-insert-table
           "tc" 'markdown-table-convert-region

           "ti"  "insert"
           "tir" 'markdown-table-insert-row
           "tic" 'markdown-table-insert-column
           "tit" 'markdown-insert-table

           "td"  "delete"
           "tdr" 'markdown-table-delete-row
           "tdc" 'markdown-table-delete-column))
     #+END_SRC

*** cmake
**** cmake-mode
     #+BEGIN_SRC emacs-lisp
       (use-package cmake-mode
         :ensure t
         :defer  t
         :mode "CMakeLists\\.txt\\|\\.cmake"
         :hook (cmake-mode . flycheck-mode)
         :config
         (company/configure-mode (cmake-mode :major t)
           company-cmake))
     #+END_SRC

**** company-cmake
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'cmake-mode
         (use-package company-cmake
           :defer  t
           :commands company-cmake))
     #+END_SRC

*** C-C++
**** company-c-headers
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'cc-mode
         (use-package company-c-headers
           :ensure t
           :defer  t))
     #+END_SRC

**** cc-mode
     #+BEGIN_SRC emacs-lisp
       (use-package cc-mode
         :straight (cc-mode :type built-in)
         :defer t
         :mode ("\\.h$" . c-mode)
         :commands (mohkale//set-c-mode-bindings)
         :hook (
                ;; use global-ycmd-mode manually
                ;; (c-mode   . ycmd-mode)
                ;; (c++-mode . ycmd-mode)
                (c-mode   . flycheck-mode)
                (c++-mode . flycheck-mode))
         :config
         (c-toggle-auto-newline  +1)
         ;; WARN never do this, it breaks commenting in
         ;;      weird places.
         ;; (c-toggle-comment-style +1)

         (setq c-default-style "stroustrup")

         ;; (company/configure-mode ((c-mode c++-mode) :major t :predicate ycmd-mode)
         ;;   company-ycmd company-c-headers)

         (defun mohkale//set-c-mode-bindings (mode)
           (leader/set-keys-for-major-mode mode
             "S" 'c-set-style
             "D" 'c-display-defun-name
             "m" 'c-mark-function
             "r" 'c-indent-defun
             "/" 'c-backslash-region
             "\\" 'c-toggle-comment-style
             "DEL" 'c-hungry-delete-forward
             "M-DEL" 'c-hungry-delete-backwards)

           (let ((mode-map (intern (concat (symbol-name mode)
                                           "mode"))))
             (general-define-key
               :keymaps 'mode-map
               "C-M-a" 'c-beginning-of-defun
               ;; "C-M-e" 'c-end-of-defun
               "M-a"   'c-beginning-of-statement
               ;; "M-e"   'c-end-of-statement
               )))

         (mohkale//set-c-mode-bindings 'c-mode)
         (mohkale//set-c-mode-bindings 'cc-mode))
     #+END_SRC

**** disaster
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'cc-mode
         (use-package disaster
           :ensure t
           :defer  t
           :init
           (dolist (mode '(c-mode c++-mode))
             (leader/set-keys-for-major-mode mode
               "D" 'disaster))))
     #+END_SRC

*** kotlin
**** kotlin-mode
     #+BEGIN_SRC emacs-lisp
       (use-package kotlin-mode
         :ensure t
         :defer  t
         :config
         (setq kotlin-tab-width 4)

         (leader/set-keys-for-major-mode 'kotlin-mode
           "r" 'kotlin-repl

           "e"     "eval"
           "e-"    'kotlin-send-line
           "e|"    'kotlin-send-block
           "er"    'kotlin-send-region
           "eb"    'kotlin-send-buffer
           "e S--" 'kotlin-send-line-and-focus
           "e S-|" 'kotlin-send-block-and-focus
           "eR"    'kotlin-send-region-and-focus
           "eB"    'kotlin-send-buffer-and-focus))
     #+END_SRC

**** lsp-kotlin
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'kotlin-mode
         (add-hook 'kotlin-mode-hook 'lsp))
     #+END_SRC

*** java
    java, the language *everyone* tolerates.

**** java-mode
    #+BEGIN_SRC emacs-lisp
      (use-package cc-mode
        :straight (cc-mode :type built-in)
        :defer t
        :init
        (with-eval-after-load 'projectile
          ;; see: https://github.com/bbatsov/projectile/blob/master/projectile.el#L2636
          (projectile-register-project-type 'gradle '("build.gradle.kts")
                                            :run     "gradle run"
                                            :compile "gradle build"
                                            :test    "gradle test"
                                            :test-suffix "Spec")

          (projectile-register-project-type 'gradlew '("gradlew")
                                            :run     "./gradlew run"
                                            :compile "./gradlew build"
                                            :test    "./gradlew test"
                                            :test-suffix "Spec"))
        :config
        (mohkale//set-c-mode-bindings 'java-mode))
    #+END_SRC

**** meghanada
    #+BEGIN_SRC emacs-lisp
      (defun mohkale/load-meghanada ()
        "load and enable the meghanada java language server package"
        (interactive)

        (use-package meghanada
          :ensure t
          :defer  t
          :delight (meghanada "MEG")
          :hook ((java-mode . meghanada-mode))
          :config
          (require 'yasnippet)

          (company/configure-mode (meghanada-mode)
            company-meghanada)

          (setq mohkale-meghanada-map (make-sparse-keymap))

          (general-define-key
            :keymaps 'mohkale-meghanada-map
            "SPC" 'meghanada-run-task
            "D"   'meghanada-typeinfo
            "G"   'meghanada-back-jump
            "F"   'meghanada-search-everywhere-ex
            "d"   'meghanada-reference ;; documentation
            "g"   'meghanada-jump-declaration
            "k"   'meghanada-server-kill
            "n"   'meghanada-server-start
            "p"   'meghanada-code-beautify
            "r"   'meghanada-restart
            "s"   'meghanada-show-project
            "f"   'meghanada-search-everywhere
            "y"   'meghanada-mode

            "cc" 'meghanada-compile-project
            "cd" 'meghanada-debug-main
            "cf" 'meghanada-compile-file
            "cr" 'meghanada-exec-main

            "Si" 'meghanada-install-server
            "Su" 'meghanada-update-server

            "ia" 'meghanada-import-all
            "il" 'meghanada-local-variable
            "io" 'meghanada-optimize-import
            "ip" 'meghanada-import-at-point

            "td"      'meghanada-debug-junit-class
            "tt"      'meghanada-switch-testcase ;; test -> file -> test
            "tf"      'meghanada-run-junit-class
            "t SPC"   'meghanada-run-junit-test-case
            "t C-SPC" 'meghanada-debug-junit-test-case)

          (leader/with-prefix mohkale--server-leader-key
            (leader/set-keys-for-major-mode '(java-mode meghanada-mode)
              ""  "meghanada"
              "c" "compile/run"
              "t" "test"
              "S" "server"
              "i" "insert/refactor")

            ;; major-mode bindings
            (leader/set-keys-for-major-mode 'java-mode
              "" mohkale-meghanada-map)

            ;; global server-key bindings
            (leader/set-keys-for-mode 'meghanada-mode
              "" mohkale-meghanada-map))))

      (mohkale/load-meghanada)
    #+END_SRC

*** javascript
    # NOTE no on the fly syntax checking? make sure eslint is installed no warning or error will be issued if it isn't :(

**** javascript-mode
     I just use this as a drop in replacement for json-mode :)

     #+BEGIN_SRC emacs-lisp
       (push '(js-mode . 2) mohkale-indent-config)
     #+END_SRC

**** js2-mode
     #+BEGIN_SRC emacs-lisp
       (use-package js2-mode
         :ensure t
         :defer  t
         :mode "\\.js$"
         :hook ((js2-mode . flycheck-mode)
                (js2-mode . javascript-enable-lsp-in-projects))
         :commands (js-jsdoc-return+)
         :init
         (defun javascript-enable-lsp-in-projects (&rest _)
           (when (project-has-file-p "package.json"
                                     "yarn.lock")
             (call-interactively 'lsp)))

         :config
         (setq js2-mode-show-parse-errors      nil
               js2-mode-show-strict-warnings   nil
               js2-strict-missing-semi-warning nil)

         (general-define-key
           :keymaps 'js2-mode-map
           [remap indent-new-comment-line] 'js-jsdoc-return+)

         (general-define-key
           :keymaps 'js2-mode-map
           :states  'insert
           ;; properly formets javadocs
           "<return>" 'js2-line-break)
           "<return>" 'js2-line-break
           "RET"      'js2-line-break)

         (leader/set-keys-for-major-mode 'js2-mode
           "i"  "insert"
           "h"  "help"
           "gg" 'js2-jump-to-definition

           ;; toggle hide-show
           "H"  "hide/show"
           "HH" 'js2-mode-show-all
           "Hw" 'js2-mode-toggle-warnings-and-errors
           "He" 'js2-mode-toggle-element
           "Hc" 'js2-mode-toggle-hide-comments
           "Hf" 'js2-mode-toggle-hide-functions

           ;; hide
           "Hh" "hide"
           "Hhw" 'js2-mode-hide-warnings-and-errors
           "Hhe" 'js2-mode-hide-element
           "Hhc" 'js2-mode-show-comments
           "Hhf" 'js2-mode-hide-functions

           ;; show
           "Hs" "show"
           "Hsw" 'js2-mode-display-warnings-and-errors
           "Hse" 'js2-mode-show-element
           "Hsc" 'js2-mode-hide-comments
           "Hsf" 'js2-mode-show-functions)

         (defun js-jsdoc-return+ (&optional arg)
           (interactive "p")
           (barf-if-buffer-read-only) ;; can't continue adding to readonly buffer.
           (setq arg (or arg 1)) ;; insert one line when arg hasn't been given.

           (let (inserted)
             (when (in-comment-p)
               (let* ((current-line (buffer-substring-no-properties
                                     (line-beginning-position)
                                     (line-end-position)))
                      (start-regexp (rx bol (zero-or-more blank) "/**"))
                      (continue-regexp (rx bol (one-or-more blank) "*"))
                      start-p continue-p)
                 (when (or (setq continue-p (string-match-p continue-regexp current-line))
                           (setq start-p    (string-match-p start-regexp    current-line)))
                   (setq inserted t)
                   (let ((start-column (line-beginning-column)))
                     (when start-p (incf start-column)) ;; one char past start column
                     (dotimes (_ arg)
                       ;; (goto-char (line-end-position))
                       (newline)
                       (insert (make-string start-column ? ) "* ")
                       (save-excursion
                         (previous-line)
                         (whitespace-cleanup-region (line-beginning-position) (line-end-position))))))))
             (unless inserted
               (dotimes (_ arg)
                 (indent-new-comment-line))))))
     #+END_SRC

**** tern
     #+BEGIN_SRC emacs-lisp :tangle no
       (with-eval-after-load 'js2-mode
         (use-package tern
           :ensure t
           :defer  t
           :hook (js2-mode . tern-mode)))
     #+END_SRC

**** company-tern
     #+BEGIN_SRC emacs-lisp :tangle no
       (with-eval-after-load 'js2-mode
         (use-package company-tern
           :ensure t
           :defer  t
           :hook (js2-mode . (lambda () (require 'company-tern)))
           :config
           (company/configure-mode (js2-mode :major t)
             company-tern)))
     #+END_SRC

**** js-doc
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'js2-mode
         (use-package js-doc
           :ensure t
           :defer  t
           :init
           ;; (general-define-key
           ;;   :keymaps 'js2-mode-map
           ;;   :states 'insert
           ;;   "@" 'js-doc-insert-tag)

           (leader/set-keys-for-major-mode 'js2-mode
             "i@" 'js-doc-insert-tag
                                               ; only works from within method
             "i)" 'js-doc-insert-function-doc
             "i(" 'js-doc-insert-function-doc-snippet
             "if" 'js-doc-insert-file-doc
             "h@" 'js-doc-describe-tag)

           :config
           (advice-add 'js-doc-insert-function-doc-snippet :after (lambda (&rest r)
                                                                    (evil-insert nil)))))
     #+END_SRC

**** js2-refactor
     #+BEGIN_SRC emacs-lisp
       ;; most of this doesn't seem to work very well...
       ;; so I'm only using a few functions with simple features.
       (with-eval-after-load 'js2-mode
         (use-package js2-refactor
           :ensure t
           :defer  t
           :diminish
           :hook (js2-mode . js2-refactor-mode)
           :config
           (defun js2r-exit-visual-mode-after-func-call (&rest args)
             (when (evil-visual-state-p)
               (evil-exit-visual-state)))

           (advice-add 'js2r-extract-method   :after #'js2r-exit-visual-mode-after-func-call)
           (advice-add 'js2r-extract-function :after #'js2r-exit-visual-mode-after-func-call)

           (leader/set-keys-for-major-mode 'js2-mode
             "[" 'js2r-expand-node-at-point
             "]" 'js2r-contract-node-at-point

             ;; doesn't work unless executed from within a function
             "e"  "extract"
             "ef" 'js2r-extract-function
             "em" 'js2r-extract-method
             "ev" 'js2r-extract-var
             "el" 'js2r-extract-let
             "ec" 'js2r-extract-const

             "l" 'js2r-log-this
             "L" 'js2r-debug-this

             "v" 'js2r-var-to-this

             "s" 'js2r-forward-slurp
             "b" 'js2r-forward-barf)))
     #+END_SRC

**** xref-js2
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'js2-mode
         (use-package xref-js2
           :ensure t
           :defer  t
           :hook (xref-backend-functions . xref-js2-xref-backend)
           :init
           (setq xref-js2-search-program 'rg)))
     #+END_SRC

**** indium
     looks cool... but tad too much setup for me & requires you to src_sh{npm install -g
     indium}.

     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package indium
         :ensure t
         :defer  t
         :config
         (setq indium-chrome-data-dir (var! "indium/chrome-profile")
               indium-workspace-file  (var! "indium/workspaces.el")))
     #+END_SRC

**** skewer-mode
     #+BEGIN_SRC emacs-lisp
       (use-package skewer-mode
         :ensure t
         :defer  t
         :delight
         (skewer-css-mode "skewerC")
         (skewer-html-mode "skewerH")
         :init
         (setq skewer-leader-prefix (concat leader-major-mode-prefix "S"))

         :config
         ;; once required, enable skewer in all
         ;; compatible buffers
         (add-hook 'js2-mode-hook 'skewer-mode)
         (add-hook 'css-mode-hook 'skewer-css-mode)
         (add-hook 'html-mode-hook 'skewer-html-mode)

         ;; (run-skewer) ;; and begin server

         (leader/with-prefix skewer-leader-prefix
           (leader/set-keys-for-mode 'skewer-mode
             "e" 'skewer-eval-last-expression
             "E" 'skewer-eval-print-last-expression
             "(" 'skewer-eval-defun
             "b" 'skewer-load-buffer

             "R" 'skewer-repl
             "L" 'skewer-bower-load
             "B" 'skewer-bower-refresh
             "p" 'skewer-run-phantomjs
             "P" 'skewer-phantomjs-kill)

           (leader/set-keys-for-mode 'skewer-html-mode
             "s" 'skewer-html-fetch-selector-into-buffer
             "e" 'skewer-html-eval-tag

             "R" 'skewer-repl
             "L" 'skewer-bower-load
             "B" 'skewer-bower-refresh
             "p" 'skewer-run-phantomjs
             "P" 'skewer-phantomjs-kill)

           (leader/set-keys-for-mode 'skewer-css-mode
             "e" 'skewer-css-eval-current-rule
             "b" 'skewer-css-eval-buffer
             "c" 'skewer-css-clear-all
             "d" 'skewer-css-eval-current-declaration

             "R" 'skewer-repl
             "L" 'skewer-bower-load
             "B" 'skewer-bower-refresh
             "p" 'skewer-run-phantomjs
             "P" 'skewer-phantomjs-kill)))
     #+END_SRC

**** typescript
     TODO implement [[https://github.com/ananthakumaran/tide][tide]].

     #+BEGIN_SRC emacs-lisp
       (use-package typescript-mode
         :ensure t
         :defer  t
         :hook (typescript-mode . javascript-enable-lsp-in-projects)
         :config
         (general-define-key
           :keymaps 'typescript-mode-map
           [remap indent-new-comment-line] 'js-jsdoc-return+))
     #+END_SRC

*** css/less
**** css-mode
     #+BEGIN_SRC emacs-lisp
       (use-package css-mode
         :defer t
         :config
         (leader/set-keys-for-major-mode 'css-mode
           "?" 'css-lookup-symbol
           "b" 'web-beautify-css)

         (company/configure-mode (css-mode :major t)
           company-css))
     #+END_SRC

**** less-css-mode
     #+BEGIN_SRC emacs-lisp
       (use-package less-css-mode
         :defer t
         :config
         (leader/set-keys-for-mode 'less-css-mode
           "c" 'less-css-compile))
     #+END_SRC

**** skewer-less
     #+BEGIN_SRC emacs-lisp
       (use-package skewer-less
         :ensure t
         :defer  t
         :init
         (with-eval-after-load 'skewer-mode
           (add-hook 'less-css-mode-hook 'skewer-less-mode))

         (leader/with-prefix skewer-leader-prefix
           (leader/set-keys-for-mode 'skewer-less-mode
             "b" 'skewer-less-eval-buffer
             "r" 'skewer-less-eval-region)))
     #+END_SRC

*** haskell
**** hindent
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'haskell-mode
         (use-package hindent
           :ensure t
           :defer  t
           :hook (haskell-mode . hindent-mode)))
     #+END_SRC

**** company-cabal
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'haskell-mode
         (use-package company-cabal
           :ensure t
           :defer  t))
     #+END_SRC

**** flycheck-haskell
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'haskell-mode
         (use-package flycheck-haskell
           :ensure t
           :defer  t))
     #+END_SRC

**** haskell-mode
     #+BEGIN_SRC emacs-lisp
       (use-package haskell-mode
         :ensure t
         :defer  t
         :init
         (push 'haskell-interactive-mode whitespace-exempt-modes)
         (push 'inferior-haskell-mode whitespace-exempt-modes)
         (defalias 'haskell-repl #'run-haskell)

         :config
         (use-package haskell-indent
           :commands (haskell-indent-cycle))

         (company/configure-mode (haskell-cabal-mode :major t)
           company-cabal)

         (setq haskell-process-type 'cabal-repl)

         (evil-set-initial-state 'haskell-interactive-mode 'emacs)

         (general-define-key
           :keymaps 'haskell-mode-map
           "C-M-i" nil)

         (defun haskell-enable-indent-control+ ()
           (interactive)
           (haskell-indent-mode +1)
           (general-define-key
             :states  '(insert replace)
             :keymaps 'haskell-mode-map
             "<tab>" 'haskell-indent-cycle))

         (leader/set-keys-for-major-mode 'haskell-mode
           "TAB"   'haskell-indent-cycle
           "S-TAB" 'haskell-delete-indentation

           "r"  "refactor"
           "ri" 'haskell-mode-format-imports
           "rI" 'haskell-sort-imports

           "i"  "insert"
           "is" 'haskell-mode-toggle-scc-at-point
           "i|" 'haskell-indent-insert-guard
           "iw" 'haskell-indent-insert-where
           "io" 'haskell-indent-insert-other
           "i=" 'haskell-indent-insert-equal

           "s"  "session"
           "sc" 'haskell-session-change
           "sC" 'haskell-session-change-target
           "sk" 'haskell-session-kill
           "sK" 'haskell-kill-session-process))
     #+END_SRC

**** company-ghci
     #+BEGIN_SRC emacs-lisp
       ;; (use-package company-ghci
       ;;   :ensure t
       ;;   :defer  t
       ;;   :commands company-ghci)
     #+END_SRC

**** hs-lint
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'haskell-mode
         (use-package hs-lint
           :defer t
           :commands (hs-lint hs-lint-mode)))
     #+END_SRC

**** hlint-refactor-mode
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'haskell-mode
         (use-package hlint-refactor-mode
           :defer t
           :commands (hlint-refactor-refactor-buffer
                      hlint-refactor-refactor-at-point)))
     #+END_SRC

**** lsp-haskell
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'haskell-mode
         (with-eval-after-load 'lsp-mode
           (use-package lsp-haskell
             :ensure t
             :defer  t
             :hook ((haskell-mode . lsp) ;; order of evaluation matters
                    (haskell-mode . (lambda ()
                                      (require 'lsp-haskell)
                                      ;; until there's actually any useful info
                                      (setq-local lsp-eldoc-enable-hover nil))))
             :config
             (setq lsp-haskell-process-args-hie (list "-d" "-l" (make-temp-file "hie." nil ".log"))))))
     #+END_SRC

*** git
    I'm not ashamed to admit... 89% of everything here is just shamelessly stollen [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%252Bsource-control/git/packages.el][spacemacs]]. and before you say it, git is a language... +or at least my OCD needs it to be+ just look at all those proprietary formats:

    - gitignore
    - gitcontrol
    - gitconfig
    - gitattributes

    okay... I made one of those up, but can you honestly tell me which one before looking below :P

**** magit
    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :ensure t
        :defer  t
        :init
        (setq magit-completing-read-function 'ivy-completing-read
              magit-revision-show-gravatars  '("^Author:     " . "^Commit:     ")
              ;; show magit status in a full screen window.
              magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1)

        ;; On Windows, we must use Git GUI to enter username and password. See [[https://github.com/magit/magit/wiki/FAQ#windows-cannot-push-via-https][here]].
        (when (eq window-system 'w32)
          (setenv "GIT_ASKPASS" "git-gui--askpass"))

        (leader/with-prefix "g"
          (leader/set-keys
            ""  "magit"
            "$" 'magit-process-buffer
            "!" 'magit-run
            "g" 'magit-dispatch
            "s" 'magit-status
            "u" 'magit-unstage-file
            "h" 'magit-log-buffer-file))

        :config
        (advice-add 'magit-section-up :around
                    (defun magit-section-up--adjust-destination (func &rest args)
                      (cond
                       ((magit-diff-inside-hunk-body-p)
                        (magit-section-goto (magit-current-section)))
                       (t (apply func args)))))

        (setq whitespace-exempt-modes
              (append '(magit-status-mode
                        magit-log-mode
                        magit-diff-mode)
                      whitespace-exempt-modes))

        (leader/set-keys-for-mode 'magit-log-select-mode
          "," 'magit-log-select-pick
          "q" 'magit-log-select-quit)

        (general-define-key
          :states evil-magit-state
          :keymaps 'magit-mode-map
          "gl" 'magit-section-forward)

        (general-define-key
          :states evil-magit-state
          :keymaps 'magit-diff-mode-map
          "gh" 'magit-section-up)

        ;; GIVE ME BACK MY LEADER!!!
        (general-define-key
          :keymaps '(magit-mode-map magit-diff-mode-map)
          leader-key nil
          "C-w" mohkale-window-map)

        (general-define-key
          :keymaps 'magit-mode-map
          "M-j" 'magit-section-forward-sibling
          "M-k" 'magit-section-backward-sibling

          ;; ;; toggle children doesn't seem to work
          ;; "C-r" 'magit-section-hide-children ; recursive close
          ;; "C-e" 'magit-section-show-children ; recursive expand
          ;; "M-r" 'magit-section-hide-children ; Meta aliases
          ;; "M-e" 'magit-section-show-children ; Meta aliases

          ;; visit and expand
          "RET"   'magit-section-toggle
          "TAB"   'magit-section-toggle
          "M-RET" 'magit-visit-thing)

        (general-define-key
          :keymaps 'magit-log-mode-map
          "RET" 'magit-visit-thing)

        (leader/with-major-mode-prefix
          (leader/set-keys-for-mode 'git-commit-mode
            "s"  'git-commit-save-message
            "d"  'magit-diff-while-committing
            "j"  'git-commit-next-message
            "k"  'git-commit-prev-message

            "i"  "insert"
            "ia" 'git-commit-ack ;; knowledgement
            "iS" 'git-commit-suggested
            "im" 'git-commit-modified
            "ic" 'git-commit-cc
            "ir" 'git-commit-reported
            "iR" 'git-commit-review
            "is" 'git-commit-signoff
            "it" 'git-commit-test)))
    #+END_SRC

**** gitattributes-mode
     #+BEGIN_SRC emacs-lisp
      (use-package gitignore-mode
        :ensure t
        :defer  t)
     #+END_SRC

**** gitconfig-mode
     #+BEGIN_SRC emacs-lisp
      (use-package gitconfig-mode
        :ensure t
        :defer  t)
     #+END_SRC

**** gitignore-mode
     #+BEGIN_SRC emacs-lisp
      (use-package gitattributes-mode
        :ensure t
        :defer  t)
     #+END_SRC

**** gitlink
     #+BEGIN_SRC emacs-lisp
       (use-package git-link
          :ensure t
          :defer  t
          :init
          (leader/set-keys
            "gy"  "links"
            "gyl" 'git-link
            "gyc" 'git-link-commit
            "gyh" 'git-link-homepage)

          ;; default is to open the generated link
          (setq git-link-open-in-browser nil))
     #+END_SRC

**** transient
     #+BEGIN_SRC emacs-lisp
       (use-package transient
          :ensure t
          :defer  t
          :config
          (setq transient-history-file (var! "transient/history.el")
                transient-values-file (etc! "transient/values.el")
                transient-levels-file (etc! "transient/levels.el"))

          (general-define-key
            :keymaps 'transient-base-map
            ;;; escape means quit too
            "ESC" 'transient-quit-one))
     #+END_SRC

**** magit-svn
     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package magit-svn
         :hook (magit-mode . turn-on-magit-svn)
         ;; TODO add some bindings
         )
     #+END_SRC

**** orgit
     #+BEGIN_SRC emacs-lisp :tangle no
       (use-package orgit
         :ensure t
         :defer  t
         :hook (org-mode . (require 'orgit)))
     #+END_SRC

**** magit-gitflow
     #+BEGIN_SRC emacs-lisp
       (use-package magit-gitflow
         :ensure t
         :defer  t
         :hook (magit-mode . turn-on-magit-gitflow)
         :delight
         (magit-gitflow-mode "GitFlow")

         :init
         (with-eval-after-load 'magit--handle-bookmark
           (general-define-key
             :keymaps 'magit-mode-map
             "%" 'magit-gitflow-popup)))
     #+END_SRC

*** plantuml
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package plantuml-mode
        :ensure t
        :defer  t)
    #+END_SRC

*** latex
    #+BEGIN_SRC emacs-lisp
      (use-package tex-mode
        :defer t
        :hook ((latex-mode . display-line-numbers-mode)
               (latex-mode . flycheck-mode))
        :init
        (setq TeX-auto-save  t
              TeX-parse-self t
              TeX-source-correlate-start-server t
              tex-print-file-extension ".pdf")

        (defvar mohkale-latex-modes '(latex-mode tex-mode)
          "list of tex related modes. used for leader and pretty symbols.")

        (push '(tex-mode   . 2) mohkale-indent-config)
        (push '(latex-mode . 2) mohkale-indent-config)

        :config
        (push 'TeX-output-mode whitespace-exempt-modes)
        (push 'TeX-special-mode whitespace-exempt-modes)

        (add-hook 'plain-TeX-mode-hook
                  (defun tex-update-electric-math+ (&rest _)
                    (setq-local TeX-electric-math '("$" . "$"))))

        (add-hook 'LaTeX-mode-hook
                  (defun latex-update-electric-math+ (&rest _)
                    (setq-local TeX-electric-math '("\\(" . "\\)"))))

        ;; show process output on error
        (advice-add 'TeX-command-sentinel :after
                    (defun TeX-process-error-handler+ (p msg)
                      (unless (zerop (process-exit-status p))
                        (TeX-recenter-output-buffer nil))))

        ;; for some reason, focus switches back to tex buffer
        (advice-add 'TeX-recenter-output-buffer :after
                    (defun TeX-recenter-focus (&rest _)
                      (TeX-pop-to-buffer (TeX-active-buffer))))

        (eval
         `(configure-presym! ',mohkale-latex-modes
            ,@(cl-loop
               for tuple in tex--prettify-symbols-alist
               append (list (car tuple) (cdr tuple)))))

        (general-define-key
          :keymaps 'latex-mode-map
          "C-M-i" nil)

        (leader/set-keys-for-major-mode mohkale-latex-modes
          "{" 'latex-insert-block
          "}" 'latex-close-block)

        ;; (defun latex/font-bold         () (interactive) (TeX-font nil ?\C-b))
        ;; (defun latex/font-medium       () (interactive) (TeX-font nil ?\C-m))
        ;; (defun latex/font-code         () (interactive) (TeX-font nil ?\C-t))
        ;; (defun latex/font-emphasis     () (interactive) (TeX-font nil ?\C-e))
        ;; (defun latex/font-italic       () (interactive) (TeX-font nil ?\C-i))
        ;; (defun latex/font-clear        () (interactive) (TeX-font nil ?\C-d))
        ;; (defun latex/font-calligraphic () (interactive) (TeX-font nil ?\C-a))
        ;; (defun latex/font-small-caps   () (interactive) (TeX-font nil ?\C-c))
        ;; (defun latex/font-sans-serif   () (interactive) (TeX-font nil ?\C-f))
        ;; (defun latex/font-normal       () (interactive) (TeX-font nil ?\C-n))
        ;; (defun latex/font-serif        () (interactive) (TeX-font nil ?\C-r))
        ;; (defun latex/font-oblique      () (interactive) (TeX-font nil ?\C-s))
        ;; (defun latex/font-upright      () (interactive) (TeX-font nil ?\C-u))
        )

      (use-package tex-site
        :ensure auctex
        :defer  t
        :hook ((latex-mode . TeX-fold-mode)
               (latex-mode . TeX-PDF-mode))
        :init
        (defvaralias 'LaTeX-mode-hook 'latex-mode-hook)

        (defvar TeX-view-in-emacs+ nil
          "when true, view latex documents in emacs PDFTools.
      This variable should be set before requiring Auctex.")

        :config
        (defvar-local TeX-command-last nil
          "the last command invoked by TeX in this buffer.")

        (defun TeX-command-smart (&optional prompt override-confirm)
          "`TeX-command-master' but with memory.
      This function works like the master command, however by default it reruns
      the last run command instead of prompting to run the command. You can pass
      a prefix arg to force the prompt to take place.
      "
          (interactive "P")
          (unless TeX-command-last
            (setq prompt t))

          (let ((cmd (or (and prompt
                              (TeX-command-query (TeX-master-file nil nil t)))
                         TeX-command-last)))
            (setq TeX-command-last cmd) ;; update command memory
            (TeX-command cmd 'TeX-master-file override-confirm)))

        (advice-add 'TeX-command :before
                    (defun TeX-command--prompt-to-save+ (&rest args)
                      "ask to save modified tex buffers, before running commands on them."
                      (when (and (buffer-modified-p)
                                 buffer-file-name
                                 (yes-or-no-p (format "Save file %s?" buffer-file-name)))
                        (save-buffer))))

        (when TeX-view-in-emacs+
          (add-hook 'TeX-after-compilation-finished-functions
                    #'TeX-revert-document-buffer))

        (setq TeX-view-program-selection
              (delq nil
                    `(((output-dvi style-pstricks)
                       "dvips and start")
                      ,(when TeX-view-in-emacs+
                         '(output-pdf "PDF Tools"))
                      ,(when (executable-find "zathura")
                         '(output-pdf "Zathura"))
                      (output-dvi "Yap")
                      ,(when (executable-find "xdvi")
                         '(output-pdf "xdvi"))
                      (output-pdf "start")
                      (output-html "start"))))

        (general-define-key
          :states 'motion
          :keymaps 'TeX-error-overview-mode-map
          "RET" 'TeX-error-overview-goto-source
          "j" 'TeX-error-overview-next-error
          "k" 'TeX-error-overview-previous-error
          "o" 'TeX-error-overview-jump-to-source
          [remap quit-window] 'TeX-error-overview-quit)

        (leader/set-keys-for-major-mode 'TeX-error-overview-mode
          "b" 'TeX-error-overview-toggle-debug-bad-boxes
          "w" 'TeX-error-overview-toggle-debug-warnings
          "s" 'TeX-error-overview-toggle-suppress-ignored-warnings
          "l" 'TeX-error-overview-goto-log)

        (leader/set-keys-for-major-mode mohkale-latex-modes
          "SPC" 'TeX-command-master
          "b" 'LaTeX-environment ;; block but more interactive.
          "," 'TeX-command-smart
          "." 'TeX-command-run-all
          "l" 'TeX-recenter-output-buffer
          "e" 'TeX-error-overview
          "k" 'TeX-kill-job
          "v" 'TeX-view
          "h" 'TeX-doc
          "RET" 'TeX-command-run-all
          "t" 'TeX-font
          "\\" 'TeX-insert-macro
          "s" 'LaTeX-section
          "m" 'LaTeX-mark-environment ;; or LaTeX-mark-section

          ;; preview
          "p"   "preview"
          "pb"  'preview-buffer
          "pc"  'preview-clearout
          "pd"  'preview-document
          "pe"  'preview-environment
          "pf"  'preview-cache-preamble
          "pp"  'preview-at-point
          "pr"  'preview-region
          "ps"  'preview-section

          ;; fold
          "z" "fold"
          "z=" 'TeX-fold-math
          "zz" 'TeX-fold-dwim
          "zb" 'TeX-fold-buffer
          "zB" 'TeX-fold-clearout-buffer
          "ze" 'TeX-fold-env
          "zr" 'TeX-fold-region
          "zR" 'TeX-fold-clearout-region
          "zm" 'TeX-fold-macro
          "z\\" 'TeX-fold-macro
          "zp" 'TeX-fold-paragraph
          "zP" 'TeX-fold-clearout-paragraph
          "z%" 'TeX-fold-comment
          "zc" 'TeX-fold-clearout-item

          ;; indentation
          "TAB"   "indent"
          "TAB b" 'LaTeX-fill-environ
          "TAB p" 'LaTeX-fill-paragra
          "TAB r" 'LaTeX-fill-region
          "TAB s" 'LaTeX-fill-section

          ;; modes
          "M"  "mode"
          "Mp" 'TeX-PDF-mode ;; toggle between PDF and DVI output.
          "Ms" 'TeX-source-correlate-mode
          "Mi" 'TeX-interactive-mode
          "Mm" 'LaTeX-math-mode

          ;; toggle
          "T"  "toggle"
          "Tb" 'TeX-toggle-debug-bad-boxes
          "Td" 'TeX-toggle-debug-warnings
          "Ts" 'TeX-toggle-suppress-ignored-warnings))
    #+END_SRC

** Unimplemented
   :PROPERTIES:
   :header-args+: :tangle no
   :END:

*** realgud
    #+BEGIN_SRC emacs-lisp
      (use-package realgud
        :ensure t
        :defer  t
        :config
        (mohkale--comint-set-bindings 'realgud:gdb-track-mode-map)
        (general-define-key
          :keymaps 'realgud:gdb-track-mode-map
          "RET" 'realgud:send-input)

        (defun realgud--display-realgud-buffer-instead-of-switch (func &rest args)
          (let ((current-buffer (current-buffer))
                debugger-buffer)
            (apply func args) ;; invoke wrapped function

            (unless (eq current-buffer (current-buffer))
              (setq debugger-buffer (current-buffer))
              (switch-to-buffer nil) ;; last buffer
              (display-buffer debugger-buffer))))

        (advice-add #'realgud:gdb :around
                    #'realgud--display-realgud-buffer-instead-of-switch)

        (general-define-key
          :keymaps 'realgud-track-mode-map
          "<override-state>" nil))
    #+END_SRC

*** hl-anything
    See [[https://github.com/hl-anything/hl-anything-emacs][here]].

    #+BEGIN_SRC emacs-lisp
      (use-package hl-anything
        :ensure t
        :defer  t
        :commands (hl-toggle-local
                   hl-toggle-global)
        :init
        (general-define-key
          :states leader-norm-states
          "zh" 'hl-toggle-local
          "zH" 'hl-toggle-global)

        :config
        (setq hl-highlight-save-file (var! "hl-save.el"))

        (evil-define-operator hl-toggle-local (beg end)
          (if (bound-and-true-p hl-highlight-mode)
              (let ((regexp (regexp-quote (buffer-substring-no-properties beg end))))
                (when regexp
                  (if (member regexp hl-highlights-local)
                      (hl-unhighlight-internal regexp hl-highlights-local hl-colors-index-local)
                    (hl-highlight-internal regexp hl-highlights-local hl-colors-index-local))))
            (user-error "`hl-highlight-mode' is not active at the moment.")))

        (evil-define-operator hl-toggle-global (beg end)
          (if (bound-and-true-p hl-highlight-mode)
              (let ((regexp (regexp-quote (buffer-substring-no-properties beg end))))
                (when regexp
                  (if (member regexp hl-highlights)
                      (hl-unhighlight-internal regexp hl-highlights hl-colors-index)
                    (hl-highlight-internal regexp hl-highlights hl-colors-index))))
            (user-error "`hl-highlight-mode' is not active at the moment."))))
    #+END_SRC

*** keycast
    Doesn't work with evil, see [[https://github.com/emacs-evil/evil/issues/1261][here]].

    #+BEGIN_SRC emacs-lisp
      (use-package keycast
        :ensure t
        :defer  t
        :init
        (with-eval-after-load 'spaceline
          (spaceline-define-segment keycast
            "show active pressed keys in the modeline."
            (eval (nth 1 mode-line-keycast))
            :when (and active
                       (bound-and-true-p keycast-mode))))

        :config
        (advice-add #'keycast-mode :around
                    (cl-defun keycast--supress-user-error+ (func &rest args)
                      "make keycast happy :)"
                      (let ((mode-line-format `(,keycast-insert-after
                                                ,(when (bound-and-true-p keycast-mode)
                                                   'mode-line-keycast))))
                        (apply func args))))

        (advice-add #'keycast-mode-line-update :around
                    (defun keycast--prevent-mode-line-update+ (func &rest args)
                      "stope keycast-mode-line-update... from updating the mode-line."
                      (cl-letf (((symbol-function #'force-mode-line-update)
                                 (symbol-function #'ignore)))
                        (apply func args)))))

    #+END_SRC

*** gif-screencast
    Doesn't work, see [[*keycast][keycast]].

    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package gif-screencast
        :straight (gif-screencast :type git :host gitlab :repo "ambrevar/emacs-gif-screencast")
        :defer t)
    #+END_SRC

* Scripts
** server-installation-scripts
   #+NAME: server-install-path
   #+BEGIN_SRC emacs-lisp :results value :tangle no
     (expand-file-name (concat user-emacs-directory  "var/lsp/servers"))
   #+END_SRC

   #+NAME: set_shell_banner
   #+BEGIN_SRC emacs-lisp :var varname="BANNER" text="" width=80 char="@" :results value :tangle no
     (let* ((text-width (length text))
            (width (max width
                        (+ 4 text-width)))
            (header-string (make-string width
                                        (string-to-char char)))
            (pad-width (/ (- width 4 text-width)
                          2))
            (pad-string (make-string pad-width ? ))

            (banner (concat "\n"
                            char
                            " "
                            (unless (zerop (% text-width 2))
                              " ")
                            pad-string
                            text
                            pad-string
                            " "
                            char
                            "\n")))
       (format "%s='\n%s\n'"
               varname
               (concat header-string
                       banner
                       header-string)))
   #+END_SRC

*** kotlin-language-server
    :PROPERTIES:
    :header-args+: :tangle bin/install/kotlin-language-server.sh
    :END:

    #+BEGIN_SRC bash :shebang #!/usr/bin/bash
      <<set_shell_banner(varname="INSTALLATION_ALREADY_DONE_BANNER",text="kotlin language server already installed",char="#")>>
      <<set_shell_banner(varname="CLONING_LANGUAGE_SERVER_BANNER",text="cloning fwcd/kotlin-language-server",char="#")>>
      <<set_shell_banner(varname="CLONING_FAILED_BANNER",text="failed to clone repository, program terminated",char="*")>>
      <<set_shell_banner(varname="CLONING_ALREADY_DONE_BANNER",text="fwcd/kotlin-language-server already cloned",char="#")>>
      <<set_shell_banner(varname="RUNNING_GRADLE_BUILD_BANNER",text="running gradle build process",char="#")>>
      <<set_shell_banner(varname="GRADLE_BUILD_FAILED_BANNER",text="failed to build kotlin language server",char="*")>>
      <<set_shell_banner(varname="FINISHED_BANNER",text="finished installing the kotlin language server",char="*")>>

      DEST_PATH="<<server-install-path()>>/kotlin"
    #+END_SRC

    #+BEGIN_SRC bash
      if [ -f "${DEST_PATH}/bin/kotlin-language-server" ]; then
          echo "${INSTALLATION_ALREADY_DONE_BANNER}"
      else
          mkdir -p "${DEST_PATH}"
          pushd "${DEST_PATH}"

          CLONE_PATH="./.server"
          if [ ! -d "${CLONE_PATH}/.git" ]; then
              echo "${CLONING_LANGUAGE_SERVER_BANNER}"

              if ! git clone "https://github.com/fwcd/kotlin-language-server" "${CLONE_PATH}"; then
                  echo "${CLONING_FAILED_BANNER}"
                  exit 1
              fi
          else
              echo "${CLONING_ALREADY_DONE_BANNER}"
          fi

          echo "${RUNNING_GRADLE_BUILD_BANNER}"

          pushd "${CLONE_PATH}"
          if ! ./gradlew :server:installDist; then
              echo "${GRADLE_BUILD_FAILED_BANNER}"
              exit 2
          fi
          popd

          mv ${CLONE_PATH}/server/build/install/server/* ./
          rm -rf "${CLONE_PATH}"
          echo "${FINISHED_BANNER}"
      fi
    #+END_SRC

*** kotlin-debug-adapter
    :PROPERTIES:
    :header-args+: :tangle bin/install/kotlin-debug-adapter.sh
    :END:

    #+BEGIN_SRC bash :shebang #!/usr/bin/bash
      <<set_shell_banner(varname="INSTALLATION_ALREADY_DONE_BANNER",text="kotlin debug adapter already installed",char="#")>>
      <<set_shell_banner(varname="CLONING_DEBUG_ADAPTER_BANNER",text="cloning fwcd/kotlin-debug-adapter",char="#")>>
      <<set_shell_banner(varname="CLONING_FAILED_BANNER",text="failed to clone repository, program terminated",char="*")>>
      <<set_shell_banner(varname="CLONING_ALREADY_DONE_BANNER",text="fwcd/kotlin-debug-adapter already cloned",char="#")>>
      <<set_shell_banner(varname="RUNNING_GRADLE_BUILD_BANNER",text="running gradle build process",char="#")>>
      <<set_shell_banner(varname="GRADLE_BUILD_FAILED_BANNER",text="failed to build kotlin debug adapter",char="*")>>
      <<set_shell_banner(varname="INISHED_BANNER",text="finished installing the kotlin debug adapter",char="*")>>

      DEST_PATH="<<server-install-path()>>/kotlin/debugger"
    #+END_SRC

    #+BEGIN_SRC bash
      if [ -f "${DEST_PATH}/bin/kotlin-debug-adapter" ]; then
          echo "${INSTALLATION_ALREADY_DONE_BANNER}"
      else
          mkdir -p "${DEST_PATH}"
          pushd "${DEST_PATH}"

          CLONE_PATH="./.debugger"
          if [ ! -d "${CLONE_PATH}/.git" ]; then
              echo "${CLONING_DEBUG_ADAPTER_BANNER}"

              if ! git clone "https://github.com/fwcd/kotlin-debug-adapter" "${CLONE_PATH}"; then
                  echo "${CLONING_FAILED_BANNER}"
                  exit 1
              fi
          else
              echo "${CLONING_ALREADY_DONE_BANNER}"
          fi

          echo "${RUNNING_GRADLE_BUILD_BANNER}"

          pushd "${CLONE_PATH}"
          if ! ./gradlew :adapter:installDist; then
              echo "${GRADLE_BUILD_FAILED_BANNER}"
              exit 2
          fi
          popd

          mv ${CLONE_PATH}/adapter/build/install/adapter/* ./
          rm -rf "${CLONE_PATH}"
          echo "${FINISHED_BANNER}"
      fi
    #+END_SRC

*** haskell-ide-engine
    :PROPERTIES:
    :header-args+: :tangle bin/install/haskell-ide-engine.sh
    :END:

    if your install fails with exit code 251, you're computer ran out of memory during the install process. Simply close all running programs and try again. Warning: install can take upto an hour and over 3 GB of RAM.

    #+BEGIN_SRC bash :shebang #!/usr/bin/bash
      <<set_shell_banner(varname="INSTALLATION_ALREADY_DONE_BANNER",text="haskell IDE engine already installed",char="#")>>
      <<set_shell_banner(varname="CLONING_LANGUAGE_SERVER_BANNER",text="cloning haskell/haskell-ide-engine",char="#")>>
      <<set_shell_banner(varname="CLONING_FAILED_BANNER",text="failed to clone repository, program terminated",char="*")>>
      <<set_shell_banner(varname="CLONING_ALREADY_DONE_BANNER",text="haskell/haskell-ide-engine already cloned",char="#")>>
      <<set_shell_banner(varname="RUNNING_CABAL_INSTALL_BANNER",text="running cabal installer, you may wish to free some RAM",char="#")>>
      <<set_shell_banner(varname="CABAL_INSTALL_FAILED_BANNER",text="failed to build haskell IDE engine",char="*")>>
      <<set_shell_banner(varname="FAILED_TO_MOVE_AFTER_INSTALL_BANNER",text="could not find stack install directory for server move",char="*")>>
      <<set_shell_banner(varname="FINISHED_BANNER",text="finished installing the haskell IDE engine",char="*")>>

      DEST_PATH="<<server-install-path()>>/haskell"
    #+END_SRC

    #+BEGIN_SRC bash
      BUILD_TARGET="stack-hie-8.6.5"

      if [ -f "${DEST_PATH}/hie.exe" -o -f "${DEST_PATH}/hie" ]; then
          echo "${INSTALLATION_ALREADY_DONE_BANNER}"
      else
          mkdir -p "${DEST_PATH}"
          pushd "${DEST_PATH}"

          CLONE_PATH="./.hie"
          if [ ! -d "${CLONE_PATH}/.git" ]; then
              echo "${CLONING_LANGUAGE_SERVER_BANNER}"

              if ! git clone "https://github.com/haskell/haskell-ide-engine" "${CLONE_PATH}" --recurse-submodules; then
                  echo "${CLONING_FAILED_BANNER}"
                  exit 1
              fi
          else
              echo "${CLONING_ALREADY_DONE_BANNER}"
          fi

          echo "${RUNNING_CABAL_INSTALL_BANNER}"

          pushd "${CLONE_PATH}"
          if ! cabal v2-run ./install.hs --project-file install/shake.project -j1 --ghc-options="+RTS -M600M" "${BUILD_TARGET}"; then
              echo "${CABAL_INSTALL_FAILED_BANNER}"
              exit 2
          fi
          popd

          INSTALL_PATH="$(stack path --local-bin)"
          if [ $? -eq 0 ]; then
              find "${INSTALL_PATH}/" -maxdepth 1 -iname 'hie*' -print0 | xargs -0 -i% mv % ./
              rm -rf "${CLONE_PATH}"
              echo "${FINISHED_BANNER}"
          else
              echo "${FAILED_TO_MOVE_AFTER_INSTALL_BANNER}"
          fi
      fi
    #+END_SRC

* Themes
** an old hope
   #+NAME: an-old-hope-theme-description
   #+BEGIN_EXAMPLE
      emacs theme inspired by a galaxy far far away...
      this theme is largely just a shot for shot copy of `jesseleite/an-old-hope-syntax-atom'
      ported to emacs because I refuse to live with an IDE that doesn't look like it XD.
      This theme isn't compatible with emacs in the terminal yet, when I find an easy way
      to approximate true-color colors to non-true-color colors, then I'll add support for
      it.
   #+END_EXAMPLE

*** Colors
   #+NAME: an-old-hope-theme-color-associations
   | color-name        | new-name   | hue | sat | light | description                       |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | very-light-grey   |            | 228 |   7 |    81 | shades of the millenium falcon    |
   | light-grey        |            | 228 |   7 |    55 | shades of the millenium falcon    |
   | grey              |            | 228 |   7 |    44 | shades of the millenium falcon    |
   | dark-grey         |            | 228 |   7 |    29 | shades of the millenium falcon    |
   | very-dark-grey    |            | 228 |   7 |    12 | shades of the millenium falcon    |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | vader             | red        | 352 |  81 |    58 | Vader's lightsaber                |
   | vader-dim         | red-dim    | 352 |  60 |    58 |                                   |
   | vader-int         | red-int    | 360 |  90 |    58 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | luke              | orange     |  25 |  86 |    55 | Luke's pilot uniform              |
   | luke-dim          | orange-dim |  25 |  60 |    60 |                                   |
   | luke-int          | orange-int |  25 |  86 |    65 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | threepio          | yellow     |  50 |  74 |    61 | Human cyborg relations            |
   | threepio-dim      | yellow-dim |  50 |  74 |    31 |                                   |
   | threepio-int      | yellow-int |  50 | 100 |    61 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | yoda              | green      | 107 |  40 |    57 | Fear is the path to the dark side |
   | yoda-dim          | green-dim  | 100 |  30 |    57 |                                   |
   | yoda-int          | green-int  | 120 |  50 |    57 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | artoo             | blue       | 196 |  64 |    58 | Whistle. Beep. Bloop.             |
   | artoo-dim         | blue-dim   | 200 |  44 |    58 |                                   |
   | artoo-int         | blue-int   | 220 |  84 |    64 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | purple            |            | 313 |  32 |    60 |                                   |
   | purple-dim        |            | 313 |  32 |    70 |                                   |
   | purple-int        |            | 313 |  40 |    60 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | turquoise         |            | 165 |  70 |    65 |                                   |
   | turquoise-dim     |            | 165 |  60 |    85 |                                   |
   | turquoise-int     |            | 165 |  80 |    50 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | black             |            | 240 |   6 |    14 |                                   |
   | black-dim         |            | 240 |  10 |    20 |                                   |
   | black-int         |            | 240 |   6 |    00 |                                   |
   |-------------------+------------+-----+-----+-------+-----------------------------------|
   | white             |            |   0 | 100 |   100 |                                   |
   | line-highlight-bg |            | 228 |   7 |    21 |                                   |
   | extra-dark-grey   |            | 228 |   7 |    10 | variant for imbedded org blocks   |
   | debug             |            | 198 |  91 |    13 | dark blue                         |

   #+NAME: color-assoc-to-rgb-strings
   #+HEADER: :var associations=an-old-hope-theme-color-associations
   #+BEGIN_SRC emacs-lisp :results value table :tangle no :exports none
     (require 'color)
     (require 'cl-lib)
     (require 'subr-x)

     (let (result)
       (cl-letf (((symbol-function 'smart-num)
                  (lambda (arg)
                    (if (numberp arg)
                        arg
                      (string-to-number arg)))))
         (dolist (row (cdr associations))
           (message "%s" row)
           (let* ((color-name (nth 0 row))
                  (dest-name  (progn
                                (let ((dest-name (nth 1 row)))
                                  (if (string-empty-p dest-name)
                                      color-name
                                    dest-name))))
                  (hue   (/ (smart-num (nth 2 row)) 360.0))
                  (sat   (/ (smart-num (nth 3 row)) 100.0))
                  (light (/ (smart-num (nth 4 row)) 100.0))

                  (rgb (color-hsl-to-rgb hue sat light))
                  (red   (nth 0 rgb))
                  (green (nth 1 rgb))
                  (blue  (nth 2 rgb)))
             (push (list (intern dest-name)
                         (color-rgb-to-hex red green blue 2))
                   result))))
       (reverse result))
   #+END_SRC

*** Header
   #+HEADER: :shebang ";; an-old-hope-theme.el -- a syntax theme from a galaxy far away... -*- lexical-binding: t -*-"
   #+BEGIN_SRC emacs-lisp :comments no :tangle etc/themes/an-old-hope-theme.el
     ;; Author: MoHKale
     ;; URL: https://github.com/MoHKale/an-old-hope-theme
     ;; Version: 0.1.0
     ;; Keywords: color, theme
     ;; Package-Requires: ((emacs "24"))

     ;; This file is not part of GNU Emacs

     ;; This file is free software; you can redistribute it and/or modify
     ;; it under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation; either version 3, or (at your option)
     ;; any later version.

     ;; This program is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.

     ;; For a full copy of the GNU General Public License
     ;; see <http://www.gnu.org/licenses/>.

     ;; Commentary:
     ;; see https://github.com/MoHKale/an-old-hope-theme/tree/master/emacs
   #+END_SRC

*** Faces
   #+HEADER: :var desc=an-old-hope-theme-description colors=color-assoc-to-rgb-strings() cls=(eval t)
   #+BEGIN_SRC emacs-lisp :results silent :tangle etc/themes/an-old-hope-theme.el
     (deftheme an-old-hope
       desc)

     (defun aoh-replace-color-syms (list)
       "replace occurences of color symbols in list, with colors.
     does so recursively, in a depth first manner."
       (cl-loop
        with pair = nil
        for var in list
        if (and (symbolp var)
                (not (keywordp var))
                (setq pair (assoc var colors)))
        collect (car (cdr pair))
        else if (listp var)
        collect (aoh-replace-color-syms var)
        else
        collect var
        end))

     (defmacro aoh-create-spec (face &rest spec)
       `(quote (,face ((,cls ,(aoh-replace-color-syms spec))))))
     (put 'aoh-create-spec 'lisp-indent-function 'defun)

     (with-eval-after-load 'ivy
       (defface ivy-actual-highlight-face '((t (:inherit highlight)))
         "face actually used by ivy to highlight some candidates.
     see an-old-hope-theme.el for why this is necessary."))

     (custom-theme-set-faces 'an-old-hope
      ;; defaults
      (aoh-create-spec default :background very-dark-grey :foreground very-light-grey)
      (aoh-create-spec italic :italic t :inherit default)
      (aoh-create-spec underline :inherit default)
      (aoh-create-spec shadow :foreground light-grey)
      (aoh-create-spec hl-line :background line-highlight-bg)

      (aoh-create-spec font-lock-builtin-face :foreground blue)
      (aoh-create-spec font-lock-comment-face :foreground grey)
      (aoh-create-spec font-lock-keyword-face :foreground green)
      (aoh-create-spec font-lock-constant-face :foreground red :inherit bold)
      (aoh-create-spec font-lock-function-name-face :foreground yellow-int)
      (aoh-create-spec font-lock-negation-char-face :foreground red)
      (aoh-create-spec font-lock-preprocessor-face :foreground green-dim)
      (aoh-create-spec font-lock-string-face :foreground blue)
      (aoh-create-spec font-lock-doc-face :foreground blue) ; TODO optional bg
      (aoh-create-spec font-lock-type-face :foreground red)
      (aoh-create-spec font-lock-variable-name-face :foreground yellow-int)
      (aoh-create-spec font-lock-warning-face
        :background yellow-int :distant-foreground yellow-int
        :foreground very-dark-grey :underline nil :inherit bold)

      (aoh-create-spec error   :background red    :distant-foreground red    :foreground very-dark-grey  :inherit bold)
      (aoh-create-spec success :background green  :distant-foreground green  :foreground very-dark-grey  :inherit bold)
      (aoh-create-spec warning :background yellow :distant-foreground yellow :foreground very-dark-grey  :inherit bold)

      (aoh-create-spec cursor :background red)
      (aoh-create-spec custom-button
        :background very-dark-grey
        :foreground very-light-grey
        :box (:line-width 2 :style released-button))

      (aoh-create-spec fringe :background black)
      (aoh-create-spec header-line :background very-dark-grey :foreground blue)
      (aoh-create-spec line-number :background black :foreground very-light-grey)
      (aoh-create-spec line-number-current-line :foreground blue :inherit line-number)
      (aoh-create-spec vertical-border :foreground very-light-grey)
      (aoh-create-spec internal-border :foreground white :background white)
      (aoh-create-spec minibuffer-prompt :foreground yellow :weight bold)

      (aoh-create-spec highlight :foreground very-dark-grey :background blue :distant-foreground blue :inherit bold)

      (aoh-create-spec region :background dark-grey :weight bold)
      (aoh-create-spec secondary-selection :inherit region)

      ;; face for current search match. exiting now takes you to it.
      (aoh-create-spec isearch :background purple :inherit bold)
      (aoh-create-spec isearch-fail :inherit compilation-mode-line-fail)
      (aoh-create-spec match :foreground green-dim)
      ;; face for matches other than the current match
      (aoh-create-spec lazy-highlight :background blue-int :foreground black-dim)

      ;; delimeter colors just taken from https://github.com/gastrodia/rainbow-brackets
      ;; colors 5-8 just recycle 1-4, maybe come up with more.
      (aoh-create-spec rainbow-delimiters-depth-1-face :foreground "#E6B422")
      (aoh-create-spec rainbow-delimiters-depth-2-face :foreground "#C70067")
      (aoh-create-spec rainbow-delimiters-depth-3-face :foreground "#00A960")
      (aoh-create-spec rainbow-delimiters-depth-4-face :foreground "#FC7482")
      (aoh-create-spec rainbow-delimiters-depth-5-face :foreground "#E6B422")
      (aoh-create-spec rainbow-delimiters-depth-6-face :foreground "#C70067")
      (aoh-create-spec rainbow-delimiters-depth-7-face :foreground "#00A960")
      (aoh-create-spec rainbow-delimiters-depth-8-face :foreground "#FC7482")

      ;; hyperlinks and path links
      (aoh-create-spec link         :foreground blue)
      (aoh-create-spec link-visited :foreground turquoise)

      ;;; modeline/spaceline
      (aoh-create-spec mode-line
        :background very-light-grey :foreground very-dark-grey
        :box (:line-width 1 :color very-light-grey :style none))

      (aoh-create-spec spaceline-evil-normal  :inherit mode-line :foreground very-dark-grey  :background "DarkGoldenrod2")
      (aoh-create-spec spaceline-evil-insert  :inherit mode-line :foreground very-dark-grey  :background green-int)
      (aoh-create-spec spaceline-evil-emacs   :inherit mode-line :foreground very-dark-grey  :background blue)
      (aoh-create-spec spaceline-evil-replace :inherit mode-line :foreground very-dark-grey  :background turquoise-int)
      (aoh-create-spec spaceline-evil-visual  :inherit mode-line :foreground very-light-grey :background dark-grey)
      (aoh-create-spec spaceline-evil-motion  :inherit mode-line :foreground very-dark-grey  :background purple-int)
      (aoh-create-spec spaceline-minibuffer   :inherit mode-line :foreground very-dark-grey  :background blue)

      ;; major mode indicator
      (aoh-create-spec powerline-active1
        :background black :foreground very-light-grey :inherit mode-line)
      ;; file-format + cursor-pos
      (aoh-create-spec powerline-active2
        :background black :foreground very-light-grey :inherit mode-line)

      ;;; evil
      (aoh-create-spec vimish-fold-overlay :background dark-grey :foreground green)

      ;;; flycheck
      (aoh-create-spec flycheck-info      :underline (:style wave :color green))
      (aoh-create-spec flycheck-warning   :underline (:style wave :color yellow))
      (aoh-create-spec flycheck-duplicate :underline (:style wave :color orange))
      (aoh-create-spec flycheck-incorrect :underline (:style wave :color red))

      (aoh-create-spec flycheck-fringe-info    :foreground green-int  :inherit fringe)
      (aoh-create-spec flycheck-fringe-warning :foreground yellow-int :inherit fringe)
      (aoh-create-spec flycheck-fringe-error   :foreground red-int    :inherit fringe)

      ;;; flyspell
      (aoh-create-spec flyspell-duplicate :foreground orange-dim :underline t)
      (aoh-create-spec flyspell-incorrect :foreground red-dim :underline t)

      ;;; avy
      (aoh-create-spec avy-background-face :foreground grey)
      (aoh-create-spec avy-lead-face :background red-int :foreground "white")
      (aoh-create-spec avy-lead-face-0 :background blue-int :foreground "white")
      (aoh-create-spec avy-lead-face-1 :background very-light-grey :foreground very-dark-grey)
      (aoh-create-spec avy-lead-face-2 :background purple-int :foreground "white")

      (aoh-create-spec frog-menu-border :background white :foreground white)
      (aoh-create-spec frog-menu-posframe-background-face :background very-dark-grey)

      ;;; company - intellisense
      (aoh-create-spec company-tooltip-mouse :foreground turquoise-int)
      (aoh-create-spec company-template-field :foreground turquoise-int)

      ;; scrollbar
      (aoh-create-spec company-scrollbar-bg :background very-light-grey :foreground very-light-grey)
      (aoh-create-spec company-scrollbar-fg :background dark-grey       :foreground dark-grey)

      (aoh-create-spec company-preview :foreground blue-int :weight bold :inherit hl-line)
      (aoh-create-spec company-preview-common :inherit company-preview)
      (aoh-create-spec company-preview-search :foreground orange-int :weight normal :inherit company-preview)

      ;; NOTE tooltip is the drop down menu which shows up when multiple results exist
      (aoh-create-spec company-tooltip :inherit bold
        :background very-light-grey :foreground very-dark-grey)
      (aoh-create-spec company-tooltip-selection :foreground very-light-grey :background blue-int)
      (aoh-create-spec company-tooltip-common :foreground blue-int :inherit company-tooltip)
      (aoh-create-spec company-tooltip-common-selection
        :foreground very-dark-grey :background blue-int
        :inherit company-tooltip-common)
      (aoh-create-spec company-tooltip-search :foreground orange :inherit company-tooltip)
      (aoh-create-spec company-tooltip-search-common :inherit company-tooltip-search)
      (aoh-create-spec company-tooltip-search-selection :background blue-int :inherit company-tooltip-search)

      ;; NOTE annotations are extra information in the tooltip
      (aoh-create-spec company-tooltip-annotation :weight bold :foreground grey)
      (aoh-create-spec company-tooltip-annotation-selection
        :foreground turquoise-int :background blue-int
        :inherit company-tooltip-annotation)

      ;;;; custom mode variants
      ;;; whitespace-mode
      ;; `(whitespace-trailing ((,cls (:foreground "yellow" :background ,red))))
      (aoh-create-spec whitespace-space :foreground dark-grey)
      (aoh-create-spec trailing-whitespace :background dark-grey)

      ;;; auto-highlight-symbol mode
      ;; Note: distant foreground is meaningless here because the faces are always given priority
      (aoh-create-spec ahs-definition-face :background blue-dim :distant-foreground blue-dim :foreground dark-grey)
      (aoh-create-spec ahs-edit-mode-face :background red-dim :distant-foreground red-dim :foreground very-light-grey)
      (aoh-create-spec ahs-face :background very-light-grey :foreground black :inherit bold)
      (aoh-create-spec ahs-plugin-whole-buffer-face :background blue :distant-foreground green :foreground black)
      (aoh-create-spec ahs-plugin-bod-face :background blue-int :distant-foreground blue-int :foreground black)
      (aoh-create-spec ahs-plugin-defalt-face :background orange-dim :distant-foreground orange-dim :foreground black)
      (aoh-create-spec ahs-warning-face :foreground red-dim)

      ;;; compilation mode
      (aoh-create-spec compilation-line-number :foreground yellow)
      (aoh-create-spec compilation-column-number :inherit font-lock-doc-face)

      ;; NOTE also represents value count in mode line
      (aoh-create-spec compilation-error :foreground red-int :inherit bold)
      (aoh-create-spec compilation-info :foreground green-int :inherit bold)
      (aoh-create-spec compilation-warning :foreground orange-int :inherit bold)

      ;; NOTE these only represent the exit status indicator
      ;; `(compilation-mode-line-exit ((,cls (:foreground very-dark-grey))))
      ;; `(compilation-mode-line-fail ((,cls (:foreground ,very-dark-grey))))
      ;; `(compilation-mode-line-run ((,cls (:foreground ,very-dark-grey))))

      ;;; markdown-mode
      (aoh-create-spec markdown-code-face :inherit default)

      ;;; anzu
      (aoh-create-spec anzu-mode-line :foreground very-dark-grey :inherit bold)
      (aoh-create-spec anzu-mode-line-no-match :foreground red-int :inherit bold)

      ;;; hydra-posframe
      ;; for some reason... if hydra-posframe-face inherits default, internal border won't work
      (aoh-create-spec hydra-posframe-face :background very-dark-grey :foreground very-light-grey)
      (aoh-create-spec hydra-posframe-border-face :inherit internal-border)

      ;;; ivy
      ;; by default, it seems if ivy-highlight-face has its own spec, it'll interfere
      ;; with the face of ivy-current-match. Which'll make it harder to tell which
      ;; candidate is the current candidate.
      ;;
      ;; If ivy-highlight-face just inherits another face, then when both it and
      ;; ivy-current-match are applied to a string, ivy-current-match will override
      ;; ivy-highlight-face. Thus, this.
      (aoh-create-spec ivy-actual-highlight-face
        :foreground very-dark-grey :background turquoise
        :distant-foreground turquoise :inherit bold)
      (aoh-create-spec ivy-highlight-face :inherit ivy-actual-highlight-face)

     ;;; org-mode
      (aoh-create-spec org-link :foreground blue :inherit bold)
      (aoh-create-spec org-footnote :foreground blue)

      ;; Overridden by hl-todo-keyword-faces
      (aoh-create-spec org-todo :foreground purple-int :inherit bold)
      (aoh-create-spec org-done :foreground green-int :inherit bold)

      (aoh-create-spec org-upcoming-deadline :foreground red-dim)
      (aoh-create-spec org-warning :foreground orange :inherit bold)
      (aoh-create-spec org-scheduled-today :foreground green-int)
      (aoh-create-spec org-block-begin-line
        :background "royalblue4" :distant-foreground "royalblue4"
        :foreground "steelblue1" :extend t)
      (aoh-create-spec org-meta-line :inherit (font-lock-comment-face))

      (aoh-create-spec org-block :background extra-dark-grey :extend t)
      (aoh-create-spec org-document-title :foreground "white" :height 1.3 :inherit bold)

      ;;; dashboard
      (aoh-create-spec dashboard-text-banner :foreground orange-int)

      ;;; eshell-prompt-extras
      (aoh-create-spec epe-remote-face :foreground turquoise)
      (aoh-create-spec epe-venv-face :foreground purple)

      ;;; magit
      (aoh-create-spec magit-mode-line-process-error
        :foreground red :background very-light-grey :inherit bold)

      ;;; typescript
      (aoh-create-spec typescript-primitive-face :inherit font-lock-type-face)

      ;;; latex
      (aoh-create-spec font-latex-sedate-face       :inherit font-lock-keyword-face)
      (aoh-create-spec font-latex-sectioning-0-face :inherit font-lock-function-name-face)
      (aoh-create-spec font-latex-sectioning-1-face :inherit font-lock-function-name-face)
      (aoh-create-spec font-latex-sectioning-2-face :inherit font-lock-function-name-face)
      (aoh-create-spec font-latex-sectioning-3-face :inherit font-lock-function-name-face)
      (aoh-create-spec font-latex-sectioning-4-face :inherit font-lock-function-name-face)
      (aoh-create-spec font-latex-sectioning-5-face :inherit font-lock-function-name-face)

      ;;; man/woman
      (aoh-create-spec Man-underline :foreground green-int :inherit bold)
      (aoh-create-spec woman-addition :foreground purple)
      (aoh-create-spec woman-bold :foreground red :inherit bold)
      (aoh-create-spec woman-unknown :inherit error)
      (aoh-create-spec woman-italic :foreground green)
      )

     (custom-theme-set-variables 'an-old-hope
       `(hl-todo-keyword-faces
         (quote
          ,(cl-loop for elem in (aoh-replace-color-syms
                                 '(("TODO"        red)
                                   ("NEXT"        red)
                                   ("RANT"        red)
                                   ("SEE"         red)
                                   ("THEM"        purple)
                                   ("PROG"        blue-int)
                                   ("OKAY"        blue-int)
                                   ("DONT"        green-int)
                                   ("FAIL"        red)
                                   ("DONE"        green-int)
                                   ("NOTE"        yellow-int)
                                   ("KLUDGE"      yellow-int)
                                   ("HACK"        yellow-int)
                                   ("TEMP"        yellow-int)
                                   ("FIXME"       orange)
                                   ("WARN"        orange)
                                   ("XXX+"        orange)
                                   ("\\?\\?\\?+"  orange)))
                    collect (cons (car elem) (car (cdr elem)))))))

     (provide-theme 'an-old-hope)
   #+END_SRC

* Deprecated
  :PROPERTIES:
  :header-args+: :tangle no
  :END:

