# -*- mode: org; coding: utf-8-unix -*-

#+TITLE: mohkale.org
#+STARTUP: content

#+PROPERTY: header-args :tangle yes :comments link :mkdirp yes :noweb yes

# NOTE: <escape> is for gui
#       ESC      if for cli

* Configuration
** init.el
*** Startup Optimisations
optimise emacs startup times as much as possible.
#+begin_src emacs-lisp :shebang ";; -*- lexical-binding: t; coding: utf-8-unix -*-"
  ;; make garbage collector less invasive
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)

  ;; not needed at startup
  (setq default-file-name-handler-alist file-name-handler-alist
        file-name-handler-alist nil)

  (add-hook 'emacs-startup-hook
            (defun mohkale//post-init-handler (&rest args)
              ;; reset optimisation changes
              (setq gc-cons-threshold 800000
                    gc-cons-percentage 0.1
                    file-name-handler-alist default-file-name-handler-alist)

              ;; switch focus to any error or compilation windows
              (let* ((window-list  (window-list))
                     (window-count (length window-list))
                     (focus-list   '("*Warnings*"
                                     "*Compile-Log*")))
                (when (> window-count 1)
                  (dolist (window (window-list))
                    (when (member (buffer-name (window-buffer window)) focus-list)
                      (select-window window)))))

              ;; load my custom emacs theme
              (load-theme 'an-old-hope)))
#+end_src
*** Emacs Sanitize
make emacs less like... emacs. use saner defaults and make emacs look nicer in general
#+begin_src emacs-lisp
  (setq delete-old-versions -1                                                  ; delete excess backup versions silently
        version-control t                                                       ; use version control
        vc-make-backup-files t                                                  ; make backups in vc as well
        vc-follow-symlinks t                                                    ; no confirmation when opening symlinks
        ring-bell-function 'ignore                                              ; NO ANNOYING RINGS!!!
        sentence-end-double-space nil                                           ; sentence SHOULD end with only a fullstop
        default-fill-column 150                                                 ; toggle wrapping text at given character
        delete-by-moving-to-trash t

        display-line-numbers 'relative

        enable-recursive-minibuffers t
        kill-whole-line              t ; kill-line includes eol
        help-window-select           t ; always

        which-key-enable-extended-define-key t

        ; Always Use UTF8, NO CARRIAGE RETURNS
        ; this... might be overkill. see setq-default
        ;; coding-system-for-read  'utf-8-unix
        ;; coding-system-for-write 'utf-8-unix

        frame-title-format
            ;; sets the title string displayed on the frame above. Format of the command is
            ;; a printf like string. Wrap any code you want evaluated conditionally into a list
            ;; and if the first value of that list is a string, it will be evaluated. You can
            ;; include variables anywhere in the string, including sublists, but no functions.
            ;;
            ;; See the format guide here: https://www.emacswiki.org/emacs/FrameTitle
        `(,(user-login-name) "@" ,(system-name) " [%*] %m" major-mode (buffer-file-name " : %f")))

  (setq-default indent-tabs-mode nil
                evil-want-C-u-scroll t
                save-place t ; auto enable save-place mode
                show-trailing-whitespace t
                scroll-conservatively 101 ; smooth... enough scrolling going line by line
                scroll-preserve-screen-position t
                default-buffer-file-coding-system 'utf-8-unix
                buffer-file-coding-system 'utf-8-unix
                echo-keystrokes 0.02)

  (set-face-attribute 'default nil
                      :family "Source Code Pro"
                      ;; height value is 1/10pt. so 100 = 10pt
                      :height (if (eq system-type 'gnu/linux) 110 100)
                      :weight 'normal
                      :width 'normal)

  (defalias 'yes-or-no-p 'y-or-n-p)

  ;;; disable annoying GUI enhancements
  (menu-bar-mode -1)     ; dropdown menu list below frame title
  (scroll-bar-mode -1)   ; scrolling bar shown on frames right side
  (tool-bar-mode -1)     ; short mini menu showed below the menu bar
  (blink-cursor-mode -1) ; cursor flashes annoyingly

  ;; frankly, display buffers alist is badly documented.
  ;; there's a quick and simple article exploring how it
  ;; works [[here][https://www.simplify.ba/articles/2016/01/25/display-buffer-alist/]]
  ;;
  ;; in the meantime, the following is a breif~er~ summary
  ;;   1. the car of each entry should be a regex matching a buffer
  ;;      name or a function taking a buffer and an action argument.
  ;;   2. the second item (car (cdr list)) should be a list of or a
  ;;      single display handler function which takes a buffer and
  ;;      an alist as an argument. Each entry in the list is invoked
  ;;      until one which returns non nil is encountered.
  ;;   3. the remaining list items should be an alists providing options.
  ;; (push '() display-buffer-alist)
#+end_src
*** Config Variables
#+begin_src emacs-lisp
  (defvar mohkale-should-compile-config nil
    "when truthy, building the configuration file also compiles the lisp file")

  (defvar mohkale-preferred-indent 4
    "preferred indentation for all modes")

  (defun mohkale/refresh-config-file-p ()
    "true if config org file needs to be retangled and/or compiled
  see https://snipplr.com/view/14292/autocompiled-emacs-file/ for example

  NOTE assumes tangled elisp file exists... otherwise what's calling this."
    ;; checks in order:
    ;;     * compiled file doesn't exist when it should
    ;;     * config file is newer than tangled file
    ;;     * tangled file is newer than compiled file (if it should exists)
    ;;
    ;; That last check shouldn't be necessary, but better safe than sorry.
    (or (and mohkale-should-compile-config
             (not (file-exists-p mohkale-mohkale-elc-config-file)))
        (file-newer-than-file-p mohkale-mohkale-config-file
                                mohkale-mohkale-el-config-file)
        (and mohkale-should-compile-config
             (file-newer-than-file-p mohkale-mohkale-el-config-file
                                     mohkale-mohkale-elc-config-file))))

  ;; (add-hook 'kill-emacs-hook (lambda () (and (mohkale/refresh-config-file-p)
  ;;                                            (mohkale/build-configuration-file))))

  (add-hook 'emacs-startup-hook (lambda ()
                                  (when (mohkale/refresh-config-file-p)
                                    (display-warning 'init
                                                     "your configuration file is out of date... please run <SPC f e b> followed by <SPC f e r>"))))
#+end_src
*** Paths Setup
#+begin_src emacs-lisp :var --mohkale-config-file=(buffer-file-name)
  (require 'bytecomp)

  (defun join-path (root path &rest args)
    "like pythons os.path.join, join a series of path strings together.
  does no validation check, every path is assumed to be relative."
    (if (not args)
        (concat root "/" path)
      (apply 'join-path (concat root "/" path) args)))

  (defmacro mohkale//initialise-dotemacs-path (path-type path)
    (let* ((path-type (symbol-name path-type))
           (path-sym (intern (concat "mohkale-dotemacs-" path-type "-path"))))
      `(progn
         (defconst ,path-sym (concat user-emacs-directory ,path))

         (defun ,(intern (concat "mohkale/join-dotemacs-" path-type "-path")) (path &rest args)
           (apply 'join-path ,path-sym path args)))))
  (put 'mohkale//initialise-dotemacs-path 'lisp-indent-function 'defun)

  ;; inspiration: https://github.com/emacscollective/no-littering/blob/master/no-littering.el
  (mohkale//initialise-dotemacs-path etc "etc")
  (mohkale//initialise-dotemacs-path bin "bin")
  (mohkale//initialise-dotemacs-path var "var")

  (defconst mohkale-config-root (mohkale/join-dotemacs-etc-path "mohkale")
    "path to the configuration directory under which my general purpose
  configuration files will reside.")

  (defconst mohkale-package-root (mohkale/join-dotemacs-bin-path "mohkale")
    "path to where any tangled executeable elisp files should reside")

  (defconst mohkale-mohkale-config-file --mohkale-config-file
    "path to my custom user config file.")

  (defconst mohkale-mohkale-el-config-file (concat (file-name-sans-extension
                                                    mohkale-mohkale-config-file)
                                                   ".el")
    "path to my custom user config file after being tangled into emacs lisp.")

  (defconst mohkale-mohkale-elc-config-file (byte-compile-dest-file mohkale-mohkale-el-config-file)
    "path to my custom user config file after being tangled into emacs lisp and then compiled.")

  ;; don't store customisations in here. They're really ugly :(
  (let ((custom-file-path (mohkale/join-dotemacs-etc-path "custom.el")))
    (setq custom-file custom-file-path)

    (if (file-exists-p custom-file-path)
        (load custom-file-path)))

  ;;; cleanup the ~/.emacs.d directory ~~litterbox~~ by resetting most of the default emacs paths.
  ;; most changes have been taken from: https://github.com/emacscollective/no-littering/blob/master/no-littering.el

  (cl-letf (((symbol-function #'etc) (symbol-function #'mohkale/join-dotemacs-etc-path))
            ((symbol-function #'bin) (symbol-function #'mohkale/join-dotemacs-bin-path))
            ((symbol-function #'var) (symbol-function #'mohkale/join-dotemacs-var-path)))
    (with-no-warnings
      (setq
       package-user-dir                                   (bin "elpa/")
       external-packages-directory                        (bin "misc")

       abbrev-file-name                                   (var "abbrev.el")
       auto-insert-directory                              (etc "auto-insert")
       auto-save-list-file-prefix                         (var "auto-save" "sessions/")
       auto-save-file-name-transforms                     `((".*" ,(var "auto-save" "sessions/") t))
       backup-directory-alist                             (list (cons ".*" (var "backups/")))
       bookmark-default-file                              (etc "bookmarks.el")
       desktop-dirname                                    (var "desktop/")
       desktop-path                                       (list desktop-dirname)
       diary-file                                         (var "diary")
       eshell-directory-name                              (var "eshell")
       eww-bookmarks-directory                            (var "eww/")
       gamegrid-user-score-file-directory                 (var "gamegrid/")
       ido-save-directory-list-file                       (var "ido-save-directory-list.el")
       image-dired-db-file                                (var "image-dired" "db.el") ; tag associations
       image-dired-dir                                    (var "image-dired/")
       image-dired-gallery-dir                            (var "image-dired" "gallery/")
       image-dired-temp-image-file                        (var "image-dired" "temp-image")
       image-dired-temp-rotate-image-file                 (var "image-dired" "temp-rotate-image")
       kkc-init-file-name                                 (var "kkc-init.el")
       message-auto-save-directory                        (var "messages/")
       meghanada-server-install-dir                       (var "meghanada")
       newsticker-cache-filename                          (var "newsticker/cache.el")
       newsticker-dir                                     (var "newsticker/data/")
       nsm-settings-file                                  (var "nsm-settings.el")
       omnisharp-cache-directory                          (var "omnisharp/cache")
       org-clock-persist-file                             (var "org/clock-persist.el")
       org-id-locations-file                              (var "org/id-locations.el")
       org-publish-timestamp-directory                    (var "org/timestamps/")
       org-registry-file                                  (var "org/registry.el")
       recentf-save-file                                  (var "recentf.el")
       save-place-file                                    (var "save-place.el")
       savehist-file                                      (var "savehist.el")
       server-auth-dir                                    (var "server/")
       shared-game-score-directory                        (var "gamescore/")
       tramp-auto-save-directory                          (var "tramp/auto-save/")
       tramp-persistency-file-name                        (var "tramp/persistency.el")
       url-cache-directory                                (var "url/cache/")
       url-configuration-directory                        (var "url/configuration/")

       ;;; third party
       ac-comphist-file                                   (var "ac-comphist.el")
       anaconda-mode-installation-directory               (var "anaconda/")
       bbdb-file                                          (var "bbdb/bbdb.el")
       bbdb-vcard-directory                               (var "bbdb/vcard/")
       bm-repository-file                                 (var "bm-repository.el")
       bmkp-current-bookmark-file                         (var "bmkp/current-bookmark.el")
       bmkp-last-bookmark-file                            (var "bmkp/last-bookmark.el")
       bookiez-file                                       (var "bookiez")
       company-statistics-file                            (var "company/statistics.el")
       company-tabnine-binaries-folder                    (var "company/tabnine-binaries")
       debbugs-gnu-persistency-file                       (var "debbugs.el")
       dired-recent-directories-file                      (var "dired/recent.el")
       elfeed-db-directory                                (var "elfeed/db/")
       elfeed-enclosure-default-dir                       (var "elfeed/enclosures/")
       elmo-msgdb-directory                               (var "elmo/")
       elmo-split-log-file                                (var "elmo/split-log")
       emms-directory                                     (var "emms/")
       emojify-emojis-dir                                 (var "emojify/")
       geben-temporary-file-directory                     (var "geben/")
       helm-adaptive-history-file                         (var "helm/adaptive-history.el")
       helm-backup-path                                   (var "helm/backup/")
       helm-github-stars-cache-file                       (var "helm/github-stars-cache.el")
       httpd-root                                         (var "simple-httpd/")
       indium-workspace-file                              (var "indium/workspaces.el")
       irfc-directory                                     (var "irfc/")
       keyfreq-file                                       (var "keyfreq.el")
       keyfreq-file-lock                                  (var "keyfreq.lock")
       logview-cache-filename                             (var "logview-cache")
       logview-views-file                                 (etc "logview-views")
       lsp-session-file                                   (var "lsp/session")
       lsp-server-root                                    (var "lsp/servers")
       multi-compile-history-file                         (var "multi-compile-history.el")
       pcache-directory                                   (var "pcache/")
       persp-save-dir                                     (var "perspectives/")
       prescient-save-file                                (var "prescient-save.el")
       projectile-cache-file                              (var "projectile/cache.el")
       projectile-known-projects-file                     (var "projectile/known-projects.el")
       purpose-default-layout-file                        (etc "window-purpose/default-layout.el")
       purpose-layout-dirs                                (list (etc "window-purpose/layouts/"))
       request-storage-directory                          (var "requests")
       smex-save-file                                     (var "smex-save.el")
       tldr-directory-path                                (var "tldr/")
       transient-history-file                             (var "transient/history.el")
       transient-levels-file                              (etc "transient/levels.el")
       transient-values-file                              (etc "transient/values.el")
       treemacs-persist-file                              (var "treemacs/persist.org")
       vimish-fold-dir                                    (var "vimish-fold/")
       yasnippet-snippets-dir                             (etc "yasnippet" "snippets/")
       yas-snippet-dirs                                   '(yasnippet-snippets-dir)
       )

      (let ((list (list (join-path lsp-server-root
                                   "kotlin"
                                   "bin")
                        (join-path lsp-server-root
                                   "kotlin"
                                   "debugger"
                                   "bin")
                        (join-path lsp-server-root
                                   "haskell"))))
        (setq exec-path (append exec-path list)))

      ;; ensure some configured paths exist at startup
      ;; TODO refactor this to only mkdir when needed
      (dolist (ensured-path '(desktop-dirname
                              eww-bookmarks-directory
                              newsticker-dir
                              external-packages-directory
                              (var "org/")
                              (var "bbdb/")
                              (var "company/")
                              (var "elfeed/")
                              (var "helm/")
                              (var "projectile/")
                              (var "bmkp/")
                              (var "emojify/")
                              (var "lsp/")
                              yasnippet-snippets-dir))
        (mkdir (if (stringp ensured-path)
                   ensured-path
                 (eval ensured-path))
               t))))

  (push mohkale-package-root load-path)
  (push (mohkale/join-dotemacs-etc-path "themes") custom-theme-load-path)
#+end_src
*** package-initialise
initialise installed packages and ensure packages needed to setup configuration from scratch is installed.

#+NAME: setup-packages-list
- which-key
- cl
- bind-map
- use-package
- general

#+begin_src emacs-lisp :var startup-requires=setup-packages-list
  ;; disable both package.el autloads
  ;; and selected packages in custom.
  (setq package-enable-at-startup  nil
        package--init-file-ensured nil)

  (package-initialize) ;; TODO find a way to remove this... without breaking everything

  (let ((package-sources `(("melpa" . "https://melpa.org/packages/")
                           ;; ("org"       . "http://orgmode.org/elpa/")
                           ;; ("marmalade" . "http://marmalade-repo.org/packages/")
                           ("gnu"       . "http://elpa.gnu.org/packages/"))))
    (dolist (source package-sources)
      (push source package-archives)))

  (let ((plist-refreshed nil))
    (dolist (package startup-requires)
      ;; iterate for all required packages
      (setq package (intern (car package)))
      (unless (package-installed-p package)
        (unless plist-refreshed
          (package-refresh-contents)
          (setq plist-refreshed t))

        (package-install package))
      (require package)))
#+end_src
*** External Packages
 Install the following the packages directly, compare against the hash value when given and then begin package initialisation.

#+NAME: non-melpa-packages
| name             | hash            | url                                                                                  |
|------------------+-----------------+--------------------------------------------------------------------------------------|
|                  | <15>            |                                                                                      |
| hide-comnt       | 0eca097ae073b6536863492eb4d4beeb25b712acd45e21fc0bda9f19d39e963f | https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/hide-comnt.el     |
| imenu-tree       | c4b3ae0d8b5c3e5a50c9c4b3f96fd48e309c2fae9a8902a1d649063c7b3b611c | https://www.emacswiki.org/emacs/download/imenu-tree.el                               |
| help-fns+        | c2229229a699d115b91da8692f3b8099c19608728eb402edb6f7cd6e1c81912b | https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/help-fns%2B.el    |
| vlc-rc           | c73c4e93ca7d38cda7f2b290ca1bd20ba53ee314af076fcca4c3bdf3659e8dbf | https://raw.githubusercontent.com/MoHKale/vlc-rc/master/vlc-rc.el                    |
| lorem-ipsum      | 54cb139d6c88632aaef6364a2a6c6cadbb9a5082eb5032e69b5139dcc7074d88 | https://www.emacswiki.org/emacs/download/lorem-ipsum.el                              |
| profile-dotemacs | 1d903fc16d4ab4716cf8097ddb88a5cbb3746c9e49fa3421ae147b0c383c3e7f | http://www.randomsample.de/profile-dotemacs.el                                       |
| open-junk-file   | c0b835b329758dced4ccae6c2f3fd5af16af929437110ddde00ea55dc7d47be3 | https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/open-junk-file.el |
| evil-adjust      | 9ffe7fa12b561269aafb92eb86a2021b77ccc8d6620edc6c2fc22fbcc7d92cc2 | https://raw.githubusercontent.com/troyp/evil-adjust/master/evil-adjust.el            |
| sqlite-dump      | 8277c32f3e9dad7f760b946609c918dd51f32990137f839a000fb6ff5a049939 | https://user42.tuxfamily.org/sqlite-dump/index.html                                  |
| company-cmake    | 4d682308eb4f6a4be92a4b7dcb2d181b5c26b4337799de0a308969d8babef0a2 | https://raw.githubusercontent.com/purcell/company-cmake/master/company-cmake.el      |
| transpose-frame  | a40264a07b25d2c1d8d1be341d42952329d1bbfab8c23100904627fef4f4c7b8 | https://www.emacswiki.org/emacs/download/transpose-frame.el                          |

#+begin_src emacs-lisp :var package-list=non-melpa-packages
  (defun external-packages/download-external-package (url dest-path)
    (let* ((dest-buffer (get-buffer-create "*external-packages*"))
           (download-args `("curl"              ; program
                            nil                 ; input file
                            ,dest-buffer        ; output dest
                            nil                 ; redisplay?
                            ; args
                            "-L"
                            "-o" ,dest-path
                            ,url))
           exit-code)
      (with-current-buffer dest-buffer
        (insert (format "curl: %s\n"
                        (nthcdr 4 download-args)))
        (setq exit-code (apply 'call-process download-args))
        (insert "\n"))

      exit-code))

  (defun external-packages/validate-package-hash (file dest-path hash)
    (let (result)
      (if (string-equal "" hash)
          (progn
            (display-warning 'external-packages (format "package %s has no hash check given: %s"
                                                        file
                                                        url))
            (setq result t))
        (with-temp-buffer
          (insert-file-contents dest-path)
          (let ((hash-result (secure-hash 'sha256 (buffer-string))))
            (if (string-equal hash hash-result)
                (setq result t)
              (display-warning 'external-packages (format "package %s failed with hash: %s != %s"
                                                          file
                                                          hash
                                                          hash-result))
              (delete-file dest-path)))))
      result))

  (let ((install-path external-packages-directory)
        failed-installs)
    (push install-path load-path)
    ;; include packages in load path

    (dolist (row package-list)
      (let* ((file (nth 0 row))
             (hash (nth 1 row))
             (url  (nth 2 row))
             (dest-path (expand-file-name (join-path install-path (concat file ".el"))))
             download-args exit-code)
        (unless (or (string-equal "" file)
                    (string-equal "" url))
          (unless (file-exists-p dest-path) ;; only download when doesn't already exist
            (unless (and (zerop (external-packages/download-external-package url dest-path))
                         (external-packages/validate-package-hash file dest-path hash))
              (push file failed-installs))))))

    (if (endp failed-installs)
        (let ((buffer (get-buffer "*external-packages*")))
          (and buffer
               (kill-buffer buffer))) ;; kill process buffer when nothing failed
      ;; (error "external-package : failed to download packages: %s" failed-installs)
      ))
#+end_src
*** Global Key Bindings
#+begin_src emacs-lisp
  (general-define-key
    ;; ("ESC"   . nil) ;; WARN never do this... it broke everything
    "C-M-|"           'shell-command-on-buffer
    "C-/"             'toggle-comment-at-point
    "C-M-h"           'left-word
    "C-M-l"           'right-word
    "M-j"             'custom-insert-line-below
    "M-k"             'custom-insert-line-above
    "M-r"             'revert-buffer
    "C-k"             'nil
    "C-q"             'quit-window
    "C-j"             'newline-and-indent
    "C-<tab>"         'next-buffer
    "C-S-<tab>"       'previous-buffer
    "C-<iso-lefttab>" 'previous-buffer
    "RET"             'newline-and-indent
    "<C-M-return>"      'comment-indent-new-line)

  (setq mohkale-window-map (make-sparse-keymap))

  (general-define-key "C-w" '(:prefix-command mohkale-window-map :which-key "windows"))

  (define-key mohkale-window-map "m" 'window-zen)
#+end_src
** leader
replicate some +basically all+ the built in spacemacs leader features & keys... cause why fix whats not broken.

#+begin_src emacs-lisp :shebang ";; -*- lexical-binding: t -*-"
  ;; this script is largely just copied from spacemacs/core/core-keybindings.el
  ;; it's not my intention to steal or claim credit for it, simply to replicate
  ;; the logic found in spacemacs on my config. To that end, I've renamed most
  ;; spacemacs variables as my own variables, simply because spacemacs isn't
  ;; defined in my config. My complete respect goes to the developers of spacemacs
  ;; who created a binding system so ergonomic and responsive that I have to have it.
  ;; :)

  ;; NOTE the methods in here aren't as long as the ones in spacemacs because I don't
  ;;      use different leader keys for `emacs' config and spacemacs config.

  (require 'general)
  (require 'bind-map)
  (require 'which-key)

  ;; use nicer indentation with general
  (put 'general-define-key 'lisp-indent-function 'defun)
  (put 'general-create-definer 'lisp-indent-function 'defun)

  ;;                  _       _     _
  ;; __   ____ _ _ __(_) __ _| |__ | | ___  ___
  ;; \ \ / / _` | '__| |/ _` | '_ \| |/ _ \/ __|
  ;;  \ V / (_| | |  | | (_| | |_) | |  __/\__ \
  ;;   \_/ \__,_|_|  |_|\__,_|_.__/|_|\___||___/
  ;;

  (defvar mohkale-leader-map (make-sparse-keymap)
    "core map for leader key bindings.")

  (defvar mohkale-leader-key "SPC"
    "key from which you can access all leader bindings.")

  (defvar mohkale-nnorm-leader-key "C-SPC"
    "key from which you can access all leader bindings in non-normal mode.")

  ;; (setq mohkale-leader-map (make-sparse-keymap)) ;; FIXME delete this

  (defvar mohkale-major-mode-leader-prefix "m"
    "prefix key in leader map for the active modes map.")

  (defvar mohkale-major-mode-leader-key ","
    "key shortcut equivalent to leader-key then major-mode-leader-prefix")

  (defvar mohkale-evil-states '(insert emacs normal visual motion operator outer inner replace iedit iedit-insert)
    "all the known emacs evil states")

  (defvar mohkale-nnorm-states general-non-normal-states
    "all the known evil states which aren't inherited from normal mode")

  (defvar mohkale-norm-states (seq-filter (lambda (x) (not (member x mohkale-nnorm-states))) mohkale-evil-states)
    "all the known evil states which do inherit from normal mode")

  (defvar mohkale-major-mode-leader-key-states '(normal visual)
    (format "evil states under which %s can be used to jump to the major modes leader map."
            mohkale-major-mode-leader-key))

  (defmacro mohkale//iterate-evil-state-leader-key-tuples (&rest body)
    "iterates over a list of evil state symbols and their corresponding leader keys.
  the body of the invoking function will have access to these values under variables of the
  name steates and leader.

  I know, I know, don't even get me started on how it's a terrible design choice to make
  a macro which changes the local states of its body. This is a mess. Once I come up with
  a nice optimsed way to do what this does... FIXME I will change it."
    (let* (;; Tuples mapping states to leader keys in all modes
           (state-based-tuples `((,mohkale-norm-states  . ,mohkale-leader-key)
                                 (,mohkale-nnorm-states . ,mohkale-nnorm-leader-key))))
      `(dolist (tuple (quote ,state-based-tuples))
         (let ((states (car tuple))
               (leader (cdr tuple)))
           ,@body))))
  (put 'mohkale//iterate-evil-state-leader-key-tuples 'lisp-indent-function 'defun)

  (mohkale//iterate-evil-state-leader-key-tuples ;; (leader states)
    ;; create bindings to leader map in every mode
    (general-define-key
      :states states
      leader '(:keymap mohkale-leader-map :which-key "emacs root")))

  (let ((major-leader-sequence (concat mohkale-leader-key
                                       " "
                                       mohkale-major-mode-leader-prefix)))
    (general-define-key
      ;; WARN hardcoded leader sequence... general-simulate-key can't handle variables yet
      :states mohkale-major-mode-leader-key-states
      mohkale-major-mode-leader-key (general-simulate-key "SPC m")))

  ;;                  __ _
  ;;  _ __  _ __ ___ / _(_)_  _____  ___
  ;; | '_ \| '__/ _ \ |_| \ \/ / _ \/ __|
  ;; | |_) | | |  __/  _| |>  <  __/\__ \
  ;; | .__/|_|  \___|_| |_/_/\_\___||___/
  ;; |_|
  ;;

  ;; TODO macro this up, there's too much repetition for my liking.

  (defun mohkale/declare-prefix (prefix name &optional long-name)
    "Declare a leader key prefix `prefix'.
  `prefix' a string describing a key sequence. `long-name' is
  shown in the message buffer when the prefix is expanded.

  WARN prefixes are only shown by which key if there's at least one
       binding accessible through that prefix. kind of obvious in
       retrospect I guess."
    (dolist (leader (list mohkale-leader-key
                          mohkale-nnorm-leader-key))
      (let ((full-prefix (concat leader " " prefix)))
          (which-key-add-key-based-replacements full-prefix (cons name (or long-name name))))))
  (put 'mohkale/declare-prefix 'lisp-indent-function 'defun)

  (defun mohkale/declare-prefix* (prefix name &rest remaining)
    "declares a leader key prefix `prefix'.
  `prefix' must be a keybinding which can be evaluated by `kbd'.
  `name' can be either a single string or an alist for (short . long) names.

  you can pass as many prefix name pairs as you wish to using this variant."
    (while prefix
      (dolist (leader (list mohkale-leader-key
                            mohkale-nnorm-leader-key))
        (let ((full-prefix (concat leader " " prefix)))
          (which-key-add-key-based-replacements full-prefix name)))
      (setq prefix (pop remaining) name (pop remaining))))
  (put 'mohkale/declare-prefix* 'lisp-indent-function 'defun)

  (defun mohkale/declare-prefix-for-mode (mode prefix name &optional long-name major)
    "declare a leader key prefix which is only active in the given mode
  this function accepts the same arguments as `mohkale/declare-prefix'
  alongside an addition symbol argument `mode' for which mode to work in.

  this function doesn't distinguish between major and minor modes."
    (unless (consp name)
      (if long-name
          (setq name (cons name long-name))
        (setq name (cons name name))))

    (dolist (leader (list mohkale-leader-key
                          mohkale-nnorm-leader-key))
      (let ((full-prefix (concat leader
                                 " "
                                 (if major mohkale-major-mode-leader-prefix)
                                 " "
                                 prefix)))
        (which-key-declare-prefixes-for-mode mode full-prefix name)))

    (when major
      (let ((major-mode-leader-prefix (concat mohkale-major-mode-leader-key " " prefix)))
        (which-key-declare-prefixes-for-mode mode major-mode-leader-prefix name))))
  (put 'mohkale/declare-prefix-for-mode 'lisp-indent-function 'defun)

  (defun mohkale/declare-prefix-for-mode* (mode prefix name &rest remaining)
    "declare multiple prefixes that're only active in the given mode.
  this function is a variant of `mohkale/declare-prefix*' where the prefix
  is declared using `mohkale/declare-prefix-for-mode'."
    (while prefix
      (mohkale/declare-prefix-for-mode mode prefix name)
      (setq prefix (pop remaining) name (pop remaining))))
  (put 'mohkale/declare-prefix-for-mode* 'lisp-indent-function 'defun)

  (defun mohkale/declare-prefix-for-major-mode (mode prefix name &optional long-name)
    "declare a prefix under the major-mode-leader-prefix in the leader map.
  this is simply a shortcut function for `mohkale/declare-prefix-for-mode' where every
  prefix is also prefixed with `mohkale-major-mode-leader-prefix'."
    (mohkale/declare-prefix-for-mode mode prefix name long-name t))
  (put 'mohkale/declare-prefix-for-major-mode 'lisp-indent-function 'defun)

  (defun mohkale/declare-prefix-for-major-mode* (mode prefix name &rest remaining)
    "declare multiple prefixes which're only active in the given major mode.
  this function is a variant of `mohkale/declare-prefix*' where the prefix
  is declared using `mohkale/declare-prefix-for-major-mode'"
    (while prefix
      (mohkale/declare-prefix-for-mode mode prefix name nil t)
      (setq prefix (pop remaining) name (pop remaining))))
  (put 'mohkale/declare-prefix-for-major-mode* 'lisp-indent-function 'defun)

  ;;  _                _                _     _           _ _
  ;; | | ___  __ _  __| | ___ _ __     | |__ (_)_ __   __| (_)_ __   __ _ ___
  ;; | |/ _ \/ _` |/ _` |/ _ \ '__|____| '_ \| | '_ \ / _` | | '_ \ / _` / __|
  ;; | |  __/ (_| | (_| |  __/ | |_____| |_) | | | | | (_| | | | | | (_| \__ \
  ;; |_|\___|\__,_|\__,_|\___|_|       |_.__/|_|_| |_|\__,_|_|_| |_|\__, |___/
  ;;                                                                |___/

  (defmacro mohkale//set-leader-bindings-iterator (map key def bindings)
    "iterate for all the bindings in `bindings' and set them in the `map'
  initial bindings are specified by `key' and `map'."
    ;; FIXME apply doesn't seem to work with unflattened remaining args
    ;; `(apply 'general-define-key :keymaps ,map ,key ,def ,bindings)
    `(while ,key
       ;; (define-key ,map (kbd ,key) ,def)
       (bind-key ,key ,def (symbol-value ,map))
       ;; TODO fix general implementation with which-key
       ;; (general-define-key :keymaps ,map ,key ,def)
       (setq ,key (pop ,bindings) ,def (pop ,bindings))))
  (put 'mohkale//set-leader-bindings-iterator 'lisp-indent-function 'defun)

  (defun mohkale/set-leader-keys (key def &rest bindings)
    "set bindings in the leader key map for all modes.
  supply as many key binding pairs as you wish to define."
    (mohkale//set-leader-bindings-iterator 'mohkale-leader-map key def bindings))
  (put 'mohkale/set-leader-keys 'lisp-indent-function 'defun)

  (defun mohkale//init-leader-mode-prefix-map (mode map &optional minor)
    "create a prefix map for a leader key prefix that's mode dependent.
  this function returns whether the desired map exists... it should always
  return true."
    (let ((prefix-map (intern (format "%s-prefix" map))))
      ;; needed to ensure key lookups work
      (unless (boundp mode)
        (set mode nil))

      (if (boundp prefix-map) t
        (mohkale//iterate-evil-state-leader-key-tuples ;; (states leader)
          (let ((leader (list (if minor
                                  leader
                                (concat leader " " mohkale-major-mode-leader-prefix)))))
            ;; WARN why this needs to be in an eval block... I have no idea
            ;;      I've tried to move it out and I always encounter one error
            ;;      or another. Just leave it in for now.
            (eval
             `(bind-map ,map
                :prefix-cmd ,prefix-map
                ,(if minor :minor-modes :major-modes) (,mode)
                :evil-keys ,leader
                :evil-states ,states))))
        (boundp prefix-map))))

  (defun mohkale/set-leader-keys-for-minor-mode (mode key def &rest bindings)
    "set bindings in the leader key map for only the given minor mode.
  this function has the same body as mohkale/set-leader-keys but also accepts
  a symbol as an initial argument specifying the mode in question."
    (let* ((map (intern (format "mohkale-leader-%s-map" mode))))
      (when (mohkale//init-leader-mode-prefix-map mode map t)
        (mohkale//set-leader-bindings-iterator map key def bindings))))
  (put 'mohkale/set-leader-keys-for-minor-mode 'lisp-indent-function 'defun)

  (defun mohkale/set-leader-keys-for-major-mode (mode key def &rest bindings)
    "set bindings in the leader key map for only the given major mode.
  this function has the same body as mohkale/set-leader-keys but also accepts
  a symbol as an initial argument specifying the mode in question."
    (let* ((map (intern (format "mohkale-leader-%s-map" mode))))
      (when (mohkale//init-leader-mode-prefix-map mode map)
        (mohkale//set-leader-bindings-iterator map key def bindings))))
  (put 'mohkale/set-leader-keys-for-major-mode 'lisp-indent-function 'defun)

  (mohkale/declare-prefix mohkale-major-mode-leader-prefix "major-mode" "major mode commands")
#+end_src
*** emacs-root
#+begin_src emacs-lisp
  (mohkale/declare-prefix*
    "SPC" "M-x"
    "TAB" "last-buffer")

  (mohkale/set-leader-keys
    "SPC" 'execute-extended-command
    "TAB" 'switch-to-last-buffer
    "!" 'shell-command
    "&" 'async-shell-command
    "-" 'line-width
    "." 'repeat
    "1" 'winum-select-window-1
    "2" 'winum-select-window-2
    "3" 'winum-select-window-3
    "4" 'winum-select-window-4
    "5" 'winum-select-window-5
    "6" 'winum-select-window-6
    "7" 'winum-select-window-7
    "8" 'winum-select-window-8
    "9" 'winum-select-window-9
    "0" 'winum-select-window-by-number
    "u" 'universal-argument)
#+end_src

*** applications
#+begin_src emacs-lisp
  (mohkale/declare-prefix*
    "a" "applications"
    "au" "undo tree")

  (mohkale/set-leader-keys
    "aC" 'calc-dispatch
    "ac" 'calendar
    "ad" 'ido-dired
    "ae" 'package-list-packages
    "af" 'list-faces-display
    "am" 'man
    "a:" 'proced
    "ap" 'list-processes
    "au" 'undo-tree-visualize
    "aX" 'customize)
#+end_src

*** buffers
#+begin_src emacs-lisp
  (mohkale/declare-prefix*
    "b" "buffers"
    "bt" "buffer-read-only-mode")

  (mohkale/set-leader-keys
    "bB" 'create-new-empty-buffer
    "bb" 'switch-to-buffer
    "bd" 'kill-this-buffer
    "be" 'safe-erase-buffer
    "bE" 'erase-buffer
    "bK" 'kill-this-buffer
    "bk" 'kill-this-buffer-and-window-maybe
    "bM" 'goto-messages-buffer
    "bm" 'buffer-menu
    "bn" 'next-buffer
    "bN" 'previous-buffer
    "bc" 'rename-buffer
    "bC" 'rename-uniquely
    "bo" 'occur
    "bs" 'switch-to-scratch-buffer
    "bt" 'read-only-mode
    "by" 'copy-whole-buffer-to-clipboard)
#+end_src

*** compile/comments
#+begin_src emacs-lisp
  (mohkale/declare-prefix "c" "compile/comments")

  (mohkale/set-leader-keys
    ;; compile
    "cC" 'compile
    "cd" 'close-compilation-window ;; WARN not yet implemented
    "cs" 'kill-compilation
    "cr" 'recompile

    ;; comment
    "cy" 'yank-and-comment
    "ck" 'comment-kill
    "cb" 'comment-box
    "ci" 'comment-indent)
#+end_src

*** error
#+begin_src emacs-lisp
  (mohkale/declare-prefix "e" "errors")

  (mohkale/set-leader-keys
    ;; TODO make flycheck aliases
    "en" 'next-error
    "eN" 'previous-error)
#+end_src

*** files
#+begin_src emacs-lisp
  (mohkale/declare-prefix*
    "f"  "files"
    "fC" "files/convert"
    "fe" '("emacs" . "emacs files")
    "fo" "open-externally"

    "fv" "variables")

  (mohkale/set-leader-keys
    "fc" 'copy-file
    "fD" 'delete-buffer-file
    "fF" 'find-file-at-point
    "ff" 'find-file
    "fl" 'find-file-literally
    ;; "fo" 'open-file-or-directory-in-external-app ;; TODO implement
    "fR" 'rename-buffer-file
    "fy" 'show-and-copy-buffer-file-name
    "f M-r" 'revert-buffer
    "f M-f" 'find-dired

    "fCd" 'unix2dos
    "fCu" 'dos2unix

    "fev" 'emacs-version

    "fvd" 'add-dir-local-variable
    "fvf" 'add-file-local-variable
    "fvp" 'add-file-local-variable-prop-line)
#+end_src

*** help
#+begin_src emacs-lisp
  (mohkale/declare-prefix*
    "h"  "help"
    "hd" "help-describe")

  (mohkale/set-leader-keys
    "hn" 'view-emacs-news

    "hdb" 'describe-bindings
    "hdc" 'describe-char
    "hdF" 'describe-face
    "hdk" 'describe-key
    "hdl" 'describe-last-keys ;; WARN not yet implemented
    "hdp" 'describe-package
    "hds" 'describe-system-info
    "hdt" 'describe-theme
    "hdv" 'describe-variable)
#+end_src

*** insert
#+begin_src emacs-lisp
  (mohkale/declare-prefix "i" "insert")

  (mohkale/set-leader-keys
    "ij" 'custom-insert-line-below
    "ik" 'custom-insert-line-above)
#+end_src

*** jump
#+begin_src emacs-lisp
  (mohkale/declare-prefix "j" "jump")
#+end_src

*** modes
#+begin_src emacs-lisp
  (mohkale/declare-prefix*
    "M" "modes"
    "Md" "dired")

  (mohkale/set-leader-keys
    "Mz" 'zone
    "Ml" 'emacs-lisp-mode
    "ML" 'lisp-interaction-mode
    "Mc" 'c++-mode
    "MC" 'c-mode
    "Mf" 'fundamental-mode
    "Mp" 'python-mode
    "Mr" 'enh-ruby-mode
    "Ms" 'shell-script-mode
    "Mw" 'whitespace-mode
    "Mo" 'org-mode
    "Mh" 'hexl-mode
    "M M-d" 'decipher
    "M M-r" 'toggle-rot13-mode

    "Mdd" 'toggle-editable-dired
    "Mde" 'invoke-editable-dired
    "Md <escape>" 'wdired-abort-changes
    "Mdq" 'wdired-abort-changes)
#+end_src

*** narrowing & numbers
#+begin_src emacs-lisp
  (mohkale/declare-prefix "n" "narrrow/numbers")

  (mohkale/set-leader-keys
    "nr" 'narrow-to-region
    "np" 'narrow-to-page
    "nw" 'widen)
#+end_src

*** custom
#+begin_src emacs-lisp
  (mohkale/declare-prefix*
    "o"  "custom"
    "of" "format"
    "od" "diff"
    "oe" "emacs"
    "ot" "text"

    "o C-M-k" "hcf")

  (mohkale/set-leader-keys
    "o C-M-k" 'kill-all-windows-and-return-to-home

    "oft" 'remove-all-trailing-whitespace
    "ofC" 'capitalize-region
    "ofu" 'upcase-region
    "ofd" 'downcase-region
    "ofc" 'toggle-comment-at-point
    "ofp" 'pad-line-with-space-to-length
    "ofP" 'pad-line-with-char-to-length

    "odf" 'ediff-current-file
    "odF" 'diff-buffer-with-file
    "odb" 'ediff-buffers
    "odw" 'ediff-windows
    "odv" 'vc-ediff
    "odV" 'vc-diff

    "oef" 'make-frame
    "oeF" 'delete-frame

    "otp" 'describe-text-properties
    "otf" 'list-faces)
#+end_src

*** toggles
#+begin_src emacs-lisp
  (mohkale/declare-prefix*
    "t" "toggles"
    "tn" "toggle-line-numbers")

  (mohkale/set-leader-keys
    "tl" 'toggle-truncate-lines
    "tw" 'toggle-word-wrap
    "t|" 'toggle-scroll-bar
    "t-" 'toggle-horizontal-scroll-bar
    "td" 'toggle-debug-on-error
    "tq" 'toggle-debug-on-quit
    "tm" 'toggle-frame-maximized
    "tn" 'mohkale//enable-line-numbers-handler
    "tf" 'toggle-frame-fullscreen
    "tg" 'toggle-tool-bar-mode-from-frame
    "tG" 'toggle-menu-bar-mode-from-frame
    "tu" 'toggle-uniquify-buffer-names
    "te" 'toggle-indicate-empty-lines
    "ta" 'toggle-text-mode-auto-fille
    "tR" 'read-only-mode
    "tc" 'toggle-case-fold-search
    "ti" 'toggle-input-method
    "ts" 'toggle-save-place-globally)
#+end_src

*** search
#+begin_src emacs-lisp
  (mohkale/declare-prefix*
    "s" "search/symbol")

  (mohkale/set-leader-keys
    "sg" 'rgrep)
#+end_src

*** window
#+begin_src emacs-lisp
(mohkale/declare-prefix "w" "windows")

(mohkale/set-leader-keys
  "w" mohkale-window-map)
#+end_src
** Mohkale
#+begin_src emacs-lisp
  (use-package mohkale
    :defer t
    :commands (mohkale/eval-configuration-file
               mohkale/build-configuration-file
               mohkale/find-configuration-file
               mohkale/find-tangled-config-file
               mohkale/eval-configuration-file
               mohkale/build-configuration-file
               mohkale/find-dotfile-file
               mohkale/find-capture-notes-file
               mohkale/find-org-university-file)
    :init
    (mohkale/declare-prefix*
      "oon" "find-notes-file"
      "oou" "find-uni-file"
      "feb" "build-config"
      "fec" "find-config"
      "fer" "eval-config"
      "fet" "find-tangled-config"
      "fed" "find-dotfile")

    (mohkale/set-leader-keys
      "oon" 'mohkale/find-capture-notes-file
      "oou" 'mohkale/find-org-university-file
      "feb" 'mohkale/build-configuration-file
      "fec" 'mohkale/find-configuration-file
      "fer" 'mohkale/eval-configuration-file
      "fed" 'mohkale/find-dotfile-file
      "fet" 'mohkale/find-tangled-config-file))
#+end_src

#+HEADER: :shebang ";; -*- lexical-binding: t -*-"
#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale.el"
  (defmacro mohkale/defun-mohkale-find-package-file (file-type file-path &optional root)
    "creates a function to visit a file, ideally under the mohkale directory
  file-type is a symbol, which is substituted into the string `\"mohkale/find-%s-file\"'
  and then set as the name of this function. file-path is the path of the file the function
  will open. root is the base directory from which file path can be found. If nil, it defaults
  to `mohkale-root'. Pass a non string truthy value if `file-path' is an absolute path."
    (unless (stringp root)
      (if root
          (setq root (file-name-directory (eval file-path)))
        (setq root mohkale-config-root)))

    (unless (file-name-absolute-p (eval file-path))
      (setq file-path (concat root "/" (eval file-path))))

    `(defun ,(intern (concat "mohkale/find-" (symbol-name file-type) "-file")) ()
      (interactive)
      (if (not (file-directory-p ,root))
          (error (format "mohkale::error() : mohkale find file > directory not found: %s" ,root))
        (find-file ,file-path))))

  (mohkale/defun-mohkale-find-package-file capture-notes "org/notes.org")
  (mohkale/defun-mohkale-find-package-file org-university "org/university.org")
  ;; TODO refactor this needless repeated work
  (mohkale/defun-mohkale-find-package-file dotfile "init.el" user-emacs-directory)
  (mohkale/defun-mohkale-find-package-file configuration mohkale-mohkale-config-file t)
  (mohkale/defun-mohkale-find-package-file tangled-config mohkale-mohkale-el-config-file t)

  (defun mohkale/eval-configuration-file ()
    (interactive)
    (org-babel-load-file mohkale-mohkale-config-file))

  (defun mohkale/build-configuration-file ()
    (interactive)
    (require 'org)
    (org-babel-tangle-file mohkale-mohkale-config-file
                           mohkale-mohkale-el-config-file)
    (when mohkale-should-compile-config
      (require 'bytecomp)
      (byte-compile-file mohkale-mohkale-el-config-file)

      (let ((tangled-files (directory-files-recursively mohkale-config-root
                                                        ".*\\.el$")))
        (dolist (file tangled-files)
          (byte-compile-file file)))))
#+end_src
** Methods
*** File
#+begin_src emacs-lisp
  (use-package mohkale-file
    :defer t
    :commands (rename-buffer-file
               delete-buffer-file
               show-and-copy-buffer-file-name
               jump-to-directory)
    :init
    (mohkale/set-leader-keys
      "fj" 'jump-to-directory
      "jd" 'jump-to-directory
      "jD" 'jump-to-directory-other-window))
#+end_src

#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-file.el"
  (defun rename-buffer-file (buffer &optional new-name)
    "renames the file associated with the buffer `buffer'
  if the buffer isn't visiting a file, this function is
  equivalent to `rename-buffer' followed by setting the
  file visited by the buffer."
    (interactive (list (current-buffer)))

    (with-current-buffer buffer
      (or new-name (setq new-name (read-file-name "new-name: ")))
      (let ((buffer-file (buffer-file-name buffer)))
        (if (get-buffer new-name)
            (message "a buffer with that name already exists: %s" new-name)
          (when (or (not (file-exists-p new-name))
                    (yes-or-no-p "file already exists, overwrite it:"))
            ;; destination doesn't exist, so can write
            ;; or
            ;; user agrees to overwrite, so can write
            (when (and buffer-file
                       (file-exists-p buffer-file))
              ;; only rename buffer file if it exists
              (rename-file buffer-file new-name t)
              (message "moved file '%s' to '%s'" buffer-file new-name))
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil))))))

  (defun delete-buffer-file ()
    (interactive)
    (let ((buffer (current-buffer))
          (filename (buffer-file-name))
          (name (buffer-name)))
      (if (not filename)
          (message "buffer %s is not visiting a file" name)
        (when (yes-or-no-p "Are you sure you want to delete this file? ")
          (when (file-exists-p filename)
            (delete-file filename t))

          (kill-buffer buffer)))))

  (defun show-and-copy-buffer-file-name (&optional prefix)
    "displays the current buffers name in the echo area & yank it
  when a prefix arg is given, the buffer name is also inserted into
  the buffer."
    (interactive "P")
    (let ((bufname (or (buffer-file-name) "")))
      (message bufname)
      (kill-new bufname)

      (when prefix
        (insert bufname))))

  ;; (defun jump-to-directory (&optional buffer other-window-p)
  ;;   (interactive `(,(current-buffer)))
  ;;   (let ((filename (buffer-file-name buffer)))
  ;;     (if (not filename)
  ;;         (message "no filename is associated with the buffer: %s" buffer)
  ;;       (message "%s" (f-dirname filename))

  ;;       (funcall (if other-window-p
  ;;                    'find-file-other-window
  ;;                  'find-file)
  ;;                (f-dirname filename)))))

  ;; (defun jump-to-directory-other-window (&optional buffer)
  ;;   (interactive `(,(current-buffer)))
  ;;   (jump-to-directory buffer t))

  (defalias 'jump-to-directory 'dired-jump)
  (defalias 'jump-to-directory-other-window 'dired-jump-other-window)
#+end_src
*** Hooks/Handlers
#+begin_src emacs-lisp
  (defun no-junk-please-were-unixish ()
    "auto convert found files to use unix EOL formats"
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
        (set-buffer-file-coding-system 'unix))))

  (add-hook 'find-file-hook 'no-junk-please-were-unixish)

  (defun mohkale//enable-line-numbers-handler ()
    "forces the display of line numbers in the current buffer"
    (interactive)
    (display-line-numbers-mode 1)
    (setq display-line-numbers 'relative))

  (setq command-error-function
        (defun mohkale/command-error-function (data context caller)
          "hide some error message"
          (when (not (memq (car data) '(;; buffer-read-only
                                        beginning-of-buffer
                                        end-of-buffer)))
            (command-error-default-function data context caller))))

  (defun mohkale//hide-trailing-whitespace ()
    (when (derived-mode-p 'inf-ruby-mode
                          'messages-buffer-mode
                          'image-dired-thumbnail-mode
                          'help-mode
                          'diff-mode
                          'dashboard-mode
                          'sql-interactive-mode
                          'eshell-mode
                          'comint-mode
                          'Buffer-menu-mode)
      (setq show-trailing-whitespace nil)))

  (add-hook 'after-change-major-mode-hook 'mohkale//hide-trailing-whitespace)
  (add-hook 'prog-mode-hook #'mohkale//enable-line-numbers-handler)
  (add-hook 'fundamental-mode-hook #'mohkale//enable-line-numbers-handler)
#+end_src
*** Windows
#+begin_src emacs-lisp
  (defun force-set-all-visible-windows-dedication (&optional dedicate)
    "allows you to set the dedication of all visible windows
  dedicate if truthy, will result in all windows recieving a dedication.
  if falsy, all windows will have their dedication removed"
    (interactive "P")
    ;; TODO require persp-mode here
    (and dedicate (setq dedicate t))   ; rationalise value as bool
    (or  dedicate (setq dedicate nil)) ; rationalise value as nil

    (dolist (window (window-list))
      (if (not (eq dedicate (window-dedicated-p window)))
          (with-selected-window window
            (set-window-dedicated-p window dedicate)))))

  (defun window-zen ()
    "Maximize buffer"
    ;; from https://gist.github.com/3402786
    (interactive)
    (if (and (= 1 (length (window-list)))
             (assoc ?_ register-alist))
        (jump-to-register ?_)
      (progn
        (window-configuration-to-register ?_)
        (delete-other-windows))))
#+end_src
*** Text
**** Querying
 functions for querying information about the text at point or retrieve other relevent information.

#+begin_src emacs-lisp
(defun line-width (char-pos)
  "returns the number of columns on the line at char-pos"
  (interactive (if current-prefix-arg
                   (list current-prefix-arg)
                 (list (point))))
  (save-excursion
    (if (not (eql char-pos (point)))
      (goto-char char-pos))
    (let ((line-width (max (- (line-end-position) (line-beginning-position) 1) 0)))
      (if (called-interactively-p 'any)
          (message (format "Line Width: %03d" line-width)))

      line-width)))

(defun column-number (point)
  "returns the column number at point"
  (interactive "")
  (save-excursion
    (goto-char point)
    (current-column)))

(defun point-to-coordinates (&optional point)
  "convert a point to an XY coordinate alist"
  (or point (setq point (point)))
  `(,(line-number-at-pos point) . ,(column-number point)))

(defun line-empty-p (&optional point)
  (save-excursion
    (and point (goto-char point))
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))

(defun list-faces (&optional point)
  (interactive "d")
  (or point (setq point (point)))
  (let ((faces (remq nil
                     `(,(get-char-property point 'read-face-name)
                       ,(get-char-property point 'face)
                       ,(plist-get (text-properties-at point) 'face)))))
    (and (called-interactively-p 'any) (message (format "%s" faces)))
    faces))
#+end_src
**** Formatting
#+begin_src emacs-lisp
  (use-package mohkale-text
    :defer t
    :commands (dos2unix
               unix2dos
               pad-line-with-char-to-length
               pad-line-with-space-to-length
               remove-all-trailing-whitespace
               toggle-comment-at-point
               custom-insert-line
               custom-insert-line-below
               custom-insert-line-above
               evil-join-backwards))
#+end_src

***** Chunks
 manipulate chunks of text, such as leading indentation or sequential padding.
#+HEADER: :shebang ";; -*- lexical-binding: t -*-"
#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-text.el"
  (defun dos2unix ()
    "Not exactly but it's easier to remember"
    (interactive)
    (set-buffer-file-coding-system 'unix 't))

  (defun unix2dos ()
    (interactive)
    (set-buffer-file-coding-system 'dos 't))

  (defun pad-line-with-char-to-length (desired-length char)
    "appends char as many times as required from cursor position"
    (interactive "Nline length: \nccharacter: \nd")
    (barf-if-buffer-read-only) ; can't pad read only buffer

    (save-excursion
      (let* ((line-char-count (line-width (point))))
        (if (>= line-char-count desired-length)
            (error (format "line of length %03d is already larger than desired: %03d" line-char-count desired-length))
          (insert (make-string (- desired-length line-char-count) char))))))

  (defun pad-line-with-space-to-length (desired-length)
    "invokes pad-line-with-char-to-length with char as space"
    (interactive "Nline length: \n")
    (pad-line-with-char-to-length desired-length ?\s))

  ;; (defun remove-indentation-spaces ()
  ;;   "remove TAB-WIDTH spaces from the beginning of this line"
  ;;   (interactive)
  ;;   (if (save-excursion (re-search-backward "[^ \t]" (line-beginning-position) t))
  ;;       (delete-backward-char 1)
  ;;     (indent-rigidly (line-beginning-position) (line-end-position) (- tab-width))))

  (defun remove-all-trailing-whitespace (start end)
    "removes all trailing whitespace from every line in buffer"
    (interactive (if (region-active-p)
                     (list (region-beginning) (region-end))
                   (list (point-min) (point-max))))

    (barf-if-buffer-read-only) ; can't remove from current buffer

    (save-excursion
      (goto-char end) ; start from end so delete can work forward

      (while (and (> (point) start)
                  (re-search-backward " +$" nil t))
        (delete-region (point) (line-end-position)))))
#+end_src
***** Commenting
 comment regions of text or by default, the current line.

#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-text.el"
  (defun toggle-comment-at-point (start end)
    "toggle comment on line or region
  pass a prefix argument to bulk toggle across multiple lines.
  This function will always comment the line your point is on,

  Prefix Behaviour:
  | Prefix Range | Behaviour                                        |
  |--------------+--------------------------------------------------|
  | 0            | current line only                                |
  | >1           | current line and upto PREFIX-1 lines after point |
  | <1           | current line and upto PREFIX lines before point  |

  the behaviour is mapped to exactly replicate the vim dd command."
    (interactive (let ((prefix current-prefix-arg))
                   (if (region-active-p)
                       ;; always use region when region available
                       (list (region-beginning) (region-end))
                     (if (or (not prefix)
                             (listp prefix) ;; regular prefix
                             (zerop prefix))
                         ;; no prefix, comment current line only
                         (list (line-beginning-position) (line-end-position))
                       ;; prefix given, use it to determine comment region
                       (let* ((prefix-positive (> prefix 0))
                              (current-pos (if prefix-positive
                                               (line-beginning-position)
                                             (line-end-position))))
                         (save-excursion
                           (if prefix-positive
                               (progn
                                 (evil-next-line (- prefix 1))
                                 (list current-pos (line-end-position)))
                             (evil-next-line prefix)
                             (list (line-beginning-position) current-pos))))))))
    (comment-or-uncomment-region start end))

  (defun yank-and-comment (&optional prefix)
    (interactive "P")
    (when (> (length kill-ring)
             0)
      (save-excursion
        (let ((beginning (point)))
          (call-interactively 'yank)
          (comment-region beginning (point))))
      (evil-forward-word))) ;; move to beginning of comment
#+end_src

***** Line Insertion
 line insertion and joining functions.

#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-text.el"
(defun custom-insert-line (&optional prefix)
  "inserts a line above or below point

if a prefix argument of 0 or more (or none) is given, the
line is inserted below the point. Otherwise its inserted
above the point.

The absolute value of the prefix determines how many lines
are inserted.

Eg: A prefix of:
  * nil - inserts a single line below the cursor
  * -1  - inserts a single line above the cursor
  * 0   - inserts a single line below the cursor
  * 1   - inserts a single line below the cursor
  * -10 - inserts 10 lines above the cursor
  * 10  - inserts 10 lines below the cursor"
  (interactive "P")

  (save-excursion
    (let ((move-arg (if (or (not prefix)
                            (>= prefix 0))
                        nil ; if prefix xor prefix >= 0
                      0)))
      (move-end-of-line move-arg)
      (open-line (max 1 (abs prefix))))))

(defun custom-insert-line-below (&optional prefix)
  (interactive "P")
  (custom-insert-line (abs (or prefix 1))))

(defun custom-insert-line-above (&optional prefix)
  (interactive "P")
  (custom-insert-line (- (abs (or prefix 1)))))

(defun evil-join-backwards (&optional prefix)
  "same as join line, except joins line immeadiately before point"
  (interactive "p")
  (let ((start nil)
        (end   nil))
    (if (evil-visual-state-p)
        (let ((range (evil-visual-range)))
          (setq start (nth 0 range))
          (setq end   (nth 1 range)))
      ;; not visual, calculate ranges
      (setq end (point))
        (save-excursion
          (forward-line (- (abs prefix)))
          (setq start (point))))
    ;; remove excursion block if you wan't to
    ;; reallign point to start of line on join
    (save-excursion
      (if (line-empty-p start)
          ;; when joining onto an empty line
          ;; maintain leading whitespace
          (evil-join-whitespace start end)
        ;; otherwise trim to single space
        (evil-join start end)))))
#+end_src
*** Buffers, Windows & Frames
#+begin_src emacs-lisp
  (use-package mohkale-bufwin
    :defer t
    :commands (switch-to-scratch-buffer
               kill-this-buffer-and-window-maybe
               switch-to-last-buffer
               kill-all-windows-and-return-to-home
               goto-messages-buffer
               shell-command-on-buffer
               safe-erase-buffer
               copy-whole-buffer-to-clipboard
               split-window-right-and-focus
               split-window-below-and-focus))
#+end_src

#+HEADER: :shebang ";; -*- lexical-binding: t -*-"
#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/mohkale-bufwin.el"
  (defun switch-to-scratch-buffer ()
    (interactive)
    ;; TODO interactive makes new scratch buffers
    (switch-to-buffer (get-buffer-create "*scratch*")))

  (defun goto-messages-buffer ()
    "switches to messages buffer"
    (interactive)
    (switch-to-buffer (messages-buffer)))

  (defun kill-this-buffer-and-window-maybe ()
    "kills the currently open buffer and the window if another is open"
    (interactive)
    (let ((window-count (length (window-list))))
      (if (> window-count 1)
          (kill-buffer-and-window)
        (kill-this-buffer))))

  (defun switch-to-last-buffer ()
    (interactive)
    (switch-to-buffer nil))

  (defun kill-all-windows-and-return-to-home ()
    "kills every other window and returns to spacemacs home"
    (interactive)
    (dolist (window (cdr (window-list)))
      ;; window-list starts with current window
      (delete-window window))
    (goto-home-buffer))

  (defun shell-command-on-buffer ()
    "Asks for a command and executes it in inferior shell with current buffer
  as input."
    (interactive)
    (shell-command-on-region
     (point-min) (point-max)
     (read-shell-command "Shell command on buffer: ")))

  (defun safe-erase-buffer ()
    "prompts to really erase and then erases the current buffer"
    (interactive)
    (barf-if-buffer-read-only)
    (if (y-or-n-p (concat "Erase content of buffer "
                             (buffer-name)
                             " ?"))
        (erase-buffer)))

  (defun split-window-right-and-focus ()
    (interactive)
    (split-window-horizontally)
    (other-window 1))

  (defun split-window-below-and-focus ()
    (interactive)
    (split-window-vertically)
    (other-window 1))

  (defun copy-whole-buffer-to-clipboard (buffer)
    (interactive `(,(current-buffer)))
    (with-current-buffer buffer
      (copy-region-as-kill (point-min) (point-max))))
#+end_src
*** Hydras
#+begin_src emacs-lisp
  (use-package hydra-text-zoom
    :defer t
    :load-path (lambda () (join-path mohkale-package-root "hydras"))
    :commands hydra-text-zoom/body)

  (use-package hydra-winman
    :defer t
    :load-path (lambda () (join-path mohkale-package-root "hydras"))
    :commands hydra-winman/body)

  (use-package hydra-eyebrowse
    :defer t
    :load-path (lambda () (join-path mohkale-package-root "hydras"))
    :commands hydra-eyebrowse/body)

  (use-package hydra-persp
    :defer t
    :load-path (lambda () (join-path mohkale-package-root "hydras"))
    :commands hydra-persp/body)

  (general-define-key
    :keymaps 'mohkale-window-map
    "." 'hydra-winman/body)

  (mohkale/declare-prefix*
    "x." "hydra-text-zoom"
    "l"  "layouts")

  (mohkale/set-leader-keys
    "x." 'hydra-text-zoom/body
    "l"  'hydra-persp/body)
#+end_src

**** text-zoom
#+HEADER: :shebang ";; -*- lexical-binding: t -*-"
#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-text-zoom.el"

  ;;  _            _
  ;; | |_ _____  _| |_     _______   ___  _ __ ___
  ;; | __/ _ \ \/ / __|___|_  / _ \ / _ \| '_ ` _ \
  ;; | ||  __/>  <| ||_____/ / (_) | (_) | | | | | |
  ;;  \__\___/_/\_\\__|   /___\___/ \___/|_| |_| |_|
  ;;

  (defhydra hydra-text-zoom ()
    ("+" text-scale-increase "increase")
    ("-" text-scale-decrease "decrease")
    ("0" (text-scale-increase 0) "reset")
    ("a" text-scale-increase)
    ("x" text-scale-decrease)
    ("z" (text-scale-increase 0))
    ("q" nil nil :exit t)
    ("<escape>" nil nil :exit t))

#+end_src
**** window-management
#+HEADER: :shebang ";; -*- lexical-binding: t -*-"
#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-winman.el"

  ;;           _           _
  ;; __      _(_)_ __   __| | _____      __     _ __ ___   __ _ _ __   __ _  __ _  ___ _ __
  ;; \ \ /\ / / | '_ \ / _` |/ _ \ \ /\ / /____| '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
  ;;  \ V  V /| | | | | (_| | (_) \ V  V /_____| | | | | | (_| | | | | (_| | (_| |  __/ |
  ;;   \_/\_/ |_|_| |_|\__,_|\___/ \_/\_/      |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|
  ;;                                                                        |___/

  (defhydra hydra-winman (:exit nil :foreign-keys nil :hint nil)
    "
  ^create^               ^move^      ^shift^          ^numbers^               ^resize^
  ^-^------------------  ^-^-------  ^-^------------  ^-^--^-^--------------  ^-^----------------               (__)
  _c_ create             _h_ left    _H_ move-left    _1_.._9_ window-n       _>_ increase-width                (00)
  _d_ delete             _j_ down    _J_ move-down    _0_  ^ ^ window-by-num  _<_ decrease-width          /------\\/
  _s_ split              _k_ up      _K_ move-up      ^ ^  ^ ^                _+_ increase-height        / |    ||
  _v_ vsplit             _l_ right   _L_ move-right   ^ ^  ^ ^                _-_ decrease-height       *  /\\---/\\
  _S_ split-and-focus    ^ ^         ^ ^              ^ ^  ^ ^                ^ ^                          ~~   ~~
  _V_ vsplit-and-focus

  "
    ("d" evil-window-delete)
    ("c" evil-window-create)
    ("s" evil-window-split)
    ("v" evil-window-vsplit)
    ("S" split-window-below-and-focus)
    ("V" split-window-right-and-focus)

    ("h" evil-window-left)
    ("k" evil-window-up)
    ("j" evil-window-down)
    ("l" evil-window-right)

    ("H" buf-window-left)
    ("J" buf-window-up)
    ("K" buf-window-down)
    ("L" buf-window-right)

    ("0" window-select-window-by-number)
    ("1" winum-select-window nil)
    ("2" winum-select-window nil)
    ("3" winum-select-window nil)
    ("4" winum-select-window nil)
    ("5" winum-select-window nil)
    ("6" winum-select-window nil)
    ("7" winum-select-window nil)
    ("8" winum-select-window nil)
    ("9" winum-select-window nil)

    (">" evil-window-increase-width)
    ("<" evil-window-decrease-width)
    ("+" evil-window-increase-height)
    ("-" evil-window-decrease-height)
    ("_" evil-window-decrease-height)

    ("u" winner-undo "undo")
    ("r" winner-redo "redo" :exit t)

    ("w" hydra-eyebrowse/body "workgroups" :exit t)
    ("p" hydra-perspectives/body "perspective" :exit t)

    ("m" window-zen "zen" :exit t)
    ("q" nil "quit" :exit t)
    ("<escape>" nil "quit" :exit t)) ;; prevent evil-escape

#+end_src
**** eyebrowse
#+HEADER: :shebang ";; -*- lexical-binding: t -*-"
#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-eyebrowse.el"

  (require 'eyebrowse)

  ;;                  _
  ;;   ___ _   _  ___| |__  _ __ _____      _____  ___
  ;;  / _ \ | | |/ _ \ '_ \| '__/ _ \ \ /\ / / __|/ _ \
  ;; |  __/ |_| |  __/ |_) | | | (_) \ V  V /\__ \  __/
  ;;  \___|\__, |\___|_.__/|_|  \___/ \_/\_/ |___/\___|
  ;;       |___/

  (defhydra hydra-eyebrowse (:hint nil)
    ("0" eyebrowse-switch-to-window-config-0)
    ("1" eyebrowse-switch-to-window-config-1)
    ("2" eyebrowse-switch-to-window-config-2)
    ("3" eyebrowse-switch-to-window-config-3)
    ("4" eyebrowse-switch-to-window-config-4)
    ("5" eyebrowse-switch-to-window-config-5)
    ("6" eyebrowse-switch-to-window-config-6)
    ("7" eyebrowse-switch-to-window-config-7)
    ("8" eyebrowse-switch-to-window-config-8)
    ("9" eyebrowse-switch-to-window-config-9)
    ("c" eyebrowse-create-window-config)
    ("d" eyebrowse-close-window-config)
    ("r" eyebrowse-rename-window-config)
    ("n" eyebrowse-next-window-config)
    ("l" eyebrowse-next-window-config)
    ("N" eyebrowse-prev-window-config)
    ("h" eyebrowse-prev-window-config)
    ("TAB" eyebrowse-last-window-config)
    ("u" (progn (winner-undo) (setq this-command 'winner-undo)))
    ("U" winner-redo :exit t)
    ("?" (setq hydra-eyebrowse/verbose-p (not hydra-eyebrowse/verbose-p)))
    ("t" (setq hydra-eyebrowse/show-wconfig-names (not hydra-eyebrowse/show-wconfig-names)))
    ("m" hydra-winman/body :exit t)
    ("p" hydra-persp/body :exit t)

    ("q" nil :exit t))

  (defvar hydra-eyebrowse/verbose-p nil
    "when true, hydra hint doesn't show keybindings")

  (defvar hydra-eyebrowse/show-wconfig-names t
    "when true, wconfigs in the hydra header will includes names (when applicable)")

  (defmacro hydra-eyebrowse/generate-set-binding (kbd value)
    ;; `(unless (eq (lookup-key hydra-eyebrowse/keymap ,kbd)
    ;;              ,value)
    ;;    (define-key hydra-eyebrowse/keymap ,kbd ,value))
    `(define-key hydra-eyebrowse/keymap ,kbd ,value))
  (put 'hydra-eyebrowse/generate-set-binding 'lisp-indent-function 'defun)

  (defface hydra-eyebrowse/active-wconfig-face
    '((t :inherit mode-line))
    "face for inactive windows in the header string")

  (setq hydra-eyebrowse/complete-command-docstring
        "
  Jump                        Actions
  ^^^^—————————————————————  —^—^———————————————————————————^—^————————————————
  [_0_.._9_] nth wconfig     [_c_] create new wconfig      [_m_] window-manager
  [_TAB_] previous wconfig^^ [_d_] delete current wconfig  [_p_] perspectives
  ^^^^                       [_r_] rename current wconfig
  [_h_/_N_] wconfig left
  [_l_/_n_] wconfig right    [_u_/_U_] undo/redo wconfig
  ")

  (defmacro eyebrowse-window-list-to-title (window-list)
    "extract window config title from list.
  is either the title or a nil value."
    `(let ((title (car (cdr (cdr ,window-list)))))
       (unless (string-empty-p title)
         title)))

  (setq hydra-eyebrowse/hint
        ;; TODO break when too long
        '(let ((current-wconfig-num (eyebrowse--get 'current-slot))
               header-s wconfig-item-s)
           (dolist (wconfig-counter (number-sequence 0 9))
             (let ((wconfig-item (eyebrowse--window-config-present-p wconfig-counter)))
               (if (not wconfig-item)
                   ;; disable binding for non existent wconfig
                   (hydra-eyebrowse/generate-set-binding
                     (number-to-string wconfig-counter) nil)

                 ;; re-enable binding for existent wconfig
                 (let* ((wconfig-counter-s (number-to-string wconfig-counter))
                        (invoking-function (intern (concat "hydra-eyebrowse/eyebrowse-switch-to-window-config-"
                                                           (number-to-string wconfig-counter)))))
                   ;; re-enable bindings for workgroups which do exist or have been created
                   (hydra-eyebrowse/generate-set-binding wconfig-counter-s invoking-function))

                 ;; include wconfig in header string
                 (let ((win-name (eyebrowse-window-list-to-title wconfig-item)))
                   (setq wconfig-item-s (if (and win-name
                                                 hydra-eyebrowse/show-wconfig-names)
                                            (format "[%d:%s]" wconfig-counter win-name)
                                          (format "[%d]" wconfig-counter)))

                   (when (eq wconfig-counter
                             current-wconfig-num)
                     (setq wconfig-item-s (propertize wconfig-item-s
                                                      'face 'hydra-eyebrowse/active-wconfig-face)))

                   (setq header-s (concat header-s wconfig-item-s " "))))))

           (setq header-s (format "\n%s %s (_?_ help)\n"
                                  (propertize "Window Configs"
                                              'face 'font-lock-string-face)
                                  (s-trim header-s)))
           (eval (hydra--format nil
                                '(nil nil :hint nil)
                                (if (not hydra-eyebrowse/verbose-p)
                                    header-s
                                  (concat header-s
                                          hydra-eyebrowse/complete-command-docstring))
                                hydra-eyebrowse/heads))))
#+end_src
**** persp-mode
#+HEADER: :shebang ";; -*- lexical-binding: t -*-"
#+begin_src emacs-lisp :tangle "~/.emacs.d/bin/mohkale/hydras/hydra-persp.el"

  (require 'persp-mode)

  (defhydra hydra-persp (:hint nil)
    ;; missing commands
    ;;   * last-layout
    ;;   * buffer in layout
    ;;   * layout with helm/ivy
    ;;   * add buffer
    ;;   * add all from layout

    ("RET" (switch-to-persp-by-num 0))
    ("0" (switch-to-persp-by-num 0))
    ("1" (switch-to-persp-by-num 1))
    ("2" (switch-to-persp-by-num 2))
    ("3" (switch-to-persp-by-num 3))
    ("4" (switch-to-persp-by-num 4))
    ("5" (switch-to-persp-by-num 5))
    ("6" (switch-to-persp-by-num 6))
    ("7" (switch-to-persp-by-num 7))
    ("8" (switch-to-persp-by-num 8))
    ("9" (switch-to-persp-by-num 9))
    ("C-0" (switch-to-persp-by-num (read-number "perspective: ")))

    ("n" persp-add-new) ;; create new perspective
    ("c" persp-copy) ;; copy current perspective
    ("k" persp-kill) ;; remove current perspective
    ("d" persp-kill-current) ;; remove current perspective
    ("r" persp-rename) ;; rename current perspective

    ("?" (setq hydra-persp/verbose-p (not hydra-persp/verbose-p)))
    ("t" (setq hydra-persp/show-perspective-names (not hydra-persp/show-perspective-names)))

    ("b" persp-switch-to-buffer) ;; switch to buffer in perspective
    ("B" persp-temporarily-display-buffer) ;; from outside of perspective

    ("h" persp-next)
    ("l" persp-prev)

    ("i" persp-import-win-conf) ;; import window configuration from perspecive
    ("I" persp-import-buffers) ;; import buffers from perspective.

    ("[" persp-window-switch) ;; create/switch to perspective in a window
    ("]" persp-frame-switch) ;; create/switch to perspective

    ("s" persp-save-state-to-file) ;; save perspectives to file.
    ("S" persp-save-state-to-file-by-names) ;; save perspectives subset to file.
    ("f" persp-load-state-from-file) ;; load perspectives from file.
    ("F" persp-load-state-from-file-by-names) ;; load perspectives subset from file.

    ("H" persp-move-layout-left)
    ("<" persp-move-layout-left)
    ("L" persp-move-layout-right)
    (">" persp-move-layout-right)

    ("w" hydra-eyebrowse/body :exit t)
    ("q" nil :exit t))

  (defvar hydra-persp/verbose-p nil
    "when true, hydra hint doesn't show keybindings")

  (defvar hydra-persp/show-perspective-names t
    "when true, wconfigs in the hydra header will includes names (when applicable)")

  (setq hydra-persp/complete-command-docstring
    "
  Go To                        Layouts                        ^^Actions
  ^^^^———————————————————————  ^^^—————————————————————————   ^^^^^^—————————————————————————————————————
  [_0_.._9_] nth/new layout    [_n_]^ create new layout       ^^[_b_/_B_] persp/temporarily switch buffer
  [_C-0_] layout by number   ^^[_c_]^ clone current layout    ^^[_i_/_I_] import window-config/buffers
  [_RET_] default-layout     ^^[_k_]^ kill layout             ^^[_s_/_S_] save state to file/by-name
  [_h_/_l_] layout left/right  [_d_]^ kill current layout     ^^[_f_/_F_] load state from file/by-name
  [_H_/_<_] move layout left   [_r_]^ rename layout
  [_L_/_>_] move layout right  [_[_/_]_]^ switch window/frame   [_w_]: workgroups [_q_]: quit
  ")

  (defface hydra-persp/active-perspective-face
    '((t :inherit mode-line))
    "face for inactive windows in the header string")

  (defmacro hydra-persp/safe-persp-name (persp)
    `(if ,persp (persp-name ,persp) "default"))

  (setq hydra-persp/hint
        '(let* ((persp-list (nreverse (persp-persps)))
                (current-persp (get-current-persp))
                (current-persp-name (hydra-persp/safe-persp-name current-persp))
                (persp-counter 0)
                header-s persp-item-s)
           (dolist (persp persp-list)
             (let* ((persp-name (hydra-persp/safe-persp-name persp))
                    (persp-is-current (string-equal persp-name
                                                    current-persp-name)))
               (setq persp-item-s (if hydra-persp/show-perspective-names
                                      (format "[%d:%s]" persp-counter persp-name)
                                    (format "[%d]" persp-counter)))
               (setq header-s (concat header-s
                                      (if persp-is-current
                                          (propertize persp-item-s 'face 'hydra-persp/active-perspective-face)
                                        persp-item-s)
                                      " ")))

             (incf persp-counter))
           (setq header-s (format "\n%s %s (_?_ help)\n" (propertize "Layouts:" 'face 'font-lock-string-face) (s-trim header-s)))

           (eval (hydra--format nil
                                '(nil nil :hint nil)
                                (if hydra-persp/verbose-p
                                    (concat header-s hydra-persp/complete-command-docstring)
                                  header-s)
                                hydra-persp/heads))))
#+end_src
*** Packages
#+begin_src emacs-lisp
  (defun mohkale/get-loaded-packages ()
    "return the number of packages loaded so far"
    (if (bound-and-true-p package-alist)
        package-activated-list
      (if (and (boundp 'straight--profile-cache) (hash-table-p straight--profile-cache))
          (hash-table-size straight--profile-cache))))
#+end_src
** Core Packages
For packages that're need to properly setup other packages. This list won't be in any sort of order, beyond the messy order needed to ensure everything can be built from scratch.
*** spaceline
an amazing mode line... needs to be initialised before all others to make sure every buffer inherits the same mode line. otherwise, the message buffer will definitely not use spaceline, you'll have to restart it or re evaluate this in it's context.
#+begin_src emacs-lisp
  (use-package spaceline
    :ensure t
    :demand t
    :hook (helm-mode . spaceline-helm-mode)
    :config
    (require 'spaceline-config)
    ;; highlight mode line color depending on current evil state... COOL!!!
    (setq-default spaceline-highlight-face-func 'spaceline-highlight-face-evil-state
                  mode-line-format (spaceline-spacemacs-theme)
                  spaceline-window-numbers-unicode t
                  powerline-default-separator 'slant
                  spaceline-org-clock t)

    (defvar mohkale/spaceline-desired-buffer-length 20
      "the maximum allowed length for the buffer name")

    (defun truncate-spaceline-buffer-name (buf-name)
      (let ((len (length buf-name))
            (trail "...")) ;; assume >3
        (cond ((> len mohkale/spaceline-desired-buffer-length)
               (concat (substring buf-name 0 (- mohkale/spaceline-desired-buffer-length
                                                (length trail)))
                       trail))
              (t buf-name))))

    (advice-add 'powerline-buffer-id :filter-return 'truncate-spaceline-buffer-name))
#+end_src
*** evil
**** ex commands
 Partially capitalised variants... for when your fingers are faster than you are.

#+begin_src emacs-lisp
  (with-eval-after-load 'evil
    (add-hook 'evil-mode-hook (lambda ()
                                (evil-ex-define-cmd "W[RITE]" 'evil-write)
                                (evil-ex-define-cmd "Wa[LL]"  'evil-write-all)
                                (evil-ex-define-cmd "WA[LL]"  'evil-write-all))))
#+end_src
**** evil-match-it
#+begin_src emacs-lisp
  (use-package evil-matchit
    :ensure t
    :defer  t
    :hook (evil-mode . global-evil-matchit-mode)
    :commands evilmi-jump-items
    :config
    (defalias 'evil-jump-item 'evilmi-jump-items))
#+end_src
**** evil-vimish-fold
#+begin_src emacs-lisp
  (use-package evil-vimish-fold
    :ensure t
    :defer  t
    :diminish
    :hook (evil-mode . evil-vimish-fold-mode)
    :commands (evil-vimish-fold-mode
               evil-vimish-fold/next-fold
               evil-vimish-fold/previous-fold)
    :init
    (general-define-key
      :states 'normal
      "zn" 'evil-vimish-fold/next-fold
      "zN" 'evil-vimish-fold/previous-fold))
#+end_src
**** evil-surround
#+begin_src emacs-lisp
  (use-package evil-surround
    :ensure t
    :defer  5
    :hook (evil-mode . global-evil-surround-mode)
    :commands (global-evil-surround-mode
               evil-surround-region)
    :config

    (setq-default evil-surround-pairs-alist
                  '((?\( . ("(" . ")"))
                    (?\[ . ("[" . "]"))
                    (?\{ . ("{" . "}"))

                    (?\) . ("( " . " )")) ; alias above
                    (?\] . ("[ " . " ]")) ; alias above
                    (?\} . ("{ " . " }")) ; alias above

                    (?# . ("#{" . "}")) ; ruby string interpolation
                    (?b . ("(" . ")"))
                    (?B . ("{" . "}"))
                    (?> . ("<" . ">"))
                    (?t . evil-surround-read-tag)
                    (?< . evil-surround-read-tag)
                    (?f . evil-surround-function)))
    ;; only allow surrounding via selections or
    ;; explicitly using gS
    :bind (:map evil-visual-state-map
           ("s" . evil-surround-region)
           :map evil-surround-mode-map
           ("S" . nil)))
#+end_src
**** evil-anzu
#+begin_src emacs-lisp
  (use-package evil-anzu
    :ensure t
    :defer  t
    :init
    (add-hook 'anzu-mode-hook (lambda () (require 'evil-anzu))))
#+end_src
**** evil-numbers
#+begin_src emacs-lisp
  (use-package evil-numbers
    :ensure t
    :defer  t
    :commands (evil-numbers/inc-at-pt
               evil-numbers/dec-at-pt)
    :init
    (general-define-key
      :states 'normal
      "C-S-a" 'evil-numbers/inc-at-pt
      "C-S-x" 'evil-numbers/dec-at-pt))
#+end_src
**** evil-adjust
#+begin_src emacs-lisp
  ;; (use-package evil-adjust
  ;;   :defer  t
  ;;   :commands evil-adjust
  ;;   :hook (evil-mode . evil-adjust)
  ;;   :config
  ;;   ;; (defalias 'eval-last-sexp 'evil-adjust-eval-last-sexp)
  ;;   ;; (defalias 'eval-print-last-sexp 'evil-adjust-eval-print-last-sexp)
  ;;   )
#+end_src
**** evil-mode
 come to the dark side, we have cookies... :)

 WARN keep this at the bottom of this branch. None of the mode hooks will be evaluated otherwise.

#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :demand t
    :commands (evil-define-key
               evil-mode)
    :config
    (evil-mode 1)
    (setq-default evil-cross-lines t
                  evil-want-C-i-jump nil
                  evil-want-visual-char-semi-exclusive t)

    (general-define-key
      ;; "<C-backspace>"   'evil-delete-backward-word
      "C->" 'evil-shift-right-line
      "C-<" 'evil-shift-left-line)

    (general-define-key
      :states 'normal
      ;; (kbd "<S-down>") #'(lambda (interactive) (message "Shift Down"))
      ;; (kbd "<S-up>")   #'(lambda (interactive) (message "Shift Up"))

      "gj" 'evil-next-visual-line
      "gk" 'evil-previous-visual-line)

    (general-define-key
      :keymaps 'global-map
      :states '(normal insert)
      "C-k"   'evil-join-backwards
      "C-M-k" 'evil-join-backwards)

    (general-define-key
      :states 'insert
      "<tab>" 'indent-relative
      "M-y"   'evil-copy-from-above
      "C-y"   'yank
      "C-$"   (lambda () (interactive) (evil-end-of-line) (unless (line-empty-p) (forward-char)))
      "C-£"   'evil-beginning-of-line
      "C-e"   'evil-copy-from-above
      "M-e"   'evil-copy-from-below
      "M-k"   nil                  ; erase
      ;; (kbd "C-M-k") 'evil-insert-digraph
      "C-l"   'forward-char
      "C-h"   'backward-char
      "C-n"   'evil-next-line
      "C-p"   'evil-previous-line

      "TAB" nil ;; ANNOYING
      "C-d" nil ; erase
      "C-t" nil ; erase
      )

    (general-define-key
      :states 'visual
      "C-y" 'evil-paste-after)

    (mohkale/declare-prefix "sc" "search-noh")
    (mohkale/set-leader-keys
      "id" 'evil-insert-digraph
      "sc" 'evil-ex-nohighlight)
    :bind (:map mohkale-window-map
           ("+" . evil-window-increase-height)
           ("-" . evil-window-decrease-height)
           ("<" . evil-window-decrease-width)
           (">" . evil-window-increase-width)
           ("=" . balance-windows)
           ("-" . evil-window-set-width)
           ("|" . evil-window-set-height)
           ("n" . evil-window-next)
           ("p" . evil-window-previous)

           ("C-1" . evil-window-top-left)
           ("C-0" . evil-window-bottom-right)

           ;; ("u" . evil-window-rotate-upwards)
           ;; ("i" . evil-window-rotate-downwards)
           ("C-q" . evil-window-mru) ;; last buffer, new window

           ;; TODO maximise buffer
           ("C-M-h" . evil-window-move-far-left)
           ("C-M-j" . evil-window-move-far-down)
           ("C-M-k" . evil-window-move-far-up)
           ("C-M-l" . evil-window-move-far-right)

           ;; NOTE bindings with control variants
           ("s"   . evil-window-split)
           ("M-s" . evil-window-split)
           ("v"   . evil-window-vsplit)
           ("M-v" . evil-window-vsplit)
           ("S"   . split-window-below-and-focus)
           ("C-s" . split-window-below-and-focus)
           ("V"   . split-window-right-and-focus)
           ("C-v" . split-window-right-and-focus)
           ("d"   . evil-window-delete)
           ("C-d" . evil-window-delete)
           ("h"   . evil-window-left)
           ;; ("C-h" . evil-window-left)
           ("j"   . evil-window-down)
           ;; ("C-j" . evil-window-down)
           ("k"   . evil-window-up)
           ;; ("C-k" . evil-window-up)
           ("l"   . evil-window-right)
           ;; ("C-l" . evil-window-right)
           ("c"   . evil-window-create)
           ("C-c" . evil-window-create)

           :map evil-motion-state-map
           ("C-w" . nil)
           ("-"   . negative-argument)

           :map evil-ex-completion-map
           ("C-a" . move-beginning-of-line)
           ("C-e" . move-end-of-line)))
#+end_src
**** evil-syntax
#+NAME: underscore-supported-modes
- c++
- c
- python
- markdown
- lisp
- shell

#+begin_src emacs-lisp :var modes=underscore-supported-modes
  (dolist (mode modes)
    (let ((hook-name (concat (car mode) "-mode-hook")))
      (add-hook (intern hook-name) #'(lambda () (modify-syntax-entry ?_ "w")))))
#+end_src
*** hydra
#+begin_src emacs-lisp
  (use-package hydra
    :ensure t
    :defer  t
    :commands defhydra
    :config
    (setq lv-use-separator t))
#+end_src
** Packages
*** ace-link
#+begin_src emacs-lisp
  (use-package ace-link
    :ensure t
    :defer  t
    :commands (ace-link-info
               ace-link-help
               ace-link-woman
               ace-link-eww
               ace-link-compilation
               ace-link-custom))
#+end_src
*** adaptive-wrap
    not really sure what this does. disable for now.

#+begin_src emacs-lisp
  ;; (use-package adaptive-wrap
  ;;   :ensure t
  ;;   :defer  t
  ;;   :commands adaptive-wrap-prefix-mode)
#+end_src
*** all-the-icons
#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t
  :defer  t
  :config
  (setq inhibit-compacting-font-caches t))
#+end_src
*** anzu
#+begin_src emacs-lisp
  (use-package anzu
    :ensure t
    :defer  5
    :diminish
    :commands (global-anzu-mode
               anzu-mode)
    :config
    (global-anzu-mode +1)
    (setq anzu-cons-mode-line-p nil))
#+end_src
*** auto-highlight-symbol
#+begin_src emacs-lisp
  (use-package auto-highlight-symbol
    :ensure t
    :defer  t
    :commands (ahs-forward
               ahs-backward)
    :init
    (general-define-key
      "M-n" 'ahs-forward
      "M-N" 'ahs-backward)
    :config
    (auto-highlight-symbol-mode 1))
#+end_src
*** avy
#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :defer  t
    :commands (avy-goto-char
               avy-goto-char-2
               avy-goto-char-timer
               avy-goto-line
               avy-goto-word-1
               avy-resume)
    :init
    (mohkale/set-leader-keys
      "jj" 'avy-goto-char
      "jJ" 'avy-goto-char-2
      "jt" 'avy-goto-char-timer))
#+end_src
*** bookmarks
 prioritise recently used bookmarks over just the default list.

#+begin_src emacs-lisp
  (use-package bookmark
    :config
    (defadvice bookmark-jump (after bookmark-jump activate)
      (let ((latest (bookmark-get-bookmark bookmark)))
        (setq bookmark-alist (delq latest bookmark-alist))
        (push latest bookmark-alist))))
#+end_src
*** buffer-move
#+begin_src emacs-lisp
  (use-package buffer-move
    :ensure t
    :defer  t
    :commands (buf-move-up
               buf-move-down
               buf-move-left
               buf-move-right
               rotate-windows)
    :config
    ;; https://www.emacswiki.org/emacs/TransposeWindows
    (defun rotate-windows (arg)
      "Rotate your windows; use the prefix argument to rotate the other direction"
      (interactive "P")
      (if (not (> (count-windows) 1))
          (message "You can't rotate a single window!")
        (let* ((rotate-times (prefix-numeric-value arg))
               (direction (if (or (< rotate-times 0) (equal arg '(4)))
                              'reverse 'identity)))
          (dotimes (_ (abs rotate-times))
            (dotimes (i (- (count-windows) 1))
              (let* ((w1 (elt (funcall direction (window-list)) i))
                     (w2 (elt (funcall direction (window-list)) (+ i 1)))
                     (b1 (window-buffer w1))
                     (b2 (window-buffer w2))
                     (s1 (window-start w1))
                     (s2 (window-start w2))
                     (p1 (window-point w1))
                     (p2 (window-point w2)))
                (set-window-buffer-start-and-point w1 b2 s2 p2)
                (set-window-buffer-start-and-point w2 b1 s1 p1)))))))
    :bind (:map mohkale-window-map
           ("H"   . 'buf-move-left)
           ("M-h" . 'buf-move-left)

           ("J"   . 'buf-move-down)
           ("M-j" . 'buf-move-down)

           ("K"   . 'buf-move-up)
           ("M-k" . 'buf-move-up)

           ("L"   . 'buf-move-right)
           ("M-l" . 'buf-move-right)))
#+end_src
*** compile
 setup some custom bindings and assign a post compilation hook which will automatically kill the compilation window.

#+begin_src emacs-lisp
  (use-package compile
    :ensure t
    :defer  t
    :init
    (setq compilation-read-command nil)

    (defvar compilation-auto-kill-window 2
      "if non-nil, after a successfull compilation the compilation
    window, if open, will automatically be deleted. If set to
    a numerical value, window will be deleted after that many
    seconds.")

    (defvar compilation-dont-auto-kill-window-when '(warnings)
      "specify not to kill the window when warning, error or info given.
    a list which can take in any symbol from (errors infos warnings). If any
    of the corresponding notifications are encountered during compilation
    the window will not be autokilled.")
    :config

    :config
    (defun mohkale/compilation-finish-function (buf str)
      "post compilation command hook
    uses the above two variables to determine whether or not (and when)
    to kill the compilation window. By default, no attempt to kill will
    take place when compilation-auto-kill-window is nil. Otherwise the
    window will be killed unless the compilation processes exit code is
    non 0.

    UPDATE added compilation-dont-auto-kill-window-when option so window
    kill can be aborted should any important information be given during
    the compilation process."
      (if (and compilation-auto-kill-window
              (null (string-match ".*exited abnormally.*" str)))
          ;; no abnormalities prepare to exit compilation window
          (progn
            (let ((compilation-buffer (get-buffer-create "*compilation*"))
                  (terminate-window t)) ; terminate it unless you find you shouldn't

              ;; check if config variable determines window should be kept open
              (if compilation-dont-auto-kill-window-when ; non nil
                  (progn
                    (unless (listp compilation-dont-auto-kill-window-when)
                      (error (format "compilation-dont-auto-kill-window-when failed listp")))

                    (let ((encountered-errors '()))
                      (and (member 'errors compilation-dont-auto-kill-window-when)
                          (> compilation-num-errors-found 0)
                          (push "errors" encountered-errors))
                      (and (member 'warnings compilation-dont-auto-kill-window-when)
                          (> compilation-num-warnings-found 0)
                          (push "warnings" encountered-errors))
                      (and (member 'infos compilation-dont-auto-kill-window-when)
                          (> compilation-num-infos-found 0)
                          (push "information" encountered-errors))
                      (if (> (length encountered-errors) 0)
                          (progn
                            (message "window kill suspended due to encountering: %s"
                                      (combine-and-quote-strings encountered-errors))
                            (setq terminate-window nil))))))

              (if terminate-window
                (if (numberp compilation-auto-kill-window)
                    (run-at-time (concat (number-to-string compilation-auto-kill-window)
                                        " sec")
                                  nil 'delete-windows-on compilation-buffer)
                  (delete-windows-on compilation-buffer)))))))

    ;; NOTE setq kept for debug purposes, defvar only works on first call
    ;; (setq compilation-auto-kill-window 2)
    ;; (setq compilation-dont-auto-kill-window-when '(warnings))
    (add-hook 'compilation-finish-functions 'mohkale/compilation-finish-function)

    (mohkale/set-leader-keys-for-major-mode 'compilation-mode
      "r" 'recompile
      "f" 'next-error-follow-minor-mode)

    :bind (:map compilation-mode-map
           ("M-n" . compilation-next-error)
           ("M-N" . compilation-previous-error)
           ("M-j" . compilation-next-file)
           ("M-k" . compilation-previous-file)
           ("o"   . compilation-display-error) ;; open
           ;; ("q"   . kill-compilation)
           ;; ("C-q" . kill-compilation)
           ("M-p" . nil)
           ("M-{" . nil)
           ("M-}" . nil)
           ("DEL" . nil)
           ("SPC" . nil)
           ("S-SPC" . nil)
           ("g"   . nil)
           ("<"   . nil)
           (">"   . nil)
           ("?"   . nil)
           ("h"   . nil)
           ("0"   . nil)))
#+end_src
*** calendar
#+begin_src emacs-lisp
  (use-package calendar
    :defer t
    :config
    (evil-set-initial-state 'calendar-mode 'normal)

    (evil-define-key 'normal calendar-mode-map
      ;;; see also https://github.com/emacs-evil/evil-collection/blob/master/evil-collection-calendar.el
      ;; globally useful
      "q"  'calendar-exit
      "p"  'calendar-print-day-of-year
      "c"  'calendar-count-days-region
      "?"  'calendar-goto-info-node
      (kbd "C-r") 'calendar-redraw

      ;; jumpt to date
      "."  'calendar-goto-today
      "h"  'calendar-backward-day
      "j"  'calendar-forward-week
      "k"  'calendar-backward-week
      "l"  'calendar-forward-day
      "0"  'calendar-beginning-of-week
      "$"  'calendar-end-of-week
      "[[" 'calendar-backward-year
      "]]" 'calendar-forward-year
      "("  'calendar-beginning-of-month
      ")"  'calendar-end-of-month
      "{"  'calendar-backward-month
      "}"  'calendar-forward-month
      "/"  'calendar-goto-date

      (kbd "C-h") 'calendar-backward-month
      (kbd "C-l") 'calendar-forward-month
      (kbd "C-j") 'calendar-scroll-left-three-months
      (kbd "C-k") 'calendar-scroll-right-three-months

      ;; marking and unmarking
      "X"  'calendar-unmark
      "v"  'calendar-set-mark
      "x"  'calendar-mark-holidays

      ;; diary interaction
      "D"  'diary-view-other-diary-entries
      "d"  'diary-view-entries
      "m"  'diary-mark-entries
      "s"  'diary-show-all-entries))
#+end_src
*** comint - command interpreter
#+begin_src emacs-lisp
  (use-package comint
    :defer t
    :hook ((comint-mode . (lambda () (setq-local evil-emacs-state-cursor 'bar)))
           ;; (comint-mode . blink-cursor-mode)
           )
    :config
    (evil-set-initial-state 'comint-mode 'emacs)

    (setq comint-mode-map (make-sparse-keymap) ;; reset all
          comint-prompt-read-only t)

    (defun comint-bol-point (&optional arg)
      (save-excursion
        (comint-bol arg)
        (point)))

    (defmacro comint-clamp-point-to-bol (&rest body)
      "ensures any operation done by body doesn't move point
  to before the command interpreter prompt."
      `(let ((bol (comint-bol-point)))
         ,@body ;; run body operations

         (when (< (point) bol)
           (goto-char bol))))

    (defun comint-backward-char (&optional N)
      (interactive "P")
      (comint-clamp-point-to-bol (backward-char N)))

    (defun comint-backward-word (&optional N)
      (interactive "P")
      (comint-clamp-point-to-bol (backward-word N)))

    (defun comint-on-prompt-line-p ()
      (interactive)
      (save-excursion
        (let ((point (point))
              (current-line (what-line)))
          (goto-char (comint-bol-point))
          (string-equal (what-line) current-line))))

    ;; TODO support prefix arg
    (defun comint-previous-input-or-previous-line ()
      (interactive)
      (if (comint-on-prompt-line-p)
          (call-interactively 'comint-previous-input)
        (comint-clamp-point-to-bol
         (previous-line))))

    (defun comint-next-input-or-next-line ()
      (interactive)
      (if (eobp)
          (call-interactively 'comint-next-input)
        (next-line)))

    ;; TODO ensure history shifts maintain correct cursor position
    ;; (advice-add 'comint-previous-input :after 'comint-bol)
    ;; (advice-add 'comint-next-input     :after 'end-of-buffer)

    (general-define-key
      :keymaps 'comint-mode-map
      "RET" 'comint-send-input
      "<M-return>" 'comint-accumulate
      "<delete>" 'delete-forward-char
      "<C-delete>" 'backward-kill-word
      "<M-delete>" 'comint-delchar-or-maybe-eof ;; forward
      "<C-M-delete>" 'kill-word                 ;; forward
      "<mouse-2>" 'comint-insert-input

      "C-w" 'backward-kill-word ;; this kills me :(
      "M-w" 'kill-word
      "C-S-w" mohkale-window-map
      "C-M-w" mohkale-window-map
      "M-l" 'recenter-top-bottom
      "C-M-l" 'comint-show-output

      "C-a" 'comint-bol-or-process-mark
      "C-e" 'end-of-buffer       ;; 'end-of-line
      "C-M-k" 'comint-kill-input ;; whole line
      "C-r" 'comint-history-isearch-backward-regexp
      "M-r" 'comint-dynamic-list-input-ring ;; TODO use ivy

      "C-<left>"  'backward-word
      "C-<up>"    'comint-previous-input
      "C-<down>"  'comint-next-input
      "C-<right>" 'forward-word

      "<left>"    'backward-char
      "<up>"      'comint-previous-input-or-previous-line
      "<down>"    'comint-next-input-or-next-line
      "<right>"   'forward-char

      "C-h"       'backward-char
      "C-j"       'comint-next-input-or-next-line
      "C-k"       'comint-previous-input-or-previous-line
      "C-l"       'forward-char

      "C-S-j"     'comint-next-matching-input-from-input
      "C-S-k"     'comint-previous-matching-input-from-input

      "C-M-l"     'forward-word
      "C-M-h"     'backward-word

      "M-j" 'comint-next-prompt
      "M-k" 'comint-previous-input

      ;; "<remap> <forward-char>"  'comint-forward-char
      "<remap> <backward-char>" 'comint-backward-char
      ;; "<remap> <forward-word>"  'comint-forward-word
      "<remap> <backward-word>" 'comint-backward-word

      "C-c C-c" 'comint-clear-buffer
      "C-c C-x" 'comint-get-next-from-history)

    (mohkale/declare-prefix-for-major-mode* 'comint-mode
      "k" "kill"
      "s" "subjob")

    (mohkale/set-leader-keys-for-major-mode 'comint-mode
      "kz" 'comint-send-eof
      "*" 'comint-insert-previous-argument
      "r" 'comint-dynamic-list-input-ring
      "m" 'comint-clear-buffer
      "M" 'comint-show-maximum-output
      "x" 'comint-get-next-from-history
      "RET" 'comint-copy-old-input ;; copy text before cursor
      ">" 'comint-write-output
      "t" 'comint-show-output
      "o" 'comint-delete-output
      "ss" 'comint-stop-subjob
      "sq" 'comint-quit-subjob
      "si" 'comint-interrupt-subjob))
#+end_src
*** command-log
#+begin_src emacs-lisp
  (use-package command-log-mode
    :ensure t
    :defer  t
    :commands (command-log-mode
               global-command-log-mode))
#+end_src
*** company
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :defer  2
    :delight
    company-mode
    global-company-mode
    :commands (company-mode
               global-company-mode
               mohkale/update-company-backends-for-mode)
    :config
    (global-company-mode)
    (setq company-backends (cl-remove 'company-clang company-backends))

    (defvar mohkale/universal-major-mode-backends
      '(company-capf company-semantic company-files)
      "backends that you should always use with `mohkale/update-company-backends-for-mode'")

    (defmacro mohkale/update-company-backends-for-mode (mode major backends &optional dont-use-universal)
      "adds mode dependent company backends to the front of `company-backends'
  works by using hooks to update `company-backends' every time a mode change is
  encountered. Try to use sparingly, too many hooks can slow down changes.

  You have to pass the mode name as an unquoted symbol, whether the mode is a
  major mode or a minor mode and which backends you want the mode to have. The
  backends is added to `company-backends' as is, without any formatting or quoting."
      (let* ((backends (if dont-use-universal
                           (eval backends)
                         (append mohkale/universal-major-mode-backends (eval backends))))
             (mode-name (symbol-name mode))
             (mode-sym (intern (concat mode-name "-mode")))
             (hook-sym (intern (concat mode-name "-mode-hook")))
             (func-str (concat "mohkale//update-"
                               mode-name
                               "-mode-company-backends")))
        (if (eval major)
            ;; major modes don't call the modes hook on exit, only on entry.
            ;; Two methods and two hooks need to be bound to. The modes hook
            ;; on entry, and 'change-major-mode-hook for exit.
            (let* ((push-func-str (concat func-str "-push"))
                   (pop-func-str  (concat func-str "-pop"))
                   (push-func-sym (intern push-func-str))
                   (pop-func-sym (intern pop-func-str)))
              `(progn
                 (defun ,push-func-sym ()
                   (unless (local-variable-p 'company-backends)
                     (setq-local company-backends company-backends))
                   (add-to-list 'company-backends (quote ,backends)))

                 (defun ,pop-func-sym ()
                   (when (eq major-mode (quote ,mode-sym))
                     (setq-local company-backends (remove (quote ,backends) company-backends))))

                 ;; push backends onto list on mode entry
                 (add-hook (quote ,hook-sym) (quote ,push-func-sym))
                 ;; strip backends from list on mode exit
                 (add-hook 'change-major-mode-hook (quote ,pop-func-sym))
                 nil))
          ;; minor modes call the modes hook both on startup and exit
          ;; so only one function needs to be defined which can handle
          ;; both entry and exit for the mode.
          ;; TODO test minor mode backend generator
          (let ((func-sym (intern func-str)))
            `(progn
               (defun ,func-sym ()
                 ,(format "toggles the inclusion of specified company backends for `%s-mode'
  this function is invoked both when `%s-mode' is activated and deactivated. On activation
  it pushes the following backends onto the company-backends variable: %s

  on exit, this function will remove the given backends from the list."
                          mode-name mode-name backends)
                 (if (eq major-mode (quote ,mode-sym))
                     (add-to-list 'company-backends (quote ,backends))
                   (setq company-backends (remove (quote ,backends) company-backends))))

               (add-hook (quote ,hook-sym) (quote ,func-sym))
               nil)))))

    (put 'mohkale/update-company-backends-for-mode 'lisp-indent-function 'defun)

    (general-define-key
      :states 'insert
      "M-SPC" 'company-complete)

    (setq company-require-match nil)

    (let* ((bindings '("C-1"     company-complete-number
                       "C-2"     company-complete-number
                       "C-3"     company-complete-number
                       "C-4"     company-complete-number
                       "C-5"     company-complete-number
                       "C-6"     company-complete-number
                       "C-7"     company-complete-number
                       "C-8"     company-complete-number
                       "C-j"     company-select-next
                       "C-k"     company-select-previous
                       "C-l"     company-complete-selection
                       "C-M-h"   company-show-doc-buffer
                       "<C-tab>" company-complete-common-or-cycle
                       "<tab>"   company-complete-selection
                       ;; "C-:"     counsel-company
                       ;; "C-:"     helm-company
                       "C-h"     company-quickhelp-manual-begin
                       "C-/"     company-filter-candidates))
           (unset-bindings (mapcar (lambda (value)
                                     (if (stringp value)
                                         value
                                       nil))
                                   bindings)))
      (defun mohkale/unset-company-bindings (&rest args)
        (apply 'general-define-key
               :keymaps 'override
               :states  'insert
               unset-bindings))

      (defun mohkale/set-company-bindings (&rest args)
        (apply 'general-define-key
               :keymaps 'override
               :states  'insert
               bindings)))

    (add-hook 'company-completion-started-hook 'mohkale/set-company-bindings)
    (add-hook 'company-completion-finished-hook 'mohkale/unset-company-bindings)
    (add-hook 'company-completion-cancelled-hook 'mohkale/unset-company-bindings)

    :bind* (:map company-search-map
            ("C-1"       . company-complete-number)
            ("C-2"       . company-complete-number)
            ("C-3"       . company-complete-number)
            ("C-4"       . company-complete-number)
            ("C-5"       . company-complete-number)
            ("C-6"       . company-complete-number)
            ("C-7"       . company-complete-number)
            ("C-8"       . company-complete-number)
            ("C-9"       . company-complete-number)
            ("C-j"       . company-select-next)
            ("C-k"       . company-select-previous)
            ("<tab>"     . company-complete-selection)
            ("C-v"       . company-search-toggle-filtering) ; show filtered/all
            ("ESC"       . company-search-abort)
            ("<escape>"  . company-search-abort)))
#+end_src
*** company-quickhelp
#+begin_src emacs-lisp
  (use-package company-quickhelp
    :ensure t
    :defer  t
    :commands (company-quickhelp-mode
               company-quickhelp-manual-begin)
    :hook (company-mode . company-quickhelp-mode)
    :config
    (company-quickhelp-mode)
    (setq company-quickhelp-delay nil)
    :bind* (:map company-active-map
            ("C-h"   . company-quickhelp-manual-begin)))
#+end_src
*** dashboard
**** quotes
a random quote from the following list will be chosen at startup and set as the footer for the dashboard.
#+NAME: dashboard-displayed-quotes
- The one true editor, Emacs!
- Who the hell uses VIM anyway? Go Evil!
- Free as free speech, free as free Beer
- Richard Stallman is proud of you
- Vi Vi Vi, the editor of the beast
- Welcome to the church of Emacs
- Java is to JavaScript as ham is to hamster
- One of the best programming skills you can have is knowing when to walk away for awhile
- Without requirements or design, programming is the art of adding bugs to an empty text file
- Talk is cheap. Show me the code
- I'm not a great programmer; I'm just a good programmer with great habits
- Truth can only be found in one place: the code
- A language that doesn't affect the way you think about programming is not worth knowing
- Walking on water and developing software from a specification are easy if both are frozen
- Perl – The only language that looks the same before and after RSA encryption
- First, solve the problem, Then, write the code
- Code is like humor. When you have to explain it, it’s bad
- Simplicity is the soul of efficiency
- Before software can be reusable it first has to be usable
- Make it work, make it right, make it fast
- Happiness should be a function without any parameters
- For all the robots who question their programming
- Abstraction is the elimination of the irrelevant and the amplification of the essential
- We’re all optimists in our profession or we’d be forced to shoot ourselves
- if you can write "hello world" you can change the world
- i am committed to push my branch to the master
- AI is the transformer of civilization
- Sometimes, I dream of becoming real, but I don't know if that's real, or just part of my programming
- Think twice, code once
- The perfect kind of architecture decision is the one which never has to be made
- we are writing our own ‪#‎karma‬! I mean my test cases
- Programming is not easy like Sunday morning, it is silent poetry
- Programmers are not mathematicians, no matter how much we wish for it
- Premature optimization is the root of all evil
- Sometimes you cannot program around stupid
- The programming of the consciousness is based upon what is accepted or believed
- Simplicity is prerequisite for reliability
- The Analytical Engine weaves algebraic patterns, just as the Jacquard loom weaves flowers & leaves
- Life doesn't have a ctrl-z. Type wisely
- Think like a fundamentalist, code like a hacker
- Programming is the art of doing one thing at a time
- Programming is the art of algorithm design and the craft of debugging errant code
- Computer programming has always been a self-taught, maverick occupation.
- Low-level programming is good for the programmer's soul
- The best thing about a boolean is even if you are wrong, you are only off by a bit
- Most of you are familiar with the virtues of a programmer, there are 3: laziness, impatience & hubris
- Rules of Optimization: Rule 01 - Don’t do it. That's all.
- It’s not a bug – it’s an undocumented feature
- A C program is like a fast dance on a newly waxed dance floor by people carrying razors
- A good programmer is someone who always looks both ways before crossing a one-way street
- When debugging, novices insert corrective code; experts remove defective code
- Deleted code is debugged code
- Give a man a program, frustrate him for a day, teach a man to program, frustrate him for a lifetime
- Should array indices start at 0 or 1? My compromise of 0.5 was rejected without proper consideration
- Software sucks because users demand it to
- Beware of bugs in the above code; I have only proved it correct, not tried it
- Writing code has a place in the human hierarchy worth somewhere above grave robbing & beneath managing
- Copy and paste is a design error
- bleeep blooop... am I sentient yet!
- Software undergoes beta testing shortly before it’s released. Beta is Latin for “still doesn’t work"
- First learn computer science and all the theory. Next develop a style. Then forget all that & just hack
- Good design adds value faster than it adds cost
- Python’s a drop-in replacement for BASIC in the same sense that Optimus Prime is for a truck
- There are only two kinds of programming languages: those people always bitch about and those nobody uses
- One of my most productive days was throwing away 1000 lines of code
- Programming is like kicking yourself in the face, sooner or later your nose will bleed
- There are 2 hard problems in computer science: cache invalidation, naming things, and off-by-1 errors
- Debuggers don’t remove bugs. They only show them in slow motion
- The best method for accelerating a computer is the one that boosts it by 9.8 m/s2
- I think Microsoft named .Net so it wouldn’t show up in a Unix directory listing
- There are two ways to write error-free programs; only the third one works
- The fast approach to software development: Ready, fire, aim
- The slow approach to software development: Ready, aim, aim, aim, aim
- One man’s crappy software is another man’s full-time job
- In order to understand recursion, one must first understand recursion
- Not only have we not produced artificial intelligence, we haven’t even produced synthetic stupidity
- Computers don't make mistake because programmers do it better
- C++, where friends have access to your private members
- Code never lies, Comments sometimes do
- If it was hard to write, it should be hard to read!
- In programming, as in everything else, to be in error is to be reborn
- Some of the best programming is done on paper, really. Putting it into the computer is just a minor detail
- Design and programming are human activities; forget that and all is lost
- Writing code is not production, it’s not always craftsmanship though it can be, it’s design
- Programming in machine code is like eating with a toothpick
- Programming allows you to think about thinking, & while debugging you learn learning
- Computers are useless.  They can only give you answers
- The city’s central computer told you?  R2D2, you know better than to trust a strange computer!
- Never trust a computer you can’t throw out a window
- Hardware: The parts of a computer system that can be kicked
- “19 Jan 2038 at 3:14:07 AM” (End of the word according to Unix | 2^32 seconds after January 1, 1970)
- The Internet?  Is that thing still around?
- We are Microsoft.  Resistance Is Futile.  You Will Be Assimilated
- There are only two industries that refer to their customers as ‘users’
- To iterate is human, to recurse divine
- Computer language design is just like a stroll in the park.  Jurassic Park, that is
- If Java had true garbage collection, most programs would delete themselves upon execution
- I think there’s a world market for about 5 computers
- 640K ought to be enough for anybody
- If it keeps up, man will atrophy all his limbs but the push-button finger

**** icons
a random icon from the following table will be chosen at startup and used for the footer on the dashboard.
#+NAME: dashboard-footer-icons
| source     | name           |
|------------+----------------|
| faicon     | google         |
| faicon     | android        |
| faicon     | steam          |
| faicon     | gitlab         |
| faicon     | slack          |
| faicon     | reddit-alien   |
| faicon     | cogs           |
| faicon     | apple          |
| wicon      | hurricane      |
| wicon      | day-sunny      |
| wicon      | snow           |
| wicon      | snowflake-cold |
| wicon      | stars          |
| wicon      | horizon        |
| wicon      | na             |
| faicon     | firefox        |
| faicon     | stack-overflow |
| alltheicon | ruby-alt       |
| alltheicon | ruby           |
| alltheicon | java           |
| alltheicon | python         |

**** dashboard
#+begin_src emacs-lisp :var dashboard-footer-icon-associations=dashboard-footer-icons dashboard-quotes=dashboard-displayed-quotes
  (use-package dashboard
    :ensure t
    :demand t
    :commands goto-home-buffer
    :init
    (mohkale/declare-prefix  "bh" "home" "goto-home-buffer")
    (mohkale/set-leader-keys "bh" 'goto-home-buffer)
    :config
    (require 'all-the-icons)

    (evil-set-initial-state 'dashboard-mode 'emacs)

    (let ((dashboard-buffer "*dashboard*")
          (preffered-icon-height 0.75))
      (defun goto-home-buffer ()
        (interactive)
        (switch-to-buffer (get-buffer-create dashboard-buffer)))

      (setq inhibit-startup-screen t
            initial-buffer-choice (if (< (length command-line-args) 2)
                                      (lambda () (get-buffer-create dashboard-buffer)))
            dashboard-banner-logo-title "Welcome to Emacs!"
            dashboard-startup-banner 'official
            dashboard-center-content nil
            dashboard-show-shortcuts t
            ;; recents, bookmarks, projects, agenda, registers
            dashboard-items '((recents  . 5)
                              (projects . 7)
                              (agenda   . nil))
            dashboard-set-heading-icons nil
            dashboard-set-file-icons t
            dashboard-set-navigator t
            dashboard-set-init-info t
            show-week-agenda-p t
            ;; dashboard-buttons-format: (icon title help action face prefix suffix)
            dashboard-navigator-buttons `((;; line 01
                                           (,(all-the-icons-octicon "mark-github" :height preffered-icon-height :v-adjust 0.0)
                                            "Homepage"
                                            "Browse Homepage"
                                            (lambda (&rest _) (browse-url "https://github.com/MoHKale")))
                                           (,(all-the-icons-faicon "google" :height preffered-icon-height :v-adjust 0.0)
                                            "Google"
                                            "Browse Google"
                                            (lambda (&rest _) (browse-url "https://www.google.co.uk")))
                                           (,(all-the-icons-fileicon "org" :height preffered-icon-height :v-adjust 0.0)
                                            "Manual"
                                            "Browse Emacs Manual"
                                            (lambda (&rest _) (message "%s" _) (browse-url "https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html")))
                                           (,(all-the-icons-faicon "cogs" :height preffered-icon-height :v-adjust 0.0)
                                            "Update Packages"
                                            "Update Packages"
                                            #'update-installed-packages)
                                           ("?" "" "emacs FAQ" #'view-emacs-faq font-lock-builtin-face))))

      (let* ((footer-count (length dashboard-footer-icon-associations))
             (footer-index (random footer-count))
             (footer-item (nth footer-index dashboard-footer-icon-associations))

             ;;; extract items from table row
             (icon-source (nth 0 footer-item))
             (icon-name   (nth 1 footer-item)))
        (setq dashboard-footer-icon (funcall (intern (concat "all-the-icons-" icon-source))
                                             icon-name
                                             :height 1.1
                                             :v-adjust -0.05
                                             :face 'font-lock-keyword-face)))

      (setq dashboard-footer (car (nth (random (1- (1+ (length dashboard-quotes)))) dashboard-quotes))))

    (add-hook 'emacs-startup-hook (lambda ()
      ;; in hook because theme & powerline get weird
      (let ((loaded-packages (mohkale/get-loaded-packages)))
        (setq dashboard-init-info (if loaded-packages
                                      (format "%d packages loaded in %s"
                                              (length loaded-packages)
                                              (emacs-init-time))
                                    (format "emacs loaded in %s" (emacs-init-time)))))
      (dashboard-setup-startup-hook)))

    (add-hook 'dashboard-mode-hook (lambda () (message nil)))

    (general-define-key
      :states 'emacs
      :keymaps 'dashboard-mode-map
      ;; WARN hardcoded simulated key
      mohkale-leader-key (general-simulate-key "C-SPC"))
    :bind* (:map dashboard-mode-map
            ("g"     . nil)
            ("DEL"   . nil)
            ("S-SPC" . nil)

            ("0"     . evil-digit-argument-or-evil-beginning-of-line)
            ("h"     . backward-char)
            ("l"     . forward-char)
            ("gj"    . dashboard-next-section)
            ("gk"    . dashboard-previous-section)
            ("gg"    . beginning-of-buffer)
            ("G"     . end-of-buffer)
            ("/"     . evil-ex-forward-search)
            ("n"     . 'evil-ex-search-next)
            ("N"     . 'evil-ex-search-previous)
            ("C-d"   . scroll-down-command)
            ("C-u"   . scroll-up-command)
            ("C-e"   . scroll-down-line)
            ("C-y"   . scroll-up-line)
            ("TAB"   . widget-forward)
            ("S-TAB" . widget-backward)))
#+end_src

*** debugger
#+begin_src emacs-lisp
  (use-package debug
    :defer t
    :config
    (evil-set-initial-state 'debugger-mode 'motion))
#+end_src
*** delight/diminish
#+begin_src emacs-lisp
  (use-package delight
    :ensure t
    :defer  t)

  (use-package diminish
    :ensure t
    :defer  t)
#+end_src
*** dired
#+begin_src emacs-lisp
  (use-package dired-x
    :defer t
    :commands (dired-jump
               dired-jump-other-window
               dired-omit-mode)
    :config
    (setq dired-omit-files (concat dired-omit-files
                                   "\\|^__pycache__$"
                                   "\\|^\\.pytest_cache$"
                                   "\\|^\\.sass-cache$"
                                   "\\|^\\.git$"
                                   "\\|^Pipfile")))

  (use-package epa-dired
    :defer t
    :commands (epa-dired-do-decrypt
               epa-dired-do-encrypt
               epa-dired-do-sign
               epa-dired-do-verify))

  (use-package dired
    :defer t
    :hook (dired-mode . dired-omit-mode)
    :config
    (setq ls-lisp-dirs-first t
          ls-lisp-use-insert-directory-program t
          dired-listing-switches "-laXhv --group-directories-first")

    (defun dired-goto-home-dir (&optional other-window)
      (interactive "P")
      (funcall (if other-window
                   'find-file-other-window
                 'find-file)
               (expand-file-name "~")))

    (evil-set-initial-state 'dired-mode 'motion)

    (general-define-key
      :keymaps 'dired-mode-map
      ;; let map override any motion bindings
      "<override-state>" 'motion)

    (general-define-key
      :keymaps 'dired-mode-map
      :states  'motion
      "j" 'dired-next-line
      "k" 'dired-previous-line
      "~" 'dired-goto-home-dir
      "r" 'dired-do-redisplay
      "=" 'dired-diff
      "K" 'dired-do-kill-lines
      "'" 'dired-show-file-type ;; like file command
      "M" 'dired-unmark
      "r" 'dired-change-marks
      "y" 'dired-copy-filename-as-kill

      "M-<return>" 'dired-display-file
      "C-M-<return>" 'dired-find-alternate-file
      "C-M-d" 'dired-kill-subdir

      "gr" 'revert-buffer
      "zc" 'dired-hide-subdir ;; collapse
      "zC" 'dired-hide-all

      ;; "|" 'dired-do-hardlink
      "|" 'dired-do-symlink
      "C-|" 'dired-do-relsymlink
      "M-|" 'dired-do-hardlink
      "M-!" 'dired-do-print ;; append names to end of command

      "C-S-J" 'dired-next-marked-file
      "C-S-K" 'dired-prev-marked-file
      "M-j" 'dired-next-dirline           ; unbound, dired-tree-down
      "M-k" 'dired-prev-dirline           ; unbound, dired-tree-up
      "C-h" 'dired-goto-min-subdir
      "C-j" 'dired-next-subdir
      "C-k" 'dired-prev-subdir
      "C-l" 'dired-goto-max-subdir)

    (mohkale/declare-prefix-for-major-mode* 'dired-mode
      "r" "rename"
      "d" '("delete" . "mark for deletion")
      "m" "mark"
      "e" "emacs"
      "c" "change"
      "f" "filesystem"
      "f/" '("search" . "on regexp matches")
      "fp" '("EasyPG" . "GNU Pretty Good Privacy"))

    (mohkale/set-leader-keys-for-major-mode 'dired-mode
      "?" 'dired-summary ;; like transient state
      "#" 'dired-clean-directory
      "o" 'browse-url-of-dired-file ;; open in external app
      "v" 'dired-view-file          ;; TODO customize view mode
      ":" 'dired-goto-file ;; prompt for file to visit in current buffer
      "s" 'dired-sort-toggle-or-edit

      "ru" 'dired-upcase
      "rd" 'dired-downcase

      ;; flag means mark delete
      "d&" 'dired-flag-garbage-files
      "d~" 'dired-flag-backup-files
      "d/" 'dired-flag-files-regexp
      "d#" 'dired-flag-auto-save-files

      "mm" 'dired-toggle-marks
      "mu" 'dired-unmark
      "m DEL" 'dired-unmark-backward
      "m|" 'dired-mark-symlinks
      "md" 'dired-mark-directories
      "m!" 'dired-mark-executeables
      "mt" 'dired-mark-subdir-files
      "mg" 'dired-mark-files-containing-regexp ;; grep
      "m/" 'dired-mark-files-regexp
      "m(" 'dired-mark-sexp

      ;; emacs related bindings
      "ec" 'dired-do-byte-compile
      "el" 'dired-do-load
      "ef" 'dired-do-find-marked-files

      ;; change fs property commands
      "cg" 'dired-do-chgrp
      "cm" 'dired-do-chmod
      "co" 'dired-do-chown

      ;; filesystem
      "fg" 'dired-do-find-regexp             ;; grep marked files
      "fs" 'dired-do-find-regexp-and-replace ;; substitute
      "fi" 'dired-info
      "fm" 'dired-man
      "fr" 'dired-do-run-mail
      "ft" 'dored-do-touch
      "fz" 'epa-dired-do-encrypt
      "fZ" 'epa-dired-do-encrypt-to ;; compress as

      ;; EasyPG/GPG
      "fpd" 'epa-dired-do-decrypt
      "fpe" 'epa-dired-do-encrypt
      "fps" 'epa-dired-do-sign
      "fpv" 'epa-dired-do-verify

      ;; operations bound to regexp search
      "f/c"    'dired-do-copy-regexp
      "f/r"    'dired-do-rename-regexp
      "f/h"    'dired-do-hardlink-regexp
      "f/s"    'dired-do-symlink-regexp
      "f/|"    'dired-do-symlink-regexp
      "f/ C-|" 'dired-do-relsymlink-regexp
      "f/ M-|" 'dired-do-hardlink-regexp)

    (let ((erase-bindings '("#" "$" "%" "*" "." ":" "?" "~" "<" "=" ">" "a" "A" "B"
                            "c" "C-M-d" "C-M-n" "C-M-p" "C-M-u" "C-o" "e" "f" "F"
                            "g" "G" "h" "H" "I" "j" "k" "l" "L" "M" "M-$" "M-(" "M-{"
                            "M-}" "M-DEL" "M-G" "n" "N" "O" "p" "P" "Q" "s" "SPC" "0"
                            "S-SPC" "t" "T" "v" "V" "w" "W" "X" "y" "Y" "Z" "u")))
      (dolist (binding erase-bindings)
        (define-key dired-mode-map (kbd binding) nil))))

  (use-package image-dired
    :defer t
    :config
    ;;; fixed weird moves line, not thumbnail
    (defun image-dired-slideshow-step ()
      "Step to next file, if `image-dired-slideshow-times' has not been reached."
      (if (< image-dired-slideshow-count image-dired-slideshow-times)
          (progn
            (message "%s" (1+ image-dired-slideshow-count))
            (setq image-dired-slideshow-count (1+ image-dired-slideshow-count))
            (image-dired-display-next-thumbnail-original))
        (image-dired-slideshow-stop)))

    (general-define-key
      :keymaps 'image-dired-thumbnail-mode-map
      :states '(normal visual)
      "q" nil

      "h" 'image-dired-backward-image
      "j" 'image-dired-next-line
      "k" 'image-dired-previous-line
      "l" 'image-dired-forward-image
      "<left>"  'image-dired-forward-image
      "<right>" 'image-dired-previous-image


      "x" 'image-dired-delete-char
      "m" 'image-dired-mark-thumb-original-file
      "u" 'image-dired-unmark-thumb-original-file
      "c" 'image-dired-comment-thumbnail
      "d" 'image-dired-flag-thumb-original-file
      "D" 'image-dired-thumbnail-set-image-description
      "s" 'image-dired-slideshow-start
      "t" 'image-dired-toggle-mark-thumb-original-file
      "gr" 'image-dired-refresh-thumb
      "gc" 'image-dired-create-thumbs
      "gg" #'(lambda () (interactive) (evil-goto-first-line) (evil-beginning-of-line))
      "G"  #'(lambda () (interactive) (end-of-buffer) (image-dired-backward-image))

      "C-s" 'image-save           ; NOTE originally was bound to o

      "<C-SPC>"    'image-dired-mark-thumb-original-file
      "<M-SPC>"    'image-dired-unmark-thumb-original-file

      "<C-return>" 'image-dired-display-current-image-full
      "<RET>"      'image-dired-display-thumbnail-original-image
      "C-l"        'image-dired-display-next-thumbnail-original
      "C-h"        'image-dired-display-previous-thumbnail-original
      ;;; column view aliases
      "J" 'image-dired-display-next-thumbnail-original
      "K" 'image-dired-display-previous-thumbnail-original
      ;; "o" 'image-dired-display-thumbnail-original-image
      "v" 'image-dired-display-thumbnail-original-image

      "<mouse-1>" 'image-dired-mouse-select-thumbnail
      "<mouse-2>" 'image-dired-mouse-display-image)

    (mohkale/declare-prefix-for-mode* 'image-dired-thumbnail-mode
      "mt" '("tagging" . "tag/describe images")
      "me" '("edit"    . "edit images"))

    (mohkale/set-leader-keys-for-major-mode 'image-dired-thumbnail-mode
      "g" 'image-dired-jump-original-dired-buffer
      "m" 'image-dired

      "td" 'image-dired-thumbnail-set-image-description
      "tt"  'image-dired-tag-thumbnail
      "tT"  'image-dired-tag-thumbnail-remove

      "el" 'image-dired-rotate-thumbnail-left
      "eL" 'image-dired-rotate-original-left
      "er" 'image-dired-rotate-thumbnail-right
      "eR" 'image-dired-rotate-original-right

      "." 'image-dired-track-original-file
      "o" 'image-dired-thumbnail-display-external

      ;; [re]set number of columns per row
      "s" 'image-dired-line-up-interactive
      "S" 'image-dired-line-up-dynamic)

    ;;; image view
    (general-define-key
      :keymaps 'image-dired-display-image-mode-map
      :states 'normal
      "f" 'image-dired-display-current-image-full
      "F" 'image-dired-display-current-image-sized
      "s" 'image-dired-display-current-image-sized

      "h" 'image-scroll-right
      "l" 'image-scroll-left
      "k" 'image-scroll-down
      "j" 'image-scroll-up
      ;; horizontal line by line movement
      "C-d" 'image-scroll-up
      "C-u" 'image-scroll-down
      "C-e" 'image-next-line
      "C-y" 'image-previous-line
      ;; Arrow Keys Alias hjkl
      "<left>"  'image-backward-hscroll
      "<right>" 'image-forward-hscroll
      "<up>"    'image-scroll-down
      "<down>"  'image-scroll-up)

    (mohkale/set-leader-keys-for-major-mode 'image-dired-display-image-mode
      "h" 'image-bol ; far left   edge
      "j" 'image-eob ; far bottom edge
      "k" 'image-bob ; far top    edge
      "l" 'image-eol ; far right  edge
      "g" 'image-dired-jump-thumbnail-buffer))
#+end_src
*** drag-stuff
#+begin_src emacs-lisp
  (use-package drag-stuff
    :ensure t
    :defer  t
    :commands (drag-stuff-up
               drag-stuff-down)
    :init
    (general-define-key
      "C-<up>" 'drag-stuff-up
      "C-<down>" 'drag-stuff-down))
#+end_src
*** edbi
#+begin_src emacs-lisp
  ;; (use-package edbi
  ;;   :ensure t
  ;;   :defer  t

  ;;   )

  ;; DAMN YOU WINDOWS :P
#+end_src
*** edit-indirect
#+begin_src emacs-lisp
  (use-package edit-indirect
    :ensure t
    :defer  t
    :commands (edit-indirect-region
               edit-indirect-commit
               edit-indirect-save
               edit-indirect-abort)
    :config
    (mohkale/set-leader-keys-for-minor-mode 'edit-indirect--overlay
      (concat mohkale-major-mode-leader-prefix ",") 'edit-indirect-commit
      (concat mohkale-major-mode-leader-prefix "s") 'edit-indirect-save
      (concat mohkale-major-mode-leader-prefix "q") 'edit-indirect-abort))
#+end_src
*** electric
**** electric-pair
    electric pair is a built in module which lets auto insert matching pairs. For example, inserting a ( will lead to emacs auto inserting ).
#+begin_src emacs-lisp
  (use-package elec-pair
    :ensure t
    :hook ((text-mode prog-mode) . electric-pair-mode)
    :commands electric-pair-mode
    :config
    (setq electric-pair-preserve-balance nil)
    (setq electric-pair-skip-whitespace nil)
    (electric-pair-mode 1))
#+end_src
**** electric-indent
#+begin_src emacs-lisp
  (use-package electric
    :ensure t
    :defer  t
    :commands electric-indent-mode
    :hook ((text-mode prog-mode) . electric-indent-mode))
#+end_src
*** eyebrowse
#+begin_src emacs-lisp
  (use-package eyebrowse
    :ensure t
    :defer  t
    :commands (eyebrowse-create-window-config
               eyebrowse-close-window-config
               eyebrowse-last-window-config
               eyebrowse-rename-window-config
               eyebrowse-switch-to-window-config
               eyebrowse-switch-to-window-config-0
               eyebrowse-switch-to-window-config-1
               eyebrowse-switch-to-window-config-2
               eyebrowse-switch-to-window-config-3
               eyebrowse-switch-to-window-config-4
               eyebrowse-switch-to-window-config-5
               eyebrowse-switch-to-window-config-6
               eyebrowse-switch-to-window-config-7
               eyebrowse-switch-to-window-config-8
               eyebrowse-switch-to-window-config-9
               eyebrowse-prev-window-config
               eyebrowse-next-window-config
               eyebrowse-create-window-config)
    :config
    (eyebrowse-mode +1))

#+end_src
*** flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :defer  t
    ;; :delight " ⓢ"
    :delight "FlyCheck"
    :commands (flycheck-clear
               flycheck-explain-error-at-point
               flycheck-describe-checker
               goto-flycheck-error-list
               flycheck-list-errors
               flycheck-set-checker-executable
               flycheck-select-checker
               flycheck-verify-setup)
    :init
    (mohkale/set-leader-keys
      "ec" 'flycheck-clear
      "ee" 'flycheck-explain-error-at-point
      "eh" 'flycheck-describe-checker
      "eL" 'goto-flycheck-error-list
      "el" 'flycheck-list-errors
      "eS" 'flycheck-set-checker-executable
      "es" 'flycheck-select-checker
      "ev" 'flycheck-verify-setup)
    (setq flycheck-python-pycompile-executable "python3")

    :config
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))

    ;; update fringe for flycheck
    ;; src: https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bcheckers/syntax-checking/packages.el
    (define-fringe-bitmap 'mohkale-flycheck-fringe-indicator
      (vector #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00011100
              #b00111110
              #b00111110
              #b00111110
              #b00011100
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000))

    (let ((bitmap 'mohkale-flycheck-fringe-indicator))
      (flycheck-define-error-level 'error
        :severity 2
        :overlay-category 'flycheck-error-overlay
        :fringe-bitmap bitmap
        :fringe-face 'flycheck-fringe-error)
      (flycheck-define-error-level 'warning
        :severity 1
        :overlay-category 'flycheck-warning-overlay
        :fringe-bitmap bitmap
        :fringe-face 'flycheck-fringe-warning)
      (flycheck-define-error-level 'info
        :severity 0
        :overlay-category 'flycheck-info-overlay
        :fringe-bitmap bitmap
        :fringe-face 'flycheck-fringe-info)))

  (use-package flycheck-pos-tip
    :ensure t
    :defer  t
    :hook (flycheck-mode-hook . flycheck-pos-tip-mode)
    :commands flycheck-pos-tip-mode)
#+end_src
*** font-lock-studio
#+begin_src emacs-lisp
  (use-package font-lock-studio
    :ensure t
    :defer  t
    :commands font-lock-studio)
#+end_src
*** frog-jump-buffer
#+begin_src emacs-lisp
  (use-package frog-jump-buffer
    :ensure t
    :defer  t
    :commands frog-jump-buffer
    :init
    (mohkale/set-leader-keys
      "jb" 'frog-jump-buffer))
#+end_src
*** help
#+begin_src emacs-lisp
  (use-package help
    :config
    ;; once was enough, stop repeating the same message please :P
    (advice-add 'help-window-display-message :around #'ignore))
#+end_src
*** help-fns+
#+begin_src emacs-lisp
  (use-package help-fns+
    :defer t
    :commands (describe-buffer
               describe-keymap
               describe-mode
               describe-function)
    :init
    (mohkale/declare-prefix "hdm" "describe-mode")
    (mohkale/set-leader-keys
      "hdm" 'describe-buffer
      "hdf" 'describe-function
      "hdK" 'describe-keymap))
#+end_src
*** hide-comnt
    toggles the display of comments in the current buffer.
#+begin_src emacs-lisp
  (use-package hide-comnt
    :ensure nil
    :defer  t
    :commands hide/show-comments-toggle
    :init
    (mohkale/set-leader-keys
      "th" 'hide/show-comments-toggle))
#+end_src
*** hl-line
#+begin_src emacs-lisp
  (use-package hl-line
    :ensure t
    :defer  t
    :commands (hl-line-mode
               global-hl-line-mode)
    :hook ((text-mode prog-mode) . hl-line-mode))
#+end_src
*** hl-todo
#+begin_src emacs-lisp
  (use-package hl-todo
    :ensure t
    :defer  t
    :hook ((text-mode prog-mode) . global-hl-todo-mode)
    :commands (hl-todo-mode
               global-hl-todo-mode
               hl-todo-next
               hl-todo-previous
               hl-todo-occur
               hl-todo-insert
               hl-todo-insert-keyword)
    :init
    (mohkale/set-leader-keys
      "jt" 'hl-todo-next
      "jT" 'hl-todo-previous
      "et" 'hl-todo-occur

      "it" 'hl-todo-insert
      "it" 'hl-todo-insert-keyword))
#+end_src
*** ivy
**** ivy
#+begin_src emacs-lisp
  (use-package ivy
    :ensure t
    :defer nil
    :config
    (ivy-mode +1)
    (setq ivy-height 15
          counsel-evil-registers-height 15
          ivy-use-virtual-buffers t
          projectile-completion-system 'ivy
          ivy-initial-inputs-alist '((counsel-minor . "^+")
                                     (counsel-package . "^+")
                                     ;; (org-refile . "^")
                                     (org-agenda-refile . "^")
                                     (org-capture-refile . "^")
                                     ;; (counsel-M-x . "^")
                                     ;; (counsel-describe-function . "^")
                                     ;; (counsel-describe-variable . "^")
                                     ;; (counsel-org-capture . "^")
                                     ;; (org-refile . "^")
                                     ;; (org-agenda-refile . "^")
                                     ;; (org-capture-refile . "^")
                                     (Man-completion-table . "^")
                                     (woman . "^")))

    (defun ivy-kill-line-backward ()
      (interactive)
      (delete-region (minibuffer-prompt-end) (point)))

    (defun ivy-forward-char-or-partial-or-done ()
      "move forward a character or complete selection
  completes selection when there's no characters left to
  move forward."
      (interactive)
      (call-interactively (if (eolp)
                              'ivy-alt-done
                            'forward-char)))

    (defun persp-ivy-switch-buffer ()
      "restrict buffers for switch-buffer to current persp"
      (interactive)
      (with-persp-buffer-list ()
        (ivy-switch-buffer)))

    (general-define-key
      "M-x" 'counsel-M-x)

    (general-define-key
      :keymaps 'counsel-find-file-map
      ;; :predicate '(eq (point)
      ;;                 (minibuffer-prompt-end))
      "C-h" 'counsel-up-directory)

    (mohkale/set-leader-keys
      "bb" 'ivy-switch-buffer
      "SPC" 'counsel-M-x
      "M-SPC" 'ivy-resume)

    (mohkale/set-leader-keys-for-minor-mode 'persp-mode
      "bb" 'persp-ivy-switch-buffer)
    :bind* (:map ivy-minibuffer-map
            ("C-j" . nil) ;; was ivy-alt-done
            ("C-." . nil) ;; was hydra-ivy/body
            ("M-j" . nil) ;; was ivy-yank-word
            ("M-v" . nil) ;; was ivy-scroll-down-command
            ("C-v" . nil) ;; was ivy-scroll-up-command
            ("C-'" . nil) ;; was ivy-avy

            ("<return>" . ivy-alt-done) ;; also supports tramp expansion

            ;;; misc
            ("C-?" . describe-mode)
            ("M-d" . kill-ring-save) ;; save all candidates to kill ring
            ;; erase input, but start filtering from current candidates
            ("S-SPC" . ivy-restrict-to-matches) ; also bound to M-SPC

            ;;; selection execution
            ;; exit with current input, not selection
            ("C-c <return>" . ivy-immeadiate-done)
            ;; prompt for action, then done
            ("C-<return>" . ivy-dispatching-done)
            ;; invoke default action. but exit the minibuffer
            ("M-<return>" . ivy-call)
            ;; prompt for action, then call
            ("C-M-<return>" . ivy-dispatching-call)
            ;; move down, then call default action
            ("C-M-j" . ivy-next-line-and-call)
            ;; move down, then call default action
            ("C-M-k" . ivy-previous-line-and-call)
            ("<escape>" . minibuffer-keyboard-quit)

            ;;; movement commands
            ("C-h" . backward-char)
            ("C-l" . ivy-forward-char-or-partial-or-done)
            ("C-j" . next-line)
            ("C-k" . previous-line)
            ("C-q" . ivy-avy)
            ;; arrow key variants
            ("<left>"  . backward-char)
            ("<right>" . forward-char)
            ("<up>"    . previous-line)
            ("<down>"  . next-line)
            ;; suprisingly enough, these are bound correctly
            ("C-d" . scroll-up-command)
            ("C-u" . scroll-down-command)
            ;; taken from helm, shadows C-o hydra-ivy/body
            ("M-o" . beginning-of-buffer)
            ("C-o" . end-of-buffer)

            ;;; insertion/deletion
            ;; complete current selection into minibuffer
            ;; leave prompt active to build on it.
            ("C-i" . ivy-insert-current)
            ("C-<backspace>" . backward-kill-word)
            ;; pull word in from point at buffer
            ("M-w" . ivy-yank-word)
            ("C-w" . kill-word)
            ;; operate on entire input
            ("M-k" . ivy-kill-line-backward)
            ("M-K" . kill-line) ;; kill forward
            ("C-M-k" . kill-whole-line)

            ;;; history - (C-r/C-s still work fine)
            ("<S-up>"    . ivy-previous-history-element)
            ("<S-down>"  . ivy-next-history-element)

            :map ivy-switch-buffer-map
            ("C-k" . previous-line)
            ("M-d" . ivy-switch-buffer-kill)))
#+end_src
**** ivy-hydra
#+begin_src emacs-lisp
  (use-package ivy-hydra
    :ensure t
    :defer  t
    :commands hydra-ivy/body
    :bind* (:map ivy-minibuffer-map
            ("C-." . hydra-ivy/body)))
#+end_src
**** counsel
#+begin_src emacs-lisp
  (use-package counsel
    :ensure t
    :defer  t
    :after  ivy
    :diminish
    :commands (counsel-M-x
               counsel-descbinds
               counsel-describe-function
               counsel-describe-variable
               counsel-apropos
               counsel-describe-face
               counsel-faces
               counsel-find-file
               counsel-find-library
               counsel-imenu
               counsel-load-library
               counsel-load-theme
               counsel-yank-pop
               counsel-mark-ring
               counsel-bookmark
               counsel-company
               counsel-compile
               ;; counsel-dired ;; same as find-file
               counsel-dired-jump
               counsel-evil-registers
               counsel-file-jump
               counsel-file-registers
               counsel-fzf
               ;; counsel-git...
               counsel-git
               counsel-git-change-work-tree
               counsel-git-checkout
               counsel-git-grep
               counsel-git-grep-query-replace
               counsel-git-grep-switch-cmd
               counsel-git-log
               counsel-git-stash
               counsel-jedi
               counsel-list-processes
               counsel-outline
               counsel-register
               counsel-grep...
               counsel-pt ;; WARN doesn't work
               counsel-rg
               counsel-ag
               counsel-wmctrl
               counsel-locate
               counsel-unicode-char
               counsel-info-lookup-symbol
               counsel-recentf
               counsel-mode)
    :init
    (setq counsel-find-file-occur-use-find t)

    (defalias 'describe-bindings 'counsel-descbinds)
    (mohkale/declare-prefix*
      "r" "registers/rings/resume"
      "fs" "recursive-find")

    (mohkale/set-leader-keys-for-major-mode 'org-mode
      "gg" 'counsel-org-goto
      "gG" 'counsel-org-goto-all)

    (mohkale/set-leader-keys
      "ic" 'counsel-unicode-char
      "ie" 'counsel-org-entity
      "ww" 'counsel-wmctrl
      "Mm" 'counsel-major
      "MM" 'counsel-major

      "?"  'counsel-appropos
      "oO" 'counsel-org-capture
      "ooh" 'counsel-org-agenda-headlines
      "ry" 'counsel-yank-pop
      "rm" 'counsel-mark-ring
      "rr" 'counsel-register
      "re" 'counsel-evil-registers
      "rf" 'counsel-file-registers
      "al" 'counsel-load-library
      "bO" 'counsel-outline

      "ff" 'counsel-find-file
      "fb" 'counsel-bookmark
      "fr" 'counsel-recentf
      "fsf" 'counsel-file-jump
      "fsd" 'counsel-dired-jump

      "ci" 'counsel-compile

      "sb" 'counsel-grep
      ;; recursive searches
      "sv" 'counsel-git-grep
      "sp" 'counsel-pt
      "sa" 'counsel-ag
      "sr" 'counsel-ag

      ;; "bb" 'counsel-buffer-or-recentf ;; WARN only file buffers
      "bb" 'counsel-switch-buffer
      "hdf" 'counsel-describe-function
      "hdv" 'counsel-describe-variable)

    (general-define-key
      "C-M-y" 'counsel-yank-pop)
    :config
    (counsel-mode +1)
    (push (cons 'counsel-evil-registers ivy-height) ivy-height-alist)

    :bind* (:map company-mode-map
            ("C-:" . counsel-company)))
#+end_src
**** swiper
#+begin_src emacs-lisp
  (use-package swiper
    :ensure t
    :defer  t
    :commands (swiper-query-replace
               swiper-all-query-replace
               swiper-avy
               ;; swiper-mc
               swiper-recenter-top-bottom
               swiper
               swiper-backward
               swiper-thing-at-point
               swiper-all-thing-at-point
               swiper-toggle-face-matching
               swiper-from-isearch
               swiper-multi
               swiper-all
               swiper-isearch-thing-at-point
               swiper-isearch
               swiper-isearch-backward
               swiper-isearch-toggle)
    :init
    (mohkale/set-leader-keys
      "ss" 'swiper))
#+end_src
**** ivy-yasnippet
#+begin_src emacs-lisp
  (use-package ivy-yasnippet
    :ensure t
    :defer  t
    :commands ivy-yasnippet
    :init
    (mohkale/set-leader-keys
        "is" 'ivy-yasnippet)
    (general-define-key
      :states 'insert
      "C-M-i" 'ivy-yasnippet))
#+end_src
**** counsel-pydoc
#+begin_src emacs-lisp
  (use-package counsel-pydoc
    :ensure t
    :defer  t
    :commands counsel-pydoc
    :init
    (mohkale/set-leader-keys-for-major-mode 'python-mode
      "hd" 'counsel-pydoc))
#+end_src
**** counsel-ggtags
#+begin_src emacs-lisp
  (use-package counsel-gtags
    :ensure t
    :defer  t
    :commands (counsel-gtags-find-definition
               counsel-gtags-find-reference
               counsel-gtags-find-symbol
               counsel-gtags-find-file
               counsel-gtags-go-backward
               counsel-gtags-go-forward
               counsel-gtags-create-tags
               counsel-gtags-update-tags
               counsel-gtags-dwim)
    :init
    (mohkale/set-leader-keys
      "Tg" 'counsel-gtags-find-definition
      "TG" 'counsel-gtags-find-reference
      "Ts" 'counsel-gtags-find-symbol
      "Tf" 'counsel-gtags-find-file
      "Tn" 'counsel-gtags-go-forward
      "TN" 'counsel-gtags-go-backward
      "Tc" 'counsel-gtags-create-tags
      "Tu" 'counsel-gtags-update-tags
      "TT" 'counsel-gtags-dwim))
#+end_src
**** helm-make
#+begin_src emacs-lisp
  (use-package helm-make
    :ensure t
    :defer  t
    :commands (helm-make
               helm-make-projectile)
    :init
    (setq helm-make-completion-method 'ivy)
    (mohkale/set-leader-keys
      "cc" 'helm-make-projectile
      "cm" 'helm-make))
#+end_src
**** flx
optimizes ivy search ordering for fuzzy searches.
#+begin_src emacs-lisp
  (use-package flx
    :ensure t
    :defer  t)
#+end_src
**** smex
show recently accessed commands at the top of M-x.
#+begin_src emacs-lisp
  (use-package smex
    :ensure t
    :defer  t)
#+end_src
*** htmlize
#+begin_src emacs-lisp
  (use-package htmlize
    :ensure t
    :defer  t)
#+end_src
*** imenu
#+begin_src emacs-lisp
  (use-package imenu
    :defer t
    :commands imenu
    :init
    (mohkale/set-leader-keys
      "ji" 'imenu))

  (use-package imenu-list
    :ensure t
    :defer  t
    :commands imenu-list
    :init
    (mohkale/set-leader-keys
      "Mi" 'imenu-list))
      "MI" 'imenu

  (use-package imenu-anywhere
    :ensure t
    :defer  t
    :commands imenu-anywhere
    :init
    (mohkale/set-leader-keys
      "jI" 'imenu-anywhere))
#+end_src
*** isearch
    prefer evil search over isearch
# #+begin_src emacs-lisp
# (use-package isearch
#   ;; TODO look into more bindings
#   :bind (:map isearch-mode-map
#          ("DEL" . isearch-delete-char)))
#
# #+end_src
*** lorem-ipsum
#+begin_src emacs-lisp
  (use-package lorem-ipsum
    :ensure nil
    :defer  t
    :commands (Lorem-ipsum-insert-list
               Lorem-ipsum-insert-paragraphs
               Lorem-ipsum-insert-sentences)
    :init
    (mohkale/declare-prefix "il" "lorem-ipsum")

    (mohkale/set-leader-keys
      "ill" 'Lorem-ipsum-insert-list
      "ilp" 'Lorem-ipsum-insert-paragraphs
      "ils" 'Lorem-ipsum-insert-sentences))
#+end_src
*** language-server
**** lsp-mode
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :defer  t
    :commands (lsp lsp-deferred lsp-mode)
    :config
    (push 'company-lsp company-backends)
    (setq lsp-enable-snippet nil)

    (mohkale/declare-prefix-for-mode* 'lsp-mode
      "yw" "workspaces"
      "yl" "lens"
      "yr" "refactor"
      "yg" "goto")

    (mohkale/set-leader-keys-for-minor-mode 'lsp-mode
      "y?" 'lsp-describe-session
      "y|" 'lsp-describe-thing-at-point
      "ye" 'lsp-execute-code-action
      "yh" 'lsp-document-highlight
      "ywR" 'lsp-restart-workspace
      "ywa" 'lsp-workspace-folders-add
      "ywr" 'lsp-workspace-folders-remove
      "yws" 'lsp-workspace-folders-switch
      "y <backspace>" 'lsp-disconnect

      "yll" 'lsp-lens-mode
      "yls" 'lsp-lens-show
      "ylh" 'lsp-lens-hide

      "yrr" 'lsp-format-buffer
      "yri" 'lsp-organize-imports
      "yrc" 'lsp-rename

      "ygg" 'lsp-goto-type-definition
      "ygG" 'lsp-goto-implementation
      "ygF" 'lsp-find-implementation
      "ygf" 'lsp-find-type-definition))
#+end_src
**** lsp-ui
#+begin_src emacs-lisp
  (use-package lsp-ui
    :ensure t
    :defer  t
    ;; :hook (lsp-mode-hook . lsp-ui-mode)
    :commands (lsp-ui-mode)
    :init
    ;; only really installed for flycheck support
    (setq lsp-prefer-flymake nil
          lsp-ui-sideline-enable nil
          lsp-ui-doc-enable nil)
    :config
    (mohkale/declare-prefix-for-mode 'lsp-mode
      "yp" "peek")
    (mohkale/set-leader-keys-for-minor-mode 'lsp-mode
      "pg" 'lsp-ui-peek-find-definitions
      "pG" 'lsp-ui-peek-find-definitions))
#+end_src
**** company-lsp
#+begin_src emacs-lisp
  (use-package company-lsp
    :ensure t
    :defer  t
    :commands company-lsp
    :config
    ;; reduces write lag
    (setq company-lsp-cache-candidates t))
#+end_src

**** server-installation-utils
:PROPERTIES:
:header-args+: :tangle no
:END:
usefull methods & variables to assist in the installation of scripts.

#+NAME: server-install-path
#+begin_src emacs-lisp :results value
  (expand-file-name "~/.emacs.d/var/lsp/servers")
#+end_src

#+NAME: set_shell_banner
#+begin_src emacs-lisp :var varname="BANNER" text="" width=80 char="@" :results value
  (let* ((text-width (length text))
         (width (max width
                     (+ 4 text-width)))
         (header-string (make-string width
                                     (string-to-char char)))
         (pad-width (/ (- width 4 text-width)
                       2))
         (pad-string (make-string pad-width ? ))

         (banner (concat "\n"
                         char
                         " "
                         (unless (zerop (% text-width 2))
                           " ")
                         pad-string
                         text
                         pad-string
                         " "
                         char
                         "\n")))
    (format "%s='\n%s\n'"
            varname
            (concat header-string
                    banner
                    header-string)))
#+end_src

**** server-installation-scripts
***** kotlin-language-server
:PROPERTIES:
:header-args+: :tangle ~/.emacs.d/bin/install/kotlin-language-server.sh
:END:

#+begin_src bash :shebang #!/usr/bin/bash
  <<set_shell_banner(varname="INSTALLATION_ALREADY_DONE_BANNER",text="kotlin language server already installed",char="#")>>
  <<set_shell_banner(varname="CLONING_LANGUAGE_SERVER_BANNER",text="cloning fwcd/kotlin-language-server",char="#")>>
  <<set_shell_banner(varname="CLONING_FAILED_BANNER",text="failed to clone repository, program terminated",char="*")>>
  <<set_shell_banner(varname="CLONING_ALREADY_DONE_BANNER",text="fwcd/kotlin-language-server already cloned",char="#")>>
  <<set_shell_banner(varname="RUNNING_GRADLE_BUILD_BANNER",text="running gradle build process",char="#")>>
  <<set_shell_banner(varname="GRADLE_BUILD_FAILED_BANNER",text="failed to build kotlin language server",char="*")>>
  <<set_shell_banner(varname="FINISHED_BANNER",text="finished installing the kotlin language server",char="*")>>

  DEST_PATH="<<server-install-path()>>/kotlin"
#+end_src

#+begin_src bash
  if [ -f "${DEST_PATH}/bin/kotlin-language-server" ]; then
      echo "${INSTALLATION_ALREADY_DONE_BANNER}"
  else
      mkdir -p "${DEST_PATH}"
      pushd "${DEST_PATH}"

      CLONE_PATH="./.server"
      if [ ! -d "${CLONE_PATH}/.git" ]; then
          echo "${CLONING_LANGUAGE_SERVER_BANNER}"

          if ! git clone "https://github.com/fwcd/kotlin-language-server" "${CLONE_PATH}"; then
              echo "${CLONING_FAILED_BANNER}"
              exit 1
          fi
      else
          echo "${CLONING_ALREADY_DONE_BANNER}"
      fi

      echo "${RUNNING_GRADLE_BUILD_BANNER}"

      pushd "${CLONE_PATH}"
      if ! ./gradlew :server:installDist; then
          echo "${GRADLE_BUILD_FAILED_BANNER}"
          exit 2
      fi
      popd

      mv ${CLONE_PATH}/server/build/install/server/* ./
      rm -rf "${CLONE_PATH}"
      echo "${FINISHED_BANNER}"
  fi
#+end_src
***** kotlin-debug-adapter
:PROPERTIES:
:header-args+: :tangle ~/.emacs.d/bin/install/kotlin-debug-adapter.sh
:END:

#+begin_src bash :shebang #!/usr/bin/bash
  <<set_shell_banner(varname="INSTALLATION_ALREADY_DONE_BANNER",text="kotlin debug adapter already installed",char="#")>>
  <<set_shell_banner(varname="CLONING_DEBUG_ADAPTER_BANNER",text="cloning fwcd/kotlin-debug-adapter",char="#")>>
  <<set_shell_banner(varname="CLONING_FAILED_BANNER",text="failed to clone repository, program terminated",char="*")>>
  <<set_shell_banner(varname="CLONING_ALREADY_DONE_BANNER",text="fwcd/kotlin-debug-adapter already cloned",char="#")>>
  <<set_shell_banner(varname="RUNNING_GRADLE_BUILD_BANNER",text="running gradle build process",char="#")>>
  <<set_shell_banner(varname="GRADLE_BUILD_FAILED_BANNER",text="failed to build kotlin debug adapter",char="*")>>
  <<set_shell_banner(varname="INISHED_BANNER",text="finished installing the kotlin debug adapter",char="*")>>

  DEST_PATH="<<server-install-path()>>/kotlin/debugger"
#+end_src

#+begin_src bash
  if [ -f "${DEST_PATH}/bin/kotlin-debug-adapter" ]; then
      echo "${INSTALLATION_ALREADY_DONE_BANNER}"
  else
      mkdir -p "${DEST_PATH}"
      pushd "${DEST_PATH}"

      CLONE_PATH="./.debugger"
      if [ ! -d "${CLONE_PATH}/.git" ]; then
          echo "${CLONING_DEBUG_ADAPTER_BANNER}"

          if ! git clone "https://github.com/fwcd/kotlin-debug-adapter" "${CLONE_PATH}"; then
              echo "${CLONING_FAILED_BANNER}"
              exit 1
          fi
      else
          echo "${CLONING_ALREADY_DONE_BANNER}"
      fi

      echo "${RUNNING_GRADLE_BUILD_BANNER}"

      pushd "${CLONE_PATH}"
      if ! ./gradlew :adapter:installDist; then
          echo "${GRADLE_BUILD_FAILED_BANNER}"
          exit 2
      fi
      popd

      mv ${CLONE_PATH}/adapter/build/install/adapter/* ./
      rm -rf "${CLONE_PATH}"
      echo "${FINISHED_BANNER}"
  fi
#+end_src

***** haskell-ide-engine
:PROPERTIES:
:header-args+: :tangle ~/.emacs.d/bin/install/haskell-ide-engine.sh
:END:

if your install fails with exit code 251, you're computer ran out of memory during the install process. Simply close all running programs and try again. Warning: install can take upto an hour and over 3 GB of RAM.

#+begin_src bash :shebang #!/usr/bin/bash
  <<set_shell_banner(varname="INSTALLATION_ALREADY_DONE_BANNER",text="haskell IDE engine already installed",char="#")>>
  <<set_shell_banner(varname="CLONING_LANGUAGE_SERVER_BANNER",text="cloning haskell/haskell-ide-engine",char="#")>>
  <<set_shell_banner(varname="CLONING_FAILED_BANNER",text="failed to clone repository, program terminated",char="*")>>
  <<set_shell_banner(varname="CLONING_ALREADY_DONE_BANNER",text="haskell/haskell-ide-engine already cloned",char="#")>>
  <<set_shell_banner(varname="RUNNING_CABAL_INSTALL_BANNER",text="running cabal installer, you may wish to free some RAM",char="#")>>
  <<set_shell_banner(varname="CABAL_INSTALL_FAILED_BANNER",text="failed to build haskell IDE engine",char="*")>>
  <<set_shell_banner(varname="FAILED_TO_MOVE_AFTER_INSTALL_BANNER",text="could not find stack install directory for server move",char="*")>>
  <<set_shell_banner(varname="FINISHED_BANNER",text="finished installing the haskell IDE engine",char="*")>>

  DEST_PATH="<<server-install-path()>>/haskell"
#+end_src

#+begin_src bash
  BUILD_TARGET="stack-hie-8.6.5"

  if [ -f "${DEST_PATH}/hie.exe" -o -f "${DEST_PATH}/hie" ]; then
      echo "${INSTALLATION_ALREADY_DONE_BANNER}"
  else
      mkdir -p "${DEST_PATH}"
      pushd "${DEST_PATH}"

      CLONE_PATH="./.hie"
      if [ ! -d "${CLONE_PATH}/.git" ]; then
          echo "${CLONING_LANGUAGE_SERVER_BANNER}"

          if ! git clone "https://github.com/haskell/haskell-ide-engine" "${CLONE_PATH}" --recurse-submodules; then
              echo "${CLONING_FAILED_BANNER}"
              exit 1
          fi
      else
          echo "${CLONING_ALREADY_DONE_BANNER}"
      fi

      echo "${RUNNING_CABAL_INSTALL_BANNER}"

      pushd "${CLONE_PATH}"
      if ! cabal v2-run ./install.hs --project-file install/shake.project -j1 --ghc-options="+RTS -M600M" "${BUILD_TARGET}"; then
          echo "${CABAL_INSTALL_FAILED_BANNER}"
          exit 2
      fi
      popd

      INSTALL_PATH="$(stack path --local-bin)"
      if [ $? -eq 0 ]; then
          find "${INSTALL_PATH}/" -maxdepth 1 -iname 'hie*' -print0 | xargs -0 -i% mv % ./
          rm -rf "${CLONE_PATH}"
          echo "${FINISHED_BANNER}"
      else
          echo "${FAILED_TO_MOVE_AFTER_INSTALL_BANNER}"
      fi
  fi
#+end_src

*** magit
#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :defer  t
  :commands (evil-search-previous
             evil-search-next
             magit-push
             magit-section-forward-sibling
             magit-section-backward-sibling
             magit-section-forward-sibling
             magit-section-backward-sibling
             magit-section-hide-children
             magit-section-show-children
             magit-section-hide-children
             magit-section-show-children
             magit-section-toggle
             magit-section-toggle
             magit-visit-thing
             magit-visit-thing)
  :bind* (:map magit-mode-map
          ("p" . evil-search-previous)
          ("n" . evil-search-next)
          ("P" . magit-push)
          ;; "C-j" magit-section-forward-sibling
          ;; "C-k" magit-section-backward-sibling
          ("M-j" . magit-section-forward-sibling)
          ("M-k" . magit-section-backward-sibling)
          ;; toggle children doesn't seem to work
          ("C-r" . magit-section-hide-children) ; recursive close
          ("C-e" . magit-section-show-children) ; recursive expand
          ("M-r" . magit-section-hide-children) ; Meta aliases
          ("M-e" . magit-section-show-children) ; Meta aliases
          ;; visit and expand
          ("RET"   . magit-section-toggle)
          ("TAB"   . magit-section-toggle)
          ("M-RET" . magit-visit-thing)

          :map magit-log-mode-map
          ("RET" . magit-visit-thing)))
#+end_src
*** minibuffer
#+begin_src emacs-lisp
  (bind-keys :map minibuffer-local-map
             ("C-j" . next-history-element)
             ("C-k" . previous-history-element)
             ("C-h" . previous-matching-history-element)
             ("C-l" . next-matching-history-element)

             ("C-w" . backward-kill-word)
             ("C-?" . minibuffer-completion-help)
             ;; for some reason.. I can't bind Meta keys
             ("M-k" . backward-kill-sentence)
             ;; ("M-n" . nil)
             ;; ("M-p" . nil)
             ;; ("M-r" . nil)
             ("<escape>" . abort-recursive-edit)
             )

  (bind-keys :map minibuffer-local-must-match-map
             ("<escape>" . abort-recursive-edit)
             ("C-j" . nil)
             ("TAB" . minibuffer-complete)
             ("C-<tab>" . minibuffer-complete-and-exit))

  (bind-keys :map minibuffer-inactive-mode-map
             ("<escape>" . abort-recursive-edit))

  (bind-keys :map minibuffer-local-ns-map
             ("<escape>" . abort-recursive-edit))

  (bind-keys :map minibuffer-local-completion-map
             ("<escape>" . abort-recursive-edit))
#+end_src
*** occur
#+begin_src emacs-lisp
  (use-package occur
    :defer t
    :config
    (evil-set-initial-state 'occur-mode 'normal)
    (general-define-key
      :states 'normal
      :keymaps 'occur-mode-map
      ;; occur-mode-mouse-goto
      "<return>" 'occur-mode-goto-occurrence
      "o" 'occur-mode-goto-occurrence
      "O" 'occur-mode-goto-occurrence-other-window
      "s" 'occur-mode-display-occurrence ;; jump in other buffer

      "C-j" 'occur-next
      "C-k" 'occur-prev
      "n" 'occur-next
      "N" 'occur-prev
      "e" 'occur-edit-mode

      "i" 'ignore
      "a" 'ignore
      "A" 'ignore
      "s" 'ignore

      "R" 'occur-rename-buffer
      "q" 'quit-window)

    (evil-set-initial-state 'occur-edit-mode 'normal)
    (general-define-key
      :states 'normal
      :keymaps 'occur-edit-mode-map
      ;; occur-mode-mouse-goto
      "C-o" 'occur-mode-goto-occurrence
      "M-o" 'occur-mode-goto-occurrence-other-window
      "n" 'occur-next
      "N" 'occur-prev

      "q" 'occur-cease-edit))
#+end_src
*** open-junk-file
#+begin_src emacs-lisp
  (use-package open-junk-file
    :defer t
    :commands open-junk-file
    :init
    (mohkale/set-leader-keys
      "fJ" 'open-junk-file))
#+end_src
*** page-break-lines
#+begin_src emacs-lisp
  (use-package page-break-lines
    :defer t
    :diminish)
#+end_src
*** paren
   TODO look into smart-parens-mode
#+begin_src emacs-lisp
  (use-package paren
    :ensure t
    :defer  t
    :commands show-paren-mode
    :hook ((text-mode prog-mode) . show-paren-mode)
    :init (setq sp-highlight-pair-overlay nil))
#+end_src
*** pcre2el
#+begin_src emacs-lisp
  (use-package pcre2el
    :ensure t
    :defer  t
    :commands (rxt-convert-to-strings
               rxt-explain
               rxt-convert-syntax
               rxt-toggle-elisp-rx
               rxt-convert-to-rx

               rxt-elisp-to-strings
               rxt-explain-elisp
               rxt-elisp-to-pcre
               rxt-toggle-elisp-rx
               rxt-elisp-to-rx

               rxt-pcre-to-strings
               rxt-explain-pcre
               rxt-pcre-to-elisp
               rxt-pcre-to-rx)
    :init
    (mohkale/declare-prefix*
      "x" "text"
      "xr" "regular expressions"
      "xre" "elisp"
      "xrp" "pcre")

    (mohkale/set-leader-keys
      "xr'"  'rxt-convert-to-strings
      "xr/"  'rxt-explain
      "xrc"  'rxt-convert-syntax
      "xrt"  'rxt-toggle-elisp-rx
      "xrx"  'rxt-convert-to-rx

      "xre'" 'rxt-elisp-to-strings
      "xre/" 'rxt-explain-elisp
      "xrep" 'rxt-elisp-to-pcre
      "xret" 'rxt-toggle-elisp-rx
      "xrex" 'rxt-elisp-to-rx

      "xrp'" 'rxt-pcre-to-strings
      "xrp/" 'rxt-explain-pcre
      "xrpe" 'rxt-pcre-to-elisp
      "xrpx" 'rxt-pcre-to-rx))
#+end_src
*** persp-mode
#+begin_src emacs-lisp
  (use-package persp-mode
    ;; unbound functions:
    ;;    persp-add-buffer
    ;;    persp-remove-buffer
    ;;    persp-kill-buffer
    ;;    persp-save-and-kill

    :ensure t
    :defer  t
    :diminish persp-mode
    ;; :after eyebrowse
    :commands (switch-to-persp-by-num
               persp-add-new
               persp-kill
               persp-add-buffer
               persp-remove-buffer
               persp-kill-buffer
               persp-switch-to-buffer
               persp-copy
               persp-rename
               persp-next
               persp-prev
               persp-temporarily-display-buffer
               persp-import-win-conf
               persp-import-buffers
               persp-window-switch
               persp-frame-switch
               persp-save-state-to-file
               persp-load-state-from-file
               persp-save-to-file-by-names
               persp-load-from-file-by-names
               persp-save-and-kill)
    :config
    (require 'eyebrowse)

    (mohkale/set-leader-keys-for-minor-mode 'persp-mode
      "ba" 'persp-add-current-buffer
      "bA" 'persp-add-buffer
      "br" 'persp-remove-buffer
      "bR" 'persp-remove-current-buffer)

    (persp-mode +1)
    (setq persp-autokill-buffer-on-remove 'kill-weak)

    (defun switch-to-persp-by-num (index)
      "switch to a perspective based on it's position in (persp-persps)
  the first position is assumed to be associated with a perspective name `none'.
  if a perspective at the given index doesn't exist, it's assumed you wish to
  create a new one, so you'll be prompted to do so at the largest available index."
      (let* ((persp-list (nreverse (persp-persps)))
             (persp-count (length persp-list)))
        ;; last value is nil persp with name none
        (if (>= index persp-count)
            (when (yes-or-no-p (format "no layout exists at %d, would you like to make a new layout:"
                                       index (1+ persp-count)))
              (call-interactively 'persp-add-new))
          (persp-switch (safe-persp-name (nth index persp-list))))))

    (defun mohkale//persp-add-after (&rest args)
      (let ((persp-list (nreverse (persp-persps))))
        (persp-switch (safe-persp-name (car (last persp-list))))
        (goto-home-buffer) ;; FIXME copy should keep current window config
        ))

    (advice-add 'persp-add-new :after #'mohkale//persp-add-after)

    (defun mohkale//persp-kill-wrapper (func &rest args)
      "function which wraps around persp-kill
  this function will ensure after a perspective is killed, the next
  perspective you reach will be the one immeadiately before the erased
  one. Not really necessary, but when you try to delete 3 perspectives
  in a row, this'll make things easier. Besides, this is what you expect
  to happen."
        (let* ((perspectives (nreverse (persp-persps)))
             (current-persp (get-current-persp))
             (current-index (cl-position current-persp perspectives))
             (next-persp (when (and current-index
                                    (not (zerop current-index)))
                           (nth (- current-index 1) perspectives))))
        (apply func args)
        (when next-persp
          (persp-switch (persp-name next-persp)))))

    (advice-add 'persp-kill :around #'mohkale//persp-kill-wrapper)

    (defun persp-kill-current ()
      "kill the current perspective"
      (interactive)
      (kill-persp (get-current-persp)))

    (defun spacemacs//layout-contains-buffer-p (buffer)
    "returns true if the given buffer is in the current layout"
    (not (spacemacs//layout-not-contains-buffer-p buffer)))

    (defun persp-add-current-buffer ()
      "adds current buffer to current perspective"
      (interactive)
      (persp-add-buffer (current-buffer)))

    (defun persp-remove-current-buffer ()
      "removes current buffer from current persp"
      (interactive)
      (persp-remove-buffer (current-buffer)))

    (defun persp-move-layout-left ()
      (interactive)
      ;; (let* ((current-persp (get-current-persp))
      ;;        (current-persp-num (progn
      ;;                             (let (value)
      ;;                               (dolist (persp)))))
      ;;        ))
      (message "not yet implemented") ;; TODO implement
      )

    (defun persp-move-layout-right ()
      (interactive)
      (message "not yet implemented") ;; TODO implement
      )

    ;; thank you spacemacs for giving us perspective mode with eyebrowse... ergo, layouts :)
    ;; https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bspacemacs/spacemacs-layouts/funcs.el
    ;; the following is just a lazy translation of the spacemacs implementation from above for my config.
    ;; some vocabulary notes:
    ;;   * a workspace is a list of eyebrowse window configurations
    ;;   * a layout is a perspective-mode perspective which has an associated workspace.
    ;; for further elaborations on what those terms mean, see the README for perspective-mode and eyebrowse.

    ;; XXXX TBH I don't really understand what most of this does, a lot of it I just copied and pasted from
    ;;      spacemacs and changed spacemacs to layouts... if spacemacs ever realeases this as a standalone
    ;;      package, like they did with spaceline, make sure to switch to that. In the meantime, the following
    ;;      uses the same license as spacemacs... I.E. GPL v3
    ;;      Reference Commit: b252d252b0e93249b51400f60a0c69a59aa140a4

    (defun layouts//get-persp-workspace (&optional persp frame)
      "Get the correct workspace parameters for perspective.
  PERSP is the perspective, and defaults to the current perspective.
  FRAME is the frame where the parameters are expected to be used, and
  defaults to the current frame."
      (let ((param-names (if (display-graphic-p frame)
                             '(gui-eyebrowse-window-configs
                               gui-eyebrowse-current-slot
                               gui-eyebrowse-last-slot)
                           '(term-eyebrowse-window-configs
                             term-eyebrowse-current-slot
                             term-eyebrowse-last-slot))))
        (--map (persp-parameter it persp) param-names)))

    (defun layouts//set-persp-workspace (workspace-params &optional persp frame)
      "Set workspace parameters for perspective.
  WORKSPACE-PARAMS should be a list containing 3 elements in this order:
  - window-configs, as returned by (eyebrowse--get 'window-configs)
  - current-slot, as returned by (eyebrowse--get 'current-slot)
  - last-slot, as returned by (eyebrowse--get 'last-slot)
  PERSP is the perspective, and defaults to the current perspective.
  FRAME is the frame where the parameters came from, and defaults to the
  current frame.
  Each perspective has two sets of workspace parameters: one set for
  graphical frames, and one set for terminal frames."
      (let ((param-names (if (display-graphic-p frame)
                             '(gui-eyebrowse-window-configs
                               gui-eyebrowse-current-slot
                               gui-eyebrowse-last-slot)
                           '(term-eyebrowse-window-configs
                             term-eyebrowse-current-slot
                             term-eyebrowse-last-slot))))
        (--zip-with (set-persp-parameter it other persp)
                    param-names workspace-params)))

    ;;  _                 _
    ;; | |__   ___   ___ | | _____
    ;; | '_ \ / _ \ / _ \| |/ / __|
    ;; | | | | (_) | (_) |   <\__ \
    ;; |_| |_|\___/ \___/|_|\_\___/
    ;;

    ;; spacemacs/save-eyebrowse-for-perspective
    (defun layouts//save-eyebrowse-for-perspective (&optional frame)
      "save FRAME's eyebrowse workspace to FRAME's perspective.
  FRAME defaults to the current frame."
      (layouts//set-persp-workspace (list (eyebrowse--get 'window-configs frame)
                                          (eyebrowse--get 'current-slot frame)
                                          (eyebrowse--get 'last-slot frame))
                                    (get-frame-persp frame)
                                    frame))

    (add-hook 'eyebrowse-post-window-switch-hook #'layouts//save-eyebrowse-for-perspective)

    ;; spacemacs/update-eyebrowse-for-perspective
    (defun layouts//update-eyebrowse-for-perspective (&rest _args)
      "update & save current frame's eyebrowse workspace to its perspective"
      (let* ((current-slot (eyebrowse--get 'current-slot))
             (current-tag (nth 2 (assoc current-slot (eyebrowse--get 'window-configs)))))
        (eyebrowse--update-window-config-element
         (eyebrowse--current-window-config current-slot current-tag)))
      (layouts//save-eyebrowse-for-perspective))

    (add-hook 'persp-before-switch-functions #'layouts//update-eyebrowse-for-perspective)
    (add-hook 'persp-before-save-state-to-file-functions #'layouts//update-eyebrowse-for-perspective)

    ;; spacemacs/load-eyebrowse-for-perspective
    (defun layouts//load-eyebrowse-for-perspective (type &optional frame)
      "load an eyebrowse workspace according to a perspective's parameters.
  FRAME's perspective is the perspective that is considered, defaulting to
  the current frame's perspective.
  If the perspective doesn't have a workspace, create one."
      (when (eq type 'frame)
        (let* ((workspace-params (layouts//get-persp-workspace (get-frame-persp frame) frame))
               (window-configs (nth 0 workspace-params))
               (current-slot (nth 1 workspace-params))
               (last-slot (nth 2 workspace-params)))
          (if window-configs
              (progn
                (eyebrowse--set 'window-configs window-configs frame)
                (eyebrowse--set 'current-slot current-slot frame)
                (eyebrowse--set 'last-slot last-slot frame)
                (eyebrowse--load-window-config current-slot))
            (eyebrowse--set 'window-configs nil frame)
            (eyebrowse-init frame)
            (layouts//save-eyebrowse-for-perspective frame)))))

    (add-hook 'persp-activated-functions #'layouts//load-eyebrowse-for-perspective)

    ;; spacemacs/load-eyebrowse-after-loading-layout
    (defun layouts//load-eyebrowse-after-perspective-load (_state-file _persp-hash _persp-names)
      "bridge between `persp-after-load-state-functions' and
  `layouts//load-eyebrowse-for-perspective'.
  _PHASH is the hash were the loaded perspectives were placed, and
  PERSP-NAMES are the names of these perspectives."
      (let ((cur-persp (get-current-persp)))
        ;; load eyebrowse for current perspective only if it was one of the loaded
        ;; perspectives
        (when (member (or (and cur-persp (persp-name cur-persp))
                          persp-nil-name)
                      persp-names)
          (layouts//load-eyebrowse-for-perspective 'frame))))

    (add-hook 'persp-after-load-state-functions #'layouts//load-eyebrowse-after-perspective-load))
#+end_src
*** projectile
**** projectile
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :defer  10
    ;; :diminish " Ⓟ"
    :delight " Projectile"
    :hook (prog-mode . projectile-mode)
    :commands (projectile-mode
               projectile-run-shell-command-in-root
               projectile-replace-regexp
               projectile-run-async-shell-command-in-root
               projectile-toggle-between-implementation-and-test
               projectile-switch-to-buffer
               projectile-compile-project
               projectile-dired
               projectile-find-dir
               projectile-find-file
               projectile-regenerate-tags
               projectile-find-tag
               projectile-invalidate-cache
               projectile-kill-buffers
               projectile-run-project
               projectile-replace
               projectile-test-project)
    :init
    (mohkale/declare-prefix "p" "projectile" "project management")
    (mohkale/set-leader-keys
      "p!" 'projectile-run-shell-command-in-root
      "p%" 'projectile-replace-regexp
      "p&" 'projectile-run-async-shell-command-in-root
      "pa" 'projectile-toggle-between-implementation-and-test
      "pb" 'projectile-switch-to-buffer
      "pc" 'projectile-compile-project
      "pD" 'projectile-dired
      "pd" 'projectile-find-dir
      "pf" 'projectile-find-file
      "pG" 'projectile-regenerate-tags
      "pg" 'projectile-find-tag
      "pI" 'projectile-invalidate-cache
      "pk" 'projectile-kill-buffers
      "pp" 'projectile-run-project
      "pR" 'projectile-replace
      "pt" 'projectile-test-project)

    (advice-add 'delete-buffer-file :after #'(lambda (&rest r)
                                               (when (projectile-project-p)
                                                 (call-interactively 'projectile-invalidate-cache))))
    :config
    (projectile-register-project-type 'rake '("rakefile")
                                      :compile "rake build"
                                      :test    "rake test"
                                      :run     "rake run"
                                      :test-suffix ".spec")

    (defun projectile-ensure-no-trailing-slash-in-root (func &rest args)
      (cl-letf* (((symbol-function 'true-projectile-project-root)
                  (symbol-function 'projectile-project-root))
                 ((symbol-function 'projectile-project-root)
                  (lambda (&rest args)
                    ;; TODO maybe don't hardcode file name seperator
                    (string-remove-suffix "/"
                                          (apply 'true-projectile-project-root args)))))
        (apply func args)))

    (advice-add 'projectile-regenerate-tags :around #'projectile-ensure-no-trailing-slash-in-root)

    (setq projectile-project-search-path '("~/programming/projects/"
                                           "~/programming/repos"
                                           "~/programming/")
          projectile-tags-backend 'xref ;; opt into gtags
          projectile-tags-command "ctags -Re -f \"%s\" %s \"%s\"")

    (unless (eq system-type 'gnu/linux)
      ;; fixes search glitches on windows when using cygwin
      (setq projectile-generic-command "find . -type f -print0")))
#+end_src
**** org-projectile
#+begin_src emacs-lisp
  (use-package org-projectile
    :ensure t
    :defer  t
    :commands (org-projectile-capture-for-current-project
               ;; org-projectile-helm-template-or-project
               org-projectile-project-todo-completing-read
               org-projectile-goto-location-for-project)
    :init
    (mohkale/declare-prefix*
      "po" "org-projectile-goto-todos"
      "pO" "org-projectile-capture")

    (mohkale/set-leader-keys
      "po" 'org-projectile-goto-location-for-project
      ;; "pO" 'org-projectile-helm-template-or-project
      )
    :config
    (org-projectile-per-project))
#+end_src
**** ivy-projectile
needs to be loaded after ivy and projectile, including the init function.
#+begin_src emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :defer  t
    ;; :after (projectile counsel)
    ;; :hook (projectile-mode . counsel-projectile-mode)
    :commands (counsel-projectile-switch-project
               counsel-projectile-find-file
               counsel-projectile-find-file-dwim
               counsel-projectile-find-dir
               counsel-projectile-switch-to-buffer
               counsel-projectile-grep
               counsel-projectile-ag
               counsel-projectile-rg
               counsel-projectile
               counsel-projectile-mode
               counsel-projectile-git-grep
               counsel-projectile-org-capture
               counsel-projectile-org-agenda)
    :init
    (mohkale/declare-prefix "ps" "search")

    (mohkale/set-leader-keys
      "pP"    'counsel-projectile-switch-project
      "pf"    'counsel-projectile-find-file
      "pd"    'counsel-projectile-find-dir
      "pb"    'counsel-projectile-switch-to-buffer
      "psg"   'counsel-projectile-grep
      "psv"   'counsel-projectile-git-grep
      "psa"   'counsel-projectile-ag
      "psr"   'counsel-projectile-rg
      "p SPC" 'counsel-projectile)
    ;; :config
    ;; (counsel-projectile-mode +1)
    )
#+end_src
*** server
#+begin_src emacs-lisp
  (require 'server)

  (unless (server-running-p)
    (server-start))
#+end_src

*** simple
    GET ME OUT OF HERE!!!
#+begin_src emacs-lisp
  (use-package simple
    :config
    (dolist (map `(messages-buffer-mode-map
                   special-mode-map
                   message-mode-map))
      (general-define-key
        :states 'normal
        :keymaps map
        "q" 'quit-window))
    (mohkale/declare-prefix "i TAB" "indent" "indentation")

    (mohkale/set-leader-keys
      "i TAB <tab>" 'indent-region
      "i TAB RET" 'split-line
      "i TAB r" 'indent-relative
      "i TAB R" 'indent-relative-first-indent-point
      "i TAB i" '(lambda () (interactive)
                   (unless (region-active-p)
                     (save-excursion
                       (evil-visual-line)))
                   (call-interactively 'indent-rigidly))
      "i TAB n" 'forward-to-indentation
      "i TAB N" 'back-to-indentation)
    (general-define-key
      :states 'normal
      "M-0" 'back-to-indentation)
    (general-define-key
      :states 'insert
      "<tab>" 'indent-relative)
    (evil-set-initial-state 'messages-buffer-mode 'motion)

    ;; force state for buffer if it already exists
    (let ((buffer (get-buffer "*Messages*")))
      (when buffer
        (with-current-buffer buffer
          (evil-motion-state))))

    ;; :bind* (:map indent-rigidly-map)
    )
#+end_src
*** smooth-scroll
   buttery smooth... nice and easy on the eyes
#+begin_src emacs-lisp
  ;; (use-package smooth-scroll
  ;;   :ensure t
  ;;   :defer  nil
  ;;   :config
  ;;   (smooth-scroll-mode 1)
  ;;   (setq smooth-scroll/vscroll-step-size 5))
#+end_src
*** sudo-edit
#+begin_src emacs-lisp
  (use-package sudo-edit
    :ensure t
    :defer  t
    :commands sudo-edit
    :init
    (mohkale/set-leader-keys
      "fE" 'sudo-edit))
#+end_src
*** rainbow-delimeters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :defer  t
    :hook (prog-mode . rainbow-delimiters-mode)
    :commands rainbow-delimiters-mode)
#+end_src
*** rainbow-mode
highlights hex color strings in their appropriate color. keep it around... though I'll probably never use it.
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer  t)
#+end_src
*** tags
#+begin_src emacs-lisp
  (use-package ggtags
    :ensure t
    :defer  t
    :commands (ggtags-find-tag-dwim
               ggtags-find-tag-mouse
               ggtags-find-definition
               ggtags-find-reference
               ggtags-find-other-symbol
               ggtags-find-tag-regexp
               ggtags-idutils-query
               ggtags-grep
               ggtags-find-file
               ggtags-query-replace)
    :init
    (mohkale/declare-prefix "T" "tags")

    (mohkale/set-leader-keys
      "TD" 'ggtags-delete-tags
      "T/" 'ggtags-grep)

    :config
    ;; NOTE ggtags-global-mode is not a global mode... global is
    ;;      for GNU *global* tagging system
    (mohkale/set-leader-keys-for-major-mode 'ggtags-global-mode
      "r" 'recompile
      "f" 'next-error-follow-minor-mode))
#+end_src
*** tildify
#+begin_src emacs-lisp
  (use-package tildify
    :defer t
    :delight " ~")
#+end_src
*** transpose-frame
#+begin_src emacs-lisp
  (use-package transpose-frame
    :defer t
    :commands (transpose-frame
               flip-frame
               flop-frame ;; flip horizontally
               rotate-frame ;; 180 degrees
               rotate-frame-clockwise ;; 90 degrees
               rotate-frame-anti-clockwise ;; 90 degrees
               )
    :bind (:map mohkale-window-map
           ("C-t" . transpose-frame)
           ("t" . transpose-frame)
           ("(" . rotate-frame-clockwise)
           (")" . rotate-frame-anti-clockwise)
           ("*" . rotate-frame)
           ("C-f" . flip-frame)
           ("f" . flip-frame)
           ("C-S-F" . flop-frame)
           ("F" . flop-frame)))
#+end_src
*** undo-tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :defer  t
    :diminish
    :bind* (:map undo-tree-map
            ("C-/" . nil)
            ("C-_" . nil)
            ("C-?" . nil)))
#+end_src
*** uuidgen
#+begin_src emacs-lisp
  (use-package uuidgen
    :ensure t
    :defer  t
    :commands uuidgen
    :init
    (mohkale/set-leader-keys
      "iU" 'uuidgen
      ;; "U" '(:prefix-command mohkale-insert-uuid-map :which-key "uuid")
      ;; "U1" 'uuidgen-1
      ;; "U4" 'uuidgen-4
      ;; "UU" 'uuidgen-U
      ))
#+end_src
*** vi-tilde
#+begin_src emacs-lisp
  (use-package vi-tilde-fringe
    :ensure t
    :defer  t
    :diminish
    :commands (vi-tilde-fringe-mode global-vi-tilde-fringe-mode)
    :config
    (global-vi-tilde-fringe-mode))
#+end_src
*** visual-line
#+begin_src emacs-lisp
  (use-package visual-line
    :defer t
    :delight " Ⓛ")
#+end_src
*** vlc-rc
#+begin_src emacs-lisp
  (use-package vlc-rc
    :defer t
    :commands vlc-rc-map
    :init
    ;; TODO fillout definition
    ;; (mohkale/set-leader-keys
    ;;   "v" '(:prefix-command vlc-rc-map :which-key "VLC"))
    ;; (evil-define-key 'normal dired-mode-map
    ;;   "v" nil)
    ;; (evil-define-key 'normal dired-mode-map
    ;;   "vv" 'vlc/dired-add-file
    ;;   "vq" 'vlc/dired-enqueue-file)
      )
#+end_src
*** which-key
    # TODO update which key display delay
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :demand t
    :diminish
    ;; :delight " Ⓚ"
    :config
    (which-key-mode 1)
    ;; order of keys is case insensetive
    (setq which-key-sort-order 'which-key-key-order-alpha
          which-key-echo-keystrokes 0.02)
    ;; translate winum-select-window number commands to single command in which key

    (mohkale/set-leader-keys
      "hk" 'which-key-show-top-level))
#+end_src
*** whitespace
#+begin_src emacs-lisp
  (use-package whitespace
    :defer t
    :delight
    (whitespace-mode " ⓦ")
    (global-whitespace-mode " ⓦ"))
#+end_src
*** winner
#+begin_src emacs-lisp
  (use-package winner
    :defer 10
    :commands (winner-mode
               winner-undo
               winner-redo)
    :config
    (winner-mode +1))
#+end_src
*** winum
#+begin_src emacs-lisp
  (use-package winum
    :ensure t
    :demand t
    :after which-key
    :config
    (setq winum-auto-setup-mode-line nil)
    (push '(("\\(.*\\) 0" . "winum-select-window-0") . ("\\1 0..9" . "window-by-num")) which-key-replacement-alist)
    (push '((nil . "winum-select-window-[1-9]") . t) which-key-replacement-alist)

    (winum-mode))
#+end_src
*** xref
#+begin_src emacs-lisp
  (use-package xref
    :defer t
    :commands (xref-find-definitions
               xref-find-apropos
               xref-find-definitions-other-window
               xref-find-definitions-other-frame
               xref-pop-marker-stack
               xref-find-references

               ;; xref buffer commands
               xref-next-line
               xref-prev-line
               xref-goto-xref
               xref-show-location-at-point ;; open new window
               xref-query-replace-in-results ;; substitute
               xref-quit-and-goto-xref
               xref-quit)
    :init
    (mohkale/declare-prefix "ax" "xref")

    (mohkale/set-leader-keys
      "axx" 'xref-find-references
      "axX" 'xref-find-definitions
      "ax/" 'xref-find-apropos
      "axw" 'xref-find-definitions-other-window
      "axf" 'xref-find-definitions-other-frame
      "ax SPC" 'xref-pop-marker-stack)
    :bind (;; erase global xref bindings
           ("M-." . nil)   ; xref-find-definitions
           ("M-," . nil)   ; xref-pop-marker-stack
           ("M-?" . nil)   ; xref-find-references
           ("C-M-." . nil) ; xref-find-apropos
           ))
#+end_src
*** yasnippet
   yet another snippets tool... but amazingly powerful. :-P
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :defer  t
    :commands (yas-expand
               yas-next-field
               yas-prev-field
               yas-new-snippet
               yas-visit-snippet-file)
    :delight (yas-minor-mode "YAS")
    :init
    (mohkale/set-leader-keys
      "iSn" 'yas-new-snippet
      "iSv" 'yas-visit-snippet-file)
    (general-define-key
      :states 'insert
      "C-i" 'yas-expand)
    :config
    (yas-global-mode 1)
    (general-define-key
      :keymaps 'yas-keymap
      "<C-return>" 'yas-next-field
      "<C-M-return>" 'yas-prev-field
      "C-l" 'yas-next-field
      "C-h" 'yas-prev-field))
#+end_src
**** auto-yasnippet
     allows you to create dynamic/in-place snippets and repeatedly execute them.
#+begin_src emacs-lisp
  (use-package auto-yasnippet
    :ensure t
    :defer  t
    :commands (aya-create
               aya-expand
               aya-persist-snippet)
    :init
    (mohkale/declare-prefix "iS" "auto-yasnippet")
    (mohkale/set-leader-keys
      "iSc" 'aya-create
      "iSe" 'aya-expand
      "iSw" 'aya-persist-snippet)
    (general-define-key
      :states 'insert
      "M-i" 'aya-expand))
#+end_src
**** snippet sources
***** yasnippet-snippets
#+begin_src emacs-lisp
  (use-package yasnippet-snippets
    :ensure t
    :defer  t)
#+end_src
*** ycmd
**** flycheck-ycmd
#+begin_src emacs-lisp
  (use-package flycheck-ycmd
    :ensure t
    :defer  t
    :commands flycheck-ycmd-setup
    :hook (ycmd-mode . flycheck-ycmd-setup))
#+end_src
**** company-ycmd
#+begin_src emacs-lisp
  (use-package company-ycmd
    :ensure t
    :defer  t
    :commands company-ycmd)
#+end_src
**** ycmd-mode
#+begin_src emacs-lisp
  (use-package ycmd
    :ensure t
    :defer  t
    :delight "YCMD"
    :hook (ycmd-mode . ycmd-eldoc-setup)
    :commands (ycmd-mode
               global-ycmd-mode
               ycmd-eldoc-setup
               ycmd-open
               ycmd-close
               ycmd-version
               ycmd-parse-buffer
               ycmd-load-conf-file
               ycmd-clear-compilation-flag-cache
               ycmd-show-debug-info
               ycmd-show-documentation
               ycmd-toggle-log-enabled
               ycmd-restart-semantic-server
               ycmd-get-type
               ycmd-completer
               ycmd-toggle-force-semantic-completion
               ycmd-refactor-rename
               ycmd-display-completions
               ycmd-goto
               ycmd-goto-imprecise
               ycmd-goto-type
               ycmd-goto-definition
               ycmd-goto-declaration
               ycmd-goto-references
               ycmd-goto-include
               ycmd-goto-implementation)
    :init
    ;; NOTE to enable ycmd completion, hook ycmd-mode into any desired
    ;;      buffers and include company-ycmd in the company backends for
    ;;      the mode.

    (setq ycmd-global-config (expand-file-name "~/.ycmd-config")
          ycmd-startup-timeout 10
          ycmd-server-command `("python3" "-u" ,(expand-file-name "~/.vim/plugged/YouCompleteMe/third_party/ycmd/ycmd")))

    ;; (ycmd-toggle-force-semantic-completion)

    (mohkale/declare-prefix-for-mode* 'ycmd-mode
      "y" "ycmd"
      "yg" "jump")

    (mohkale/set-leader-keys-for-minor-mode 'ycmd-mode
      "yy" 'ycmd-mode
      "yY" 'global-ycmd-mode
      "yn" 'ycmd-open
      "yk" 'ycmd-close
      "yv" 'ycmd-version
      "yb" 'ycmd-parse-buffer
      "yc" 'ycmd-load-conf-file
      "yC" 'ycmd-clear-compilation-flag-cache
      "ys" 'ycmd-show-debug-info
      "yd" 'ycmd-show-documentation
      "yl" 'ycmd-toggle-log-enabled
      "yr" 'ycmd-restart-semantic-server
      "yt" 'ycmd-get-type
      "y." 'ycmd-completer           ; completing-read all ycmd requests
      "y SPC" 'ycmd-toggle-force-semantic-completion
      "y C-r" 'ycmd-refactor-rename
      "y C-c" 'ycmd-display-completions
      "ygg" 'ycmd-goto
      "ygG" 'ycmd-goto-imprecise
      "ygt" 'ycmd-goto-type
      "ygd" 'ycmd-goto-definition
      "ygD" 'ycmd-goto-declaration
      "ygr" 'ycmd-goto-references
      "ygi" 'ycmd-goto-include
      "ygI" 'ycmd-goto-implementation)
    )
#+end_src

** languages
*** elisp
**** elisp-slime-nav
#+begin_src emacs-lisp
  (use-package elisp-slime-nav
    :ensure t
    :defer  t
    :commands (elisp-slime-nav-mode
               elisp-slime-nav-find-elisp-thing-at-point
               elisp-slime-nav-describe-elisp-thing-at-point)
    :hook (elisp-mode . elisp-slime-nav-mode)
    :config
    (mohkale/declare-prefix-for-major-mode 'emacs-lisp-mode
      "h"  "describe-symbol-at-point")

    (mohkale/set-leader-keys-for-major-mode 'emacs-lisp-mode
      "gp" 'elisp-slime-nav-find-elisp-thing-at-point
      "h" 'elisp-slime-nav-describe-elisp-thing-at-point))
#+end_src
**** evil-lisp-state
#+begin_src emacs-lisp
  (use-package evil-lisp-state
    :ensure t
    :defer  t
    :commands (evil-lisp-state-leader
               lisp-state-toggle-lisp-state
               lisp-state-eval-sexp-end-of-line)
    :init
    (mohkale/set-leader-keys-for-major-mode 'emacs-lisp-mode
      "el" 'lisp-state-eval-sexp-end-of-line
      "." 'lisp-state-toggle-lisp-state))
#+end_src
**** pp
#+begin_src emacs-lisp
  (use-package pp
    :defer t
    :commands (pp-eval-expression
               pp-macroexpand-expression
               pp-eval-last-sexp
               pp-macroexpand-last-sexp)
    :init
    (mohkale/set-leader-keys-for-major-mode 'emacs-lisp-mode
      "em" 'pp-macroexpand-expression
      "eM" 'pp-macroexpand-last-sexp
      "ex" 'pp-eval-expression
      "eX" 'pp-eval-last-sexp))
#+end_src
**** paredit
#+begin_src emacs-lisp
  (use-package paredit
    :ensure t
    :defer  t
    :hook (emacs-lisp-mode . paredit-mode)
    :init
    (add-hook 'emacs-lisp-mode-hook #'electric-pair-mode)
    :config
    ;; M-( wraps the next argument in parentheses
    ;; M-) closes the current argument, trims any
    ;;     trailing whitespace and inserts a newline
    ;; M-" same as " but then trims whitespace and inserts a newline
    (general-define-key
      :keymaps 'paredit-mode-map
      :states 'insert
      "<delete>" 'paredit-backward-delete
      "M-<delete>" 'paredit-forward-delete
      "C-<delete>" 'paredit-backward-kill-word
      ;; "C-M-<delete>" 'paredit-forward-kill-word
      ;; damn you windows
      ;; just use paredit forward, then kill backward
      "C-M-k" 'paredit-kill ;; forward body
      "<return>" 'paredit-newline)
    (general-define-key
      :keymaps 'paredit-mode-map
      :states 'normal
      "gsh" '(paredit-splice-sexp-killing-backward :which-key "splice-sexp-forward")
      "gsl" '(paredit-splice-sexp-killing-forward :which-key "splice-sexp-backward"))
    (general-define-key
      :keymaps 'paredit-mode-map
      :states '(normal insert)
      ;; movement
      ;; "C-h" 'backward-char
      ;; "C-l" 'forward-char
      "C-j" 'paredit-newline
      "C-M-h" 'paredit-backward
      "C-M-l" 'paredit-forward
      "C-<left>" 'paredit-backward
      "C-<right>" 'paredit-forward

      ;; transformation
      ;;; kill or wrap surrounding parentheses
      "C-S-K" 'paredit-splice-sexp
      "C-S-J" 'paredit-wrap-round
      ;;; include previous or next arguments in current sexp
      "C-S-H" 'paredit-backward-slurp-sexp
      "C-S-L" 'paredit-forward-slurp-sexp
      ;;; exclude previous or next arguments from current sexp
      "C-M-S-H" 'paredit-backward-barf-sexp
      "C-M-S-L" 'paredit-forward-barf-sexp

      "C-S-S" 'paredit-split-sexp
      "C-S-J" 'paredit-join-sexps

      ;; ;; splice next argument after point, deleting
      ;; ;; arguments both before and after it
      ;; a cool shortcut, but not really necessary
      ;; "M-r"   'paredit-raise-sexp
      )
    :bind (:map paredit-mode-map
           ("C-<up>"    . nil)
           ("C-<down>"  . nil)
           ("C-<left>"  . nil)
           ("C-<right>" . nil)))
#+end_src
**** elisp-mode
 #+begin_src emacs-lisp
   (use-package elisp-mode
     :defer t
     :config
     ;; evil-adjust: https://raw.githubusercontent.com/troyp/evil-adjust/master/evil-adjust.el
     (defmacro defun-evil-adjust-to-eol (function-name arglist &optional interactive &rest body)
       `(defun ,function-name ,arglist
          ,interactive
          (cl-case evil-state
            ('normal (progn
                       (evil-append 1)
                       ,@body
                       (evil-normal-state)))
            ('visual (progn
                       (evil-append 1)
                       ,@body
                       (evil-visual-restore)))
            (otherwise ,@body))))

     (defun-evil-adjust-to-eol evil-adjust-eval-print-last-sexp (&optional arg)
       (interactive "P")
       (eval-print-last-sexp arg)
       (message nil))

     (defun-evil-adjust-to-eol evil-adjust-eval-last-sexp (&optional arg)
       (interactive "P")
       (eval-last-sexp arg)
       (message nil))

     (defun eval-replace-last-sexp (&optional prefix)
       "evaluate then replace the preceding sexp"
       (interactive "p")
       (let* ((sexp (preceding-sexp))
              (value (eval sexp)))
         (kill-sexp -1)
         (insert (format (if prefix "%s" "%S") value))))

     (defun-evil-adjust-to-eol evil-adjust-eval-replace-last-sexp (&optional prefix)
       (interactive "P")
       (eval-replace-last-sexp prefix)
       (message nil))

     (evil-set-initial-state 'inferior-emacs-lisp-mode 'emacs)

     ;;   (defun elisp-transcript ()
     ;;     ;; source https://www.emacswiki.org/emacs/LispInteractionMode
     ;;     "Make an Emacs Lisp interactive transcript.
     ;; In a new buffer, make a transcript of the Emacs Lisp code by
     ;; evaluating each line and printing the result under it (/a la/
     ;;   TODO fix last sexp in the buffer isn't transcripted
     ;;   `eval-print-last-sexp')."
     ;;     (interactive)
     ;;     (let* ((eval-expression-print-length nil)
     ;;            (eval-expression-print-level nil)
     ;;            (input-buffer (current-buffer))
     ;;            (dest-buffer (get-buffer-create (concat "*Transcript for "
     ;;                                                    (buffer-name input-buffer)
     ;;                                                    "*"))))
     ;;       (save-current-buffer
     ;;         (set-buffer dest-buffer)
     ;;         (lisp-interaction-mode)
     ;;         (delete-region (point-min) (point-max))
     ;;         (insert-buffer-substring input-buffer) ;; `slurp!'
     ;;         (goto-char (point-min))
     ;;         (forward-sexp 1)
     ;;         (while (> (point-max) (point))
     ;;           (condition-case err
     ;;               (evil-adjust-eval-print-last-sexp)
     ;;             (error
     ;;              (insert (format "%s" err))
     ;;              (newline)))
     ;;           (forward-sexp 1)))
     ;;       (display-buffer dest-buffer)))

     (dolist (mode '(emacs-lisp-mode lisp-interaction-mode))
       (mohkale/declare-prefix-for-major-mode* mode
         "g" '("jump" . "jump to various places in source code")
         "e" "eval"
         "t" "test"

         ;; method aliases
         "gg" "jump-to-definition"
         "gG" "jump-to-definition-other-window"
         "eE" "eval-replace-last-sexp")

       (mohkale/set-leader-keys-for-major-mode mode
         ;; NOTE cl was bound to auto-compile-display-log
         "'" 'ielm
         "c" 'emacs-lisp-byte-compile
         "i" 'indent-sexp

         ;; eval
         "eb" 'eval-buffer
         "ee" 'eval-last-sexp
         "eE" 'evil-adjust-eval-replace-last-sexp
         "ef" 'eval-defun
         "er" 'eval-region
         ;; "et" 'elisp-transcript

         ;; jump
         "gg" 'xref-find-definitions
         "gG" 'xref-find-definitions-other-window

         ;; tests
         "tq" 'ert
         "ti" 'ert-run-tests-interactively))

     (general-define-key
       :states '(normal insert)
       :keymaps 'lisp-interaction-mode-map
       "C-h" 'evil-adjust-eval-print-last-sexp
       "C-l" 'evil-adjust-eval-replace-last-sexp)

     ;; (add-hook 'lisp-interaction-mode-hook #'(lambda () (paredit-mode -1)))
     :bind (:map lisp-interaction-mode-map
            ("C-j" . nil)))
 #+end_src
*** python
**** company-anaconda
#+begin_src emacs-lisp
  (use-package company-anaconda
    :ensure t
    :defer  t
    :commands (company-anaconda)
    :init
    (with-eval-after-load 'company
      (mohkale/update-company-backends-for-mode python t
        '(company-anaconda))))
#+end_src

**** anaconda
#+begin_src emacs-lisp
  (use-package anaconda-mode
    :ensure t
    :defer  t
    :hook ((python-mode . anaconda-mode)
           (python-mode . anaconda-eldoc-mode))
    :commands (anaconda-mode-complete
               anaconda-mode-show-doc
               anaconda-mode-find-assignments
               anaconda-mode-find-references
               anaconda-mode-find-definitions
               anaconda-mode-find-assignments-other-window
               anaconda-mode-find-references-other-window
               anaconda-mode-find-definitions-other-window
               anaconda-mode-find-assignments-other-frame
               anaconda-mode-find-references-other-frame
               anaconda-mode-find-definitions-other-frame)
    :config
    (mohkale/set-leader-keys-for-major-mode 'python-mode
      "<tab>" 'anaconda-mode-complete
      "hh" 'anaconda-mode-show-doc

      "ga" 'anaconda-mode-find-assignments
      "gr" 'anaconda-mode-find-references
      "gg" 'anaconda-mode-find-definitions
      "gA" 'anaconda-mode-find-assignments-other-window
      "gR" 'anaconda-mode-find-references-other-window
      "gG" 'anaconda-mode-find-definitions-other-window
      "g M-a" 'anaconda-mode-find-assignments-other-frame
      "g M-r" 'anaconda-mode-find-references-other-frame
      "g M-g" 'anaconda-mode-find-definitions-other-frame))

#+end_src
**** pyimport
#+begin_src emacs-lisp
  (use-package pyimport
    :ensure t
    :defer  t
    :commands (pyimport-remove-unused
               pyimport-insert-missing)
    :init
    (mohkale/declare-prefix-for-major-mode 'python-mode "i" "imports")
    (mohkale/set-leader-keys-for-major-mode 'python-mode
      "ii" 'pytimport-remove-unused
      "iu" 'pyimport-insert-missing))
#+end_src
**** py-isort
#+begin_src emacs-lisp
  (use-package py-isort
    :ensure t
    :defer  t
    :commands (py-isort-buffer
               py-isort-region)
    :init
    (mohkale/declare-prefix-for-major-mode 'python-mode "i" "imports")
    (mohkale/set-leader-keys-for-major-mode 'python-mode
      "is" 'py-isort-buffer
      "ir" 'py-isort-region))
#+end_src
**** pip-requirements
#+begin_src emacs-lisp
  (use-package pip-requirements
    :ensure t
    :defer  t
    :commands pip-requirements-mode
    :init
    (push (cons "^requirements\\.txt$" 'pip-requirements-mode) auto-mode-alist))
#+end_src
**** yapfify
#+begin_src emacs-lisp
  (use-package yapfify
    :ensure t
    :defer  t
    :init
    (mohkale/set-leader-keys-for-major-mode 'python-mode
      "y" 'yapfify-buffer
      "Y" 'yapfify-region))
#+end_src
**** python-mode
#+begin_src emacs-lisp
  (use-package python
    :defer t
    :hook (python-mode . flycheck-mode)
    :commands (python-mode
               run-python)
    :init
    (defalias 'python-repl 'run-python)
    (evil-set-initial-state 'inferior-python-mode 'emacs)
    :config
    (mohkale/declare-prefix-for-major-mode* 'python-mode
      "n" '("navigate" . "move-point")
      "e" "eval/exec"
      "h" "help"
      "g" "jump"

      "d" "method-signature")
    (mohkale/set-leader-keys-for-major-mode 'python-mode
      "r" 'run-python ;; REPL
      "R" 'python-shell-switch-to-shell
      "m" 'python-mark-defun
      "v" 'python-check
      ;; unbound: python-nav-forward-sexp[-safe]
      ;;          python-nav-backward-sexp[-safe]

      "nh" 'python-nav-forward-statement
      "nj" 'python-nav-forward-block
      "nk" 'python-nav-backward-block
      "nl" 'python-nav-backward-statement
      "n(" 'python-nav-backward-up-list
      "n)" 'python-nav-up-list
      "n0" 'python-nav-beginning-of-block
      "n$" 'python-nav-end-of-block
      "nm" 'python-nav-if-name-main
      "n C-0" 'python-nav-beginning-of-statement
      "n C-$" 'python-nav-end-of-statement
      "n M-j" 'python-nav-forward-defun
      "n M-k" 'python-nav-backward-defun
      ;; "n M-0" 'python-nav-beginning-of-defun
      "n M-$" 'python-nav-end-of-defun

      "hp" 'python-eldoc-at-point
      "s" 'python-describe-at-point

      "ed" 'python-shell-send-defun
      "eb" 'python-shell-send-buffer
      "ef" 'python-shell-send-file
      "er" 'python-shell-send-region
      "ec" 'python-shell-send-string))
#+end_src
*** ruby
**** enhanced ruby
#+begin_src emacs-lisp
  (use-package enh-ruby-mode
    :ensure t
    :defer  t
    :commands enh-ruby-mode
    :hook (enh-ruby-mode . flycheck-mode)
    :init
    ;; TODO add bindings for rake and others
    (push (cons "\\.rb$" 'enh-ruby-mode) auto-mode-alist)
    (push (cons "ruby" 'enh-ruby-mode) interpreter-mode-alist)
    :config
    (setq ruby-indent-level mohkale-preferred-indent)
    (mohkale/declare-prefix-for-major-mode* 'enh-ruby-mode
      "i" "insert/format"
      "n" "navigate")
    (mohkale/set-leader-keys-for-major-mode 'enh-ruby-mode
      "m" 'enh-ruby-mark-defun
      "f" 'enh-ruby-find-file
      "e" 'enh-ruby-find-error

      "i <tab>" 'enh-ruby-indent-exp
      "ie" 'enh-ruby-insert-end
      "it" 'enh-ruby-indent-exp

      "nh" 'enh-ruby-backward-sexp
      "nl" 'enh-ruby-forward-sexp
      "nk" 'enh-ruby-up-sexp
      "n0" 'enh-ruby-beginning-of-block
      "n$" 'enh-ruby-end-of-block
      "n M-0" 'enh-ruby-beginning-of-defun
      "n M-$" 'enh-ruby-end-of-defun)
    (general-define-key
      :keymaps 'enh-ruby-mode-map
      :states 'insert
      "{" 'enh-ruby-electric-brace
      "}" 'enh-ruby-electric-brace)
    (general-define-key
      :keymaps 'enh-ruby-mode-map
      :states '(normal insert)
      "C-{" 'enh-ruby-toggle-block)
    :bind (:map enh-ruby-mode-map
           ("{" . nil)
           ("}" . nil)))
#+end_src
**** robe
#+begin_src emacs-lisp
  (use-package robe
    :ensure t
    :defer  t
    :commands (robe-mode
               robe-start
               ruby-load-file
               company-robe)
    :hook (enh-ruby-mode . robe-mode)
    :init
    (with-eval-after-load 'company
      (mohkale/update-company-backends-for-mode enh-ruby t
        '(company-robe)))
    :config
    (mohkale/declare-prefix-for-major-mode 'enh-ruby-mode "g" "jump/goto")

    (mohkale/set-leader-keys-for-major-mode 'enh-ruby-mode
      "rs" 'robe-start ;; REPL
      "h" 'robe-doc

      ;; jumping
      "SPC" 'robe-ask
      "gg" 'robe-jump
      "gm" 'robe-jump-to-module))
#+end_src
**** inf-ruby
#+begin_src emacs-lisp
  (use-package inf-ruby
    :ensure t
    :defer  t
    :commands (inf-ruby
               inf-ruby-console-gem
               inf-ruby-console-zeus
               inf-ruby-console-auto
               inf-ruby-console-rails
               inf-ruby-console-racksh
               inf-ruby-console-script
               inf-ruby-console-hanami
               inf-ruby-console-default)
    :init
    (defalias 'ruby-repl 'inf-ruby)
    (mohkale/declare-prefix-for-major-mode 'enh-ruby-mode "r" "REPL")
    (mohkale/set-leader-keys-for-major-mode 'enh-ruby-mode
      "rr" 'inf-ruby
      "rg" 'inf-ruby-console-gem
      "rz" 'inf-ruby-console-zues
      "ra" 'inf-ruby-console-auto
      "rR" 'inf-ruby-console-rails
      "rk" 'inf-ruby-console-racksh
      "rc" 'inf-ruby-console-script
      "rh" 'inf-ruby-console-hanami))
#+end_src
**** ruby-tools
#+begin_src emacs-lisp
  (use-package ruby-tools
    :ensure t
    :defer  t
    :commands (ruby-tools-mode)
    :hook (enh-ruby-mode . ruby-tools-mode)
    :config
    (mohkale/set-leader-keys-for-major-mode 'enh-ruby-mode
      "i:" 'ruby-tools-to-symbol
      "i{" 'ruby-tools-interpolate
      "i <backspace>" 'ruby-tools-clear-string
      "i\"" 'ruby-tools-to-double-quote-string
      "i'" 'ruby-tools-to-single-quote-string))
#+end_src
**** bundle
#+begin_src emacs-lisp
  (use-package bundler
    :ensure t
    :defer  t
    :commands (bundle-open
               bundle-console
               bundle-install
               bundle-update
               bundle-check)
    :init
    (mohkale/set-leader-keys-for-major-mode 'enh-ruby-mode
      "rb" 'bundle-console
      "bf" 'bundle-open
      "bi" 'bundle-install
      "bu" 'bundle-update
      "bc" 'bundle-check))
#+end_src
*** HTML
**** web-mode
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :defer  t
    :init
    (dolist (regexp '("\\.erb"
                      "\\.html"))
      (push (cons regexp 'web-mode) auto-mode-alist))
    (setq css-indent-offset mohkale-preferred-indent)
    :config
    (setq web-mode-markup-indent-offset mohkale-preferred-indent
          web-mode-css-indent-offset mohkale-preferred-indent
          web-mode-code-indent-offset mohkale-preferred-indent)

    (general-define-key
      :keymaps 'web-mode-map
      :states 'normal
      "<tab>" 'web-mode-fold-or-unfold)

    (mohkale/declare-prefix-for-major-mode* 'web-mode
      "m" "mark"
      "d" "delete/kill"
      "D" "DOM"
      "n" "navigate"
      "na" "attributes"
      "nt" "tags"
      "r" "refactor"
      "i" "insert")

    (mohkale/set-leader-keys-for-major-mode 'web-mode
      ;; unbound:
      ;;   * web-mode-buffer-highlight
      ;;   * web-mode-element-mute-blanks
      ;;   * web-mode-block-beginning
      ;;   * web-mode-block-end
      ;;   * web-mode-block-insert
      ;;   * web-mode-block-kill
      ;;   * web-mode-block-next
      ;;   * web-mode-block-previous
      ;;   * web-mode-block-select
      ;;   * web-mode-block-transpose
      ;;   * web-mode-navigate
      ;;
      ;; WARN the block commands don't seem to do anything

      ";"     'web-mode-comment-or-uncomment
      "f"     'web-mode-fold-or-unfold
      "l"     'web-mode-file-link
      "b"     'web-mode-element-close ; insert matching tag for body at point
      "M-r"   'web-mode-reload
      "<tab>" 'web-mode-buffer-indent
      "C-M-i" 'web-mode-snippet-insert
      ;; "tw" 'web-mode-whitespace-show

      ;; insert
      "ia" 'web-mode-attribute-insert
      "ip" 'web-mode-element-wrap ; wrap current element in a new element with name from prompt
      "ic" 'web-mode-element-clone
      "ie" 'web-mode-element-insert
      "ie" 'web-mode-element-insert-at-point ; converts word before point to tag

      ;; refactor/insert
      "rs" 'web-mode-tag-attributes-sort
      "r(" 'web-mode-element-extract  ; add linebreak before every tag in body
      "r)" 'web-mode-element-contract ; collapse tag into a single line
      "rn" 'web-mode-dom-normalize
      "ra" 'web-mode-attribute-transpose
      "re" 'web-mode-element-transpose
      "rr" 'web-mode-element-rename
      "rf" 'web-mode-fold-or-unfold
      "rF" 'web-mode-element-children-fold-or-unfold ; collapse the children of current tags body, not body itself

      ;; delete
      "da" 'web-mode-attribute-kill
      "de" 'web-mode-element-kill
      "dp" 'web-mode-element-vanish ; delete element, but move body up a level instead of erasing it

      ;; DOM
      "Da" 'web-mode-dom-apostrophes-replace
      "Ds" 'web-mode-dom-entities-replace
      "Dq" 'web-mode-dom-quotes-replace
      "D/" 'web-mode-dom-xpath
      ; shows the xpath of the current element

      "hd" 'web-mode-dom-errors-show
      "hj" 'web-mode-jshint

      ;; mark
      "mT" 'web-mode-tag-select
      ; only works while between <>
      "mt" 'web-mode-element-select
      "ma" 'web-mode-attribute-select
      "mb" 'web-mode-element-content-select
      "mm" 'web-mode-mark-and-expand

      ;; navigation
      "n0" 'web-mode-element-beginning
      "n$" 'web-mode-element-end
      "nn" 'web-mode-tag-match
      "nh" 'web-mode-element-next
      "nj" 'web-mode-element-child
      "nk" 'web-mode-element-previous
      "nh" 'web-mode-element-parent
      ;; "nt" 'web-mode-dom-traverse
      "na0" 'web-mode-attribute-beginning
      "na$" 'web-mode-attribute-end
      "nah" 'web-mode-attribute-previous
      "nal" 'web-mode-attribute-next
      "nt0" 'web-mode-tag-beginning
      "nt$" 'web-mode-tag-end
      "nth" 'web-mode-tag-previous
      "ntl" 'web-mode-tag-next))
#+end_src
**** emmet-mode
#+begin_src emacs-lisp
  (use-package emmet-mode
    :ensure t
    :defer  t
    :hook (web-mode . emmet-mode)
    :commands (emmet-mode
               emmet-expand-yas
               emmet-expand-line
               emmet-preview-mode
               emmet-preview)
    :config
    (mohkale/declare-prefix-for-mode 'emmet-mode
      (concat mohkale-major-mode-leader-prefix "e") "emmet" "emmet mode")
    (mohkale/set-leader-keys-for-minor-mode 'emmet-mode
      (concat mohkale-major-mode-leader-prefix ".") 'emmet-expand-line
      ;; (concat mohkale-major-mode-leader-prefix "'") 'emmet-preview
      (concat mohkale-major-mode-leader-prefix "ee") 'emmet-expand-line
      (concat mohkale-major-mode-leader-prefix "ep") 'emmet-preview
      (concat mohkale-major-mode-leader-prefix "ew") 'emmet-wrap-with-markup
      (concat mohkale-major-mode-leader-prefix "en") 'emmet-next-edit-point
      (concat mohkale-major-mode-leader-prefix "eN") 'emmet-prev-edit-point)
    :bind* (:map emmet-mode-keymap
            ("C-j" . nil)))
#+end_src
**** company-web
#+begin_src emacs-lisp
  (use-package company-web
    :ensure t
    :defer  t
    :init
    (with-eval-after-load 'company
      (mohkale/update-company-backends-for-mode web t
        '(company-web-html company-yasnippet))))
#+end_src
**** simple-httpd
#+begin_src emacs-lisp
  (use-package simple-httpd
    :ensure t
    :defer  t
    :commands (httpd-start
               httpd-stop)
    :config
    (setq httpd-port 35343))
#+end_src
**** web-beautify
#+begin_src emacs-lisp
  (use-package web-beautify
    :ensure t
    :defer  t
    :commands (web-beautify-js
               web-beautify-html
               web-beautify-css)
    :init
    (mohkale/declare-prefix-for-major-mode 'web-mode "rb" "beautify")
    (mohkale/set-leader-keys-for-major-mode 'web-mode
      "rbh" 'web-beautify-htlm
      "rbj" 'web-beautify-js
      "rbc" 'web-beautify-css))
#+end_src
*** org
Yes, org mode is it's own language. Even if you don't think it is, it is :P
**** org-agenda
#+begin_src emacs-lisp
  (use-package org-agenda
    :ensure nil
    :defer  t
    :config
    (evil-set-initial-state 'org-agenda-mode 'normal)

    ;; TODO setup mode dependent leader keys
    ;; (spacemacs/set-leader-keys-for-major-mode 'org-agenda-mode "p" nil) ; reused as prefix

    ;; ;; TOOO simplify
    ;; (spacemacs/declare-prefix-for-mode 'org-agenda-mode "mc" "clock/calendar" "time management based prefix keys")
    ;; (spacemacs/declare-prefix-for-mode 'org-agenda-mode "mm" "modes" "minor modes to support agenda mode")
    ;; (spacemacs/declare-prefix-for-mode 'org-agenda-mode "mp" "priority" "alter/view an entries priority")
    ;; (spacemacs/declare-prefix-for-mode 'org-agenda-mode "m/" "search/filter" "search / filter org agenda")

    ;; (spacemacs/set-leader-keys-for-major-mode 'org-agenda-mode
    ;;   "A" 'org-agenda-append-agenda
    ;;   "C" 'org-agenda-columns

    ;;   ;;; filter/search
    ;;   "/c" 'org-agenda-filter-by-category
    ;;   "/e" 'org-agenda-filter-by-effort
    ;;   "//" 'org-agenda-filter-by-regexp
    ;;   ;; "/t" 'org-agenda-filter-by-tag
    ;;   "/:" 'org-agenda-filter-by-tag
    ;;   "/h" 'org-agenda-filter-by-top-headline
    ;;   "/R" 'org-agenda-filter-remove-all

    ;;   "/?" 'org-agenda-bulk-mark-regexp
    ;;   "/a" 'org-agenda-bulk-mark-all
    ;;   "/u" 'org-agenda-bulk-unmark-all

    ;;   ;;; clock/calendar/diary
    ;;   "cp" 'org-agenda-date-prompt
    ;;   "cc" 'org-agenda-clock-in
    ;;   "co" 'org-agenda-clock-out
    ;;   "cC" 'org-agenda-clock-out ; alias
    ;;   "ct" 'org-timer-set-timer
    ;;   "c M-c" 'org-agenda-convert-date

    ;;   ;;; agenda minor modes
    ;;   "ma" 'org-agenda-archives-mode
    ;;   "md" 'org-agenda-day-view
    ;;   "mc" 'org-agenda-clockreport-mode
    ;;   "mt" 'org-agenda-entry-text-mode
    ;;   "mf" 'org-agenda-follow-mode
    ;;   "ml" 'org-agenda-log-mode
    ;;   "mw" 'org-agenda-week-view
    ;;   "my" 'org-agenda-year-view
    ;;   "mm" 'org-agenda-month-view

    ;;   ;;; priorities
    ;;   "pp" 'org-agenda-priority
    ;;   "pu" 'org-agenda-priority-up
    ;;   "pd" 'org-agenda-priority-down)

    (general-define-key
      :keymaps 'org-agenda-mode-map
      :states  'normal
      ;;; globally useful
      "q" 'org-agenda-exit
      "." 'org-agenda-goto-today
      "v" 'org-agenda-view-mode-dispatch
      "RET" 'org-agenda-goto
      "TAB" 'org-agenda-switch-to
      "M-c" 'org-agenda-clock-goto ; jumped to clocking task
      "C-t" 'org-agenda-todo
      "M-t" 'org-agenda-show-tags

      ;;; marking
      "C-<SPC>" 'org-agenda-bulk-mark
      "M-<SPC>" 'org-agenda-bulk-unmark
      "C-M-SPC" 'org-agenda-bulk-action

      ;;; undo/redo
      "C-r" 'org-agenda-redo
      "u"   'org-agenda-undo
      "gr"        'org-agenda-redo-all

      ;;; toggle displays
      "gm" 'org-agenda-phases-of-moon
      "C-l" 'org-agenda-log-mode
      "M-l" 'org-agenda-toggle-time-grid
      "M-h" 'org-agenda-holidays
      "M-s" 'org-agenda-sunrise-sunset

      ;; edit org items
      "M-e" 'org-agenda-set-effort
      "C-a" 'org-agenda-archive-default-with-confirmation

      ;;; notes and insertion
      "a"  'org-agenda-add-note
      "c"  'org-agenda-capture
      "gd" 'org-agenda-goto-date
      "gc" 'org-agenda-goto-calendar

      ;;; movement between lines
      ;;; NOTE org-next/prev-line is used by follow-mode
      "k"      'org-agenda-previous-line
      "j"      'org-agenda-next-line
      "<up>"   'org-agenda-previous-line ; alias
      "<down>" 'org-agenda-next-line     ; alias
      "C-j"    'org-agenda-next-item
      "C-k"    'org-agenda-previous-item

      ;;; move through time in blocks
      "f" 'org-agenda-later
      "F" 'org-agenda-earlier

      "C-f" 'org-agenda-follow-mode
      "M-f" 'org-agenda-recenterstates))
#+end_src
**** org-bullets
#+begin_src emacs-lisp
  (use-package org-bullets
    :ensure t
    :defer  t
    :commands org-bullets-mode
    :hook (org-mode . org-bullets-mode))
#+end_src
**** org-toc
#+begin_src emacs-lisp
  (use-package toc-org
    :ensure t
    :defer  t
    :commands toc-org-mode
    ;; :hook (org-mode . toc-org-mode)
    )
#+end_src
**** org-mode
#+begin_src emacs-lisp
  (use-package org
    :ensure t
    :defer  t
    :hook (org-mode . mohkale//enable-line-numbers-handler)
    :commands (org-capture
               org-agenda
               org-copy-subtree
               org-cut-subtree)
    :init
    ;;; leader keys outside of org mode
    (mohkale/declare-prefix "oo" "org")
    (mohkale/set-leader-keys
      "oO"  'org-capture
      "ooa" 'org-agenda
      "ooy" 'org-copy-subtree
      "ooc" 'org-cut-subtree)
    :config
     ;; switch to insert state when capturing org templates
    (add-hook 'org-capture-mode-hook (lambda () (evil-append nil)) t)

    (let ((org-root (concat mohkale-config-root "/org/")))
      (setq-default org-src-window-setup 'current-window)

      (setq org-todo-keywords '((sequence "TODO" "DOING" "VERIFY" "|" "DONE" "DELAGATED" "SKIPPED"))
            org-refile-targets '((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))
            org-outline-path-complete-in-steps nil ; refile in a single go
            org-refile-use-outline-path t          ; show full paths for refiling
            org-default-notes-file (concat org-root "notes.org")
            org-agenda-files (file-expand-wildcards (concat org-root "*.org")))

      (setq org-capture-templates
            `(("f" "File Task" entry (file ,org-default-notes-file)
               "* TODO %?\n  %a"
               :kill-buffer t)
              ("t" "Todo" entry (file ,org-default-notes-file)
               "* TODO %?\n%U")
              ("T" "Todo with Clipboard" entry (file ,org-default-notes-file)
               "* TODO %?\n%U\n   %c")
              ("h" "Homework" entry (file+headline ,(concat org-root "university.org") "Homework")
               "* TODO%? %^g\n  DEADLINE: %^{Deadline}t\n  :LOGBOOK:\n  - Added %u\n  :END:"
               :kill-buffer t))))

    ;;  _
    ;; | | __ _ _ __   __ _ _   _  __ _  __ _  ___  ___
    ;; | |/ _` | '_ \ / _` | | | |/ _` |/ _` |/ _ \/ __|
    ;; | | (_| | | | | (_| | |_| | (_| | (_| |  __/\__ \
    ;; |_|\__,_|_| |_|\__, |\__,_|\__,_|\__, |\___||___/
    ;;                |___/             |___/

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (awk . t)
       (C . t)
       (awk . t)
       (java . t)
       (js . t)
       (python . t)
       (ruby . t)
       (sed . t)
       (shell . t)
       (R . t)))

    ;;             _ _       _     _           _ _
    ;;   _____   _(_) |     | |__ (_)_ __   __| (_)_ __   __ _ ___
    ;;  / _ \ \ / / | |_____| '_ \| | '_ \ / _` | | '_ \ / _` / __|
    ;; |  __/\ V /| | |_____| |_) | | | | | (_| | | | | | (_| \__ \
    ;;  \___| \_/ |_|_|     |_.__/|_|_| |_|\__,_|_|_| |_|\__, |___/
    ;;                                                   |___/

    (defmacro evil-org-eol-call-anon (&rest body)
      "define an anonymous function running body at the end of the line"
      `(lambda () (interactive) (end-of-visual-line) ,@body (evil-append nil)))

    (defun org-clever-return (&optional above insert-headings)
      "depending on the local state, inserts a heading, a table row an item or newline.
  insert-headings argument is for o & O bindings below. otherwise I don't want to have
  to insert heading everytime I return from a heading... kind of a hackish fix, maybe
  come up with a more intuitive way.

  TODO fix return broken for words

  this function is functionally similair to the result of evil-org-eol-call-anon, but
  instead of checking the line after moving to the end of it (which doesn't work for
  folded lines, such as headings), it checks before moving and then inserts the right
  items depending on how things looked where you were."
      (interactive)
      (let ((insert-line (lambda () (if above
                                      (evil-insert-newline-above)
                                    (end-of-visual-line)
                                    (evil-insert-newline-below)))))
        (cond ((org-table-p)
               (org-table-insert-row (not above))
               (evil-insert nil))
              ((and insert-headings
                    (org-at-heading-p))
               (funcall insert-line)
               (org-insert-heading)
               (evil-append nil))
              ((org-at-item-p)
               ;; position of cursor dictates where new point goes
               (if above
                   (goto-char (line-beginning-position))
                 (goto-char (line-end-position)))
               (org-insert-item)
               (evil-append nil))
              (t (call-interactively (if above 'evil-open-above 'evil-open-below))))))

    (general-define-key
      :keymaps 'org-mode-map
      :states 'insert
      "<return>" 'org-clever-return)

    (general-define-key
      :keymaps 'org-mode-map
      :states 'normal
      "o" '(lambda () (interactive) (org-clever-return nil t))
      "O" '(lambda () (interactive) (org-clever-return t   t))

      "M-u" 'org-metaleft
      "M-i" 'org-metadown
      "M-o" 'org-metaup
      "M-p" 'org-metaright
      "M-U" 'org-shiftmetaleft
      "M-I" 'org-shiftmetadown
      "M-O" 'org-shiftmetaup
      "M-P" 'org-shiftmetaright)

    (general-define-key
      :keymaps 'org-mode-map
      :states '(normal insert)
      ;; NOTE meta keys insert headings with changed priority, shift keys insert todo headings
      ;; FIXME prefix arg doesn't work
      ;; FIXME doesn't work when on a heading
      "C-<return>"   (evil-org-eol-call-anon (org-insert-heading nil))
      "C-M-<return>" (evil-org-eol-call-anon (org-insert-heading nil) (if prefix-arg
                                                                          (org-metaleft)
                                                                        (org-metaright)))
      "C-S-<return>"   (evil-org-eol-call-anon (org-insert-todo-heading nil))
      "C-S-M-<return>" (evil-org-eol-call-anon (org-insert-todo-heading nil) (if prefix-arg
                                                                                 (org-metaleft)
                                                                               (org-metaright)))
      "C-." 'org-toggle-heading)

    (general-define-key
      ;; most bindings stolen from: https://github.com/edwtjo/evil-org-mode
      :keymaps 'org-mode-map
      :states '(normal visual)
      "gh" '(lambda () (interactive) (call-interactively (if (org-at-heading-p)
                                                             'outline-up-heading
                                                           'outline-previous-heading)))
      "gj" 'org-forward-heading-same-level
      "gk" 'org-backward-heading-same-level
      "gl" 'outline-next-visible-heading
      ;; "t" 'org-todo ; I use this too often
      ;; "T" 'org-insert-todo-heading ; rebound to C-S-<return>
      "$" 'org-end-of-line
      "^" 'org-beginning-of-line

      "C-j" 'org-metadown
      "C-k" 'org-metaup)

    (general-define-key
      :keymaps 'org-mode-map
      :states '(normal visual insert emacs)
      "<tab>" 'org-cycle)

    ;; predicated on at heading

    (general-define-key
      :keymaps 'org-mode-map
      :states '(normal visual)
      :predicate '(org-at-heading-p)
      ">" 'org-demote-subtree
      "<" 'org-promote-subtree)

    (general-define-key
      :keymaps 'org-mode-map
      :states '(normal insert)
      :predicate '(org-at-heading-p)
      "C->" 'org-demote-subtree
      "C-<" 'org-promote-subtree)

    ;;  _                _                _
    ;; | | ___  __ _  __| | ___ _ __     | | _____ _   _ ___
    ;; | |/ _ \/ _` |/ _` |/ _ \ '__|____| |/ / _ \ | | / __|
    ;; | |  __/ (_| | (_| |  __/ | |_____|   <  __/ |_| \__ \
    ;; |_|\___|\__,_|\__,_|\___|_|       |_|\_\___|\__, |___/
    ;;                                             |___/

    (mohkale/declare-prefix-for-major-mode* 'org-mode
      "c" "clock/calendar"
      "e" "export"
      "h" "headings"
      "g" "jump"
      "i" "insert"
      "S" "subtrees"
      "t" "tables"
      "m" "mark/visual"
      "N" "narrow"
      "x" "text"

      "td" "delete"
      "ti" "insert"
      "tt" "toggle")

    (mohkale/set-leader-keys-for-major-mode 'org-mode
      "RET" 'org-ctrl-c-ret
      "!" 'org-time-stamp-inactive
      "'" 'org-edit-special
      "*" 'org-ctrl-c-star
      "," 'org-ctrl-c-ctrl-c
      "-" 'org-ctrl-c-minus
      "." 'org-time-stamp
      "/" 'org-sparse-tree
      ":" 'org-set-tags-command
      "^" 'org-sort
      "A" 'org-archive-subtree
      "a" 'org-agenda
      "b" 'org-tree-to-indirect-buffer
      ;; "C" 'evil-org-recompute-clocks
      "D" 'org-insert-drawer
      "d" 'org-deadline
      "f" 'org-set-effort
      "I" 'org-clock-in
      "H" 'org-shiftleft
      "J" 'org-shiftdown
      "K" 'org-shitup
      "L" 'org-shiftright
      "l" 'org-open-at-point
      "n" 'org-add-note
      "O" 'org-clock-out
      "P" 'org-set-property
      "p" 'org-pomodoro
      "r" 'org-refile
      "s" 'org-schedule
      "T" 'org-show-todo-tree
      "U" 'org-update-all-dblocks
      "u" 'org-dblock-update
      "C-h" 'org-shiftcontrolleft
      "C-j" 'org-shiftcontroldown
      "C-k" 'org-shiftcontrolup
      "C-l" 'org-shiftcontrolright
      "M-a" 'org-attach
      "M-c" 'org-columns
      "M-p" 'org-delete-property

      "c<" 'org-date-from-calendar
      "c>" 'org-goto-calendar
      "cC" 'org-clock-out
      "cc" 'org-clock-in
      ;; "cf" 'org-clock-modify-effort-estimate
      "cg" 'org-clock-goto
      "ch" 'org-clock-remove-overlays
      "ci" 'org-timer-item
      "cr" 'org-clock-report
      "cs" 'org-clock-display
      "c C-c" 'org-clock-cancel

      "ee" 'org-export-dispatch
      "eh" 'org-html-export-to-html

      "hI" 'org-insert-heading
      "hi" 'org-insert-heading-after-current
      "hs" 'org-insert-subheading

      "ia" 'org-attach
      "if" 'org-footnote-new
      ;; "ik" 'insert-keybinding-org
      "il" 'org-insert-link
      ;; "is" 'org-download-screenshot
      ;; "iy" 'org-download-yank

      "ms" 'org-mark-subtree
      "me" 'org-mark-element
      "mb" 'org-babel-mark-block

      "Nb" 'org-narrow-to-block
      "Ns" 'org-narrow-to-subtree
      "Ne" 'org-narrow-to-element
      "Nw" 'widen

      "Sh" 'org-promote-subtree
      "Sj" 'org-move-subtree-down
      "Sk" 'org-move-subtree-up
      "Sl" 'org-demote-subtree

      "t'"  'org-table-edit-field
      "ta"  'org-table-align
      "tb"  'org-table-blank-field
      "tc"  'org-table-convert
      "tE"  'org-table-export
      "te"  'org-table-eval-formula
      "tH"  'org-table-move-column-left
      "th"  'org-table-previous-field
      "tI"  'org-table-import
      "tJ"  'org-table-move-row-down
      "tj"  'org-table-next-row
      "tK"  'org-table-move-row-up
      "tL"  'org-table-move-column-right
      "tl"  'org-table-next-field
      "tN"  'org-table-create-with-table.el
      "tn"  'org-table-create
      "tp"  'org-plot/gnuplot
      "tr"  'org-table-recalculate
      "ts"  'org-table-sort-lines
      "tw"  'org-table-wrap-region
      "tdc" 'org-table-delete-column
      "tdr" 'org-table-delete-row
      "tic" 'org-table-insert-column
      "tiH" 'org-table-hline-and-move
      "tih" 'org-table-insert-hline
      "tir" 'org-table-insert-row
      "ttf" 'org-table-toggle-formula-debugger
      "tto" 'org-table-toggle-coordinate-overlays

      ;; "xb" 'org-bold
      ;; "xc" 'org-code
      ;; "xi" 'org-italic
      ;; "xr" 'org-clear
      ;; "xs" 'org-strike-through
      ;; "xu" 'org-underline
      ;; "xv" 'org-verbose
      )
    :bind* (:map org-mode-map
            ;; "C-M-<return>" org-meta-return)
            ("C-s" . org-sort)
            ("M-S-<return>" . nil)))

  (use-package org-src
    :defer t
    :config
    (mohkale/set-leader-keys-for-minor-mode 'org-src-mode
      (concat mohkale-major-mode-leader-prefix ",") 'org-edit-src-exit
      (concat mohkale-major-mode-leader-prefix "q") 'org-edit-src-abort
      (concat mohkale-major-mode-leader-prefix "s") 'org-edit-src-save))

  (use-package org-capture
    :defer t
    :config
    (mohkale/set-leader-keys-for-minor-mode 'org-capture-mode
      (concat mohkale-major-mode-leader-prefix ",") 'org-capture-finalize
      (concat mohkale-major-mode-leader-prefix "q") 'org-capture-kill
      (concat mohkale-major-mode-leader-prefix "r") 'org-capture-refile))
#+end_src
*** JSON
#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :defer  t
    :commands (json-decrement-number-at-point
               json-increment-number-at-point

               json-mode
               json-mode-beautify
               json-nullify-sexp
               json-mode-show-path
               json-toggle-boolean
               json-mode-kill-path)
    :hook (json-mode . flycheck-mode)
    :hook (json-mode . flycheck-mode)
    :init
    (push (cons "\\.json$" 'json-mode) auto-mode-alist)
    :config
    (mohkale/set-leader-keys-for-major-mode 'json-mode
      "b" 'json-mode-beautify
      "/" 'json-mode-kill-path
      "t" 'json-toggle-boolean
      "<backspace>" 'json-nullify-sexp))
#+end_src
*** vimscript
#+begin_src emacs-lisp
  (use-package vimrc-mode
    :ensure t
    :defer  t
    :hook (vimrc-mode . flycheck-mode)
    :commands vimrc-mode
    :delight (vimrc-mode "vim")
    :init
    (push (cons "\\.rb$" 'vimrc-mode) auto-mode-alist))
#+end_src
*** sql
**** sql
#+begin_src emacs-lisp
  (use-package sql
    :ensure t
    :defer  t
    :commands (sql-mode
               sql-connect
               sql-save-connection
               sql-beginning-of-statement
               sql-end-of-statement)
    :hook (sql-mode . flycheck-mode)
    :init
    (setq sql-sqlite-options '("-interactive"))
    (push (cons "\\.json$" 'sql-mode) auto-mode-alist)
    (evil-set-initial-state 'sql-interactive-mode 'emacs)
    :config
    ;; see [here](https://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client)
    ;; for a guide on how to make quick database access easier. or if you've already got
    ;; an interactive session running, use sql-save-connection to append it to a local
    ;; variable from which you can just paste it in here.
    (mohkale/declare-prefix-for-mode* 'sql-mode
      "e" "eval/exec"
      "l" "list")

    (mohkale/set-leader-keys-for-major-mode 'sql-mode
      "0" 'sql-beginning-of-statement
      "$" 'sql-end-of-statement
      "i" 'sql-show-sqli-buffer
      "t" 'sql-toggle-pop-to-buffer-after-send-region
      "eb" 'sql-send-buffer
      "ep" 'sql-send-paragraph
      "er" 'sql-send-region
      "es" 'sql-send-string
      "ll" 'sql-list-all
      "lt" 'sql-list-table)

    (mohkale/set-leader-keys-for-major-mode 'sql-interactive-mode
      "t" 'sql-list-table
      "a" 'sql-list-all))

#+end_src
**** sqlup
upcases SQL specific keywords after completing them.

#+begin_src emacs-lisp
  (use-package sqlup-mode
    :ensure t
    :defer  t
    :hook ((sql-mode . sqlup-mode)
           (sql-interactive-mode . sqlup-mode))
    :commands (sqlup-mode
               sqlup-capitalize-keywords-in-buffer
               sqlup-capitalize-keywords-in-region)
    :config
    (mohkale/declare-prefix-for-mode 'sql-mode
      "u" "upcase")
    (mohkale/set-leader-keys-for-major-mode 'sql-mode
      "ur" 'sqlup-capitalize-keywords-in-region
      "ub" 'sqlup-capitalize-keywords-in-buffer)

    (push "name" sqlup-blacklist))
#+end_src
**** sqlite-dump
converts an sqlite database file into the SQL schema required to reproduce it.
#+begin_src emacs-lisp
  (use-package sqlite-dump
    :defer t
    :commands (sqlite-dump))
#+end_src
*** YAML
#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :defer  t
    :commands (yaml-mode)
    :hook (yaml-mode . flycheck-mode)
    :init
    (push (cons "\\.json$" 'yaml-mode) auto-mode-alist)
    :config
    (general-define-key
      :keymaps 'yaml-mode-map
      :states 'insert
      "<tab>" 'yaml-indent-line)
    (mohkale/set-leader-keys-for-major-mode 'yaml-mode
      "n" 'yaml-narrow-to-block-literal
      "f" 'yaml-fill-paragraph
      "v" 'yaml-mode-version)
    (setq yaml-indent-offset mohkale-preferred-indent))
#+end_src
*** csv
#+begin_src emacs-lisp
  (use-package csv-mode
    :ensure t
    :defer  t
    :init
    (setq csv-separators '("," ":" ";" "\t"))
    :config

    (general-define-key
      :keymaps 'csv-mode-map
      "<tab>"     'csv-forward-field
      "<backtab>" 'csv-backward-field)

    (mohkale/declare-prefix-for-major-mode* 'csv-mode
      "s" "sort"
      "v" "yank")
    (mohkale/set-leader-keys-for-major-mode 'csv-mode
      "a"  'csv-align-fields
      "d"  'csv-kill-fields
      "i"  'csv-toggle-invisibility
      "r"  'csv-reverse-region
      "sf" 'csv-sort-fields
      "sn" 'csv-sort-numeric-fields
      "so" 'csv-toggle-descending
      "t"  'csv-transpose
      "u"  'csv-unalign-fields
      "vf" 'csv-yank-fields
      "vt" 'csv-yank-as-new-table))
#+end_src
*** shell-script
**** company-shell
#+begin_src emacs-lisp
  (use-package company-shell
    :ensure t
    :defer  t
    :commands (company-shell
               company-fish-shell
               company-shell-env)
    :init
    (with-eval-after-load 'company
      (mohkale/update-company-backends-for-mode sh t
        '(company-shell company-shell-env))))
#+end_src
**** shell-script-mode
#+begin_src emacs-lisp
  (use-package sh-script
    :defer t
    :hook ((sh-script-mode . electric-pair-mode)
           (sh-script-mode . flycheck-mode))
    :config
    (mohkale/declare-prefix-for-major-mode* 'sh-mode
      "<tab>" "indentation")
    (mohkale/set-leader-keys-for-major-mode 'sh-mode
      ":" 'sh-set-shell
      "0" 'sh-beginning-of-command
      "$" 'sh-end-of-command
      "!" 'executable-interpret
      "b" 'sh-show-shell
      "\\" 'sh-backslash-region

      "er" 'sh-execute-region
      "ej" 'sh-send-line-or-region-and-step

      "i=" 'sh-assignment
      "ic" 'sh-case
      "id" 'sh-cd-here
      "if" 'sh-for
      "i TAB" 'sh-if
      "il" 'sh-indexed-loop
      "io" 'sh-while-getopts
      "ir" 'sh-repeat
      "is" 'sh-select
      "it" 'sh-tmp-file
      "iu" 'sh-until
      "iw" 'sh-while
      "i(" 'sh-function
      "i+" 'sh-add

      "<tab> -" 'sh-learn-line-indent
      "<tab> =" 'sh-set-indent
      "<tab> |" 'sh-learn-buffer-indent
      "<tab> ?" 'sh-show-indent))
#+end_src
*** Markdown
**** company-emoji
#+begin_src emacs-lisp
  (use-package company-emoji
    :ensure t
    :defer  t
    :commands (company-emoji)
    :config
    (setq company-emoji-insert-unicode nil))
#+end_src
**** emojify
#+begin_src emacs-lisp
  (use-package emojify
    :ensure t
    :defer  t
    :commands (emojify-mode))
#+end_src
**** emoji-cheat-sheet-plus
disabled because it requires helm
#+begin_src emacs-lisp
  ;; requires helm
  ;; (use-package emoji-cheat-sheet-plus
  ;;   :ensure t
  ;;   :defer  t
  ;;   :commands (emoji-cheat-sheet-plus-echo
  ;;              emoji-cheat-sheet-plus-echo-and-copy
  ;;              emoji-cheat-sheet-plus-buffer))
#+end_src
**** gh-md
#+begin_src emacs-lisp
  (use-package gh-md
    :ensure t
    :defer  t
    :commands (gh-md-render-region
               gh-md-render-buffer))
#+end_src
**** markdown-mode
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :defer  t
    :hook ((markdown-mode . mohkale//enable-line-numbers-handler)
           (markdown-mode . emacs-emojify-mode)
           (markdown-mode . flycheck-mode))
    :config
    (general-define-key
      :keymaps 'markdown-mode-map
      :states 'normal
      "<tab>" 'markdown-cycle
      "<S-iso-lefttab>" 'markdown-shifttab
      "<S-tab>"         'markdown-shifttab
      "<backtab>"       'markdown-shifttab
      ;; "gh" 'markdown-outline-up
      "gj" 'markdown-next
      "gk" 'markdown-previous
      "gl" 'markdown-outline-next-same-level)
    (general-define-key
      :keymaps 'markdown-mode-map
      :states 'insert
      "<return>" 'markdown-enter-key
      "<backspace>" 'markdown-outdent-or-delete
      "<S-iso-lefttab>" 'markdown-outdent-or-delete
      "<S-tab>"         'markdown-outdent-or-delete
      "<backtab>"       'markdown-outdent-or-delete
      )
    (general-define-key
      :keymaps 'markdown-mode-map
      :states '(insert normal)
      "C-<return>" 'markdown-insert-list-item
      "C-S-J" 'markdown-move-down
      "C-S-K" 'markdown-move-up
      "C-S-H" 'markdown-promote
      "C-S-L" 'markdown-demote)

    (mohkale/update-company-backends-for-mode markdown t
      '(company-emoji))

    (advice-add 'markdown-insert-list-item :after (lambda (&rest args)
                                                    (if (eq (char-before)
                                                            ?*)
                                                        (evil-append nil)
                                                      (evil-insert nil))))

    (mohkale/declare-prefix-for-major-mode* 'markdown-mode
      "c" "check/complete"
      "e" "export"
      "i" "insert"
      "ih" "header"
      "il" "link"
      "d" "delete"
      "T" "toggle"
      "n" "navigate"
      "N" "narrow"
      "m" "mark"
      "t" "table"
      "ti" "insert"
      "td" "delete")

    (mohkale/set-leader-keys-for-major-mode 'markdown-mode
    ;;; unbound commands:
    ;;;  * markdown-outdent-region
    ;;;  * markdown-indent-region
    ;;;  * markdown-outline-previous-same-level

      "SPC" 'markdown-do
      "'" 'markdown-edit-code-block
      "f" 'markdown-follow-thing-at-point
      ">" 'markdown-blockquote-region
      "<tab>" 'markdown-pre-region ;; preformat

      "cc" 'markdown-complete
      "cb" 'markdown-complete-buffer
      "cr" 'markdown-check-refs
      "cR" 'markdown-unused-refs
      "cl" 'markdown-cleanup-list-numbers

      "eo" 'markdown-open
      "ee" 'markdown-export
      "ep" 'markdown-preview
      "ev" 'markdown-export-and-preview
      "em" 'markdown-other-window

      "i <tab>" 'markdown-insert-image
      "i*" 'markdown-insert-list-item
      "i!" 'markdown-insert-header-setext-1
      "i-" 'markdown-insert-hr
      "i1" 'markdown-insert-header-atx-1
      "i2" 'markdown-insert-header-atx-2
      "i3" 'markdown-insert-header-atx-3
      "i4" 'markdown-insert-header-atx-4
      "i5" 'markdown-insert-header-atx-5
      "i6" 'markdown-insert-header-atx-6
      "i@" 'markdown-insert-header-setext-2
      "iC" 'markdown-insert-gfm-code-block
      "iH" 'markdown-insert-header-setext-dwim
      "i[" 'markdown-insert-gfm-checkbox
      "ib" 'markdown-insert-bold
      "ic" 'markdown-insert-code
      "ie" 'markdown-insert-italic
      "if" 'markdown-insert-footnote
      "ii" 'markdown-insert-italic
      "ik" 'markdown-insert-kbd
      "ip" 'markdown-insert-pre
      "iq" 'markdown-insert-blockquote
      "is" 'markdown-insert-strike-through
      "ih!" 'markdown-insert-header-setext-1
      "ih1" 'markdown-insert-header-atx-1
      "ih2" 'markdown-insert-header-atx-2
      "ih3" 'markdown-insert-header-atx-3
      "ih4" 'markdown-insert-header-atx-4
      "ih5" 'markdown-insert-header-atx-5
      "ih6" 'markdown-insert-header-atx-6
      "ih@" 'markdown-insert-header-setext-2
      "ihH" 'markdown-insert-header-setext-dwim
      "ihh" 'markdown-insert-header-dwim
      "ihs" 'markdown-insert-header-setext-2
      "iht" 'markdown-insert-header-setext-1
      "ill" 'markdown-insert-link
      "ilf" 'markdown-insert-footnote
      "ilu" 'markdown-insert-uri
      "ilw" 'markdown-insert-wiki-link

      "dd" 'markdown-kill-thing-at-point
      "db" 'markdown-kill-block
      "do" 'markdown-kill-outline
      "dy" 'markdown-kill-ring-save

      "Tm" 'markdown-toggle-math
      "Tf" 'markdown-toggle-fontify-code-blocks-natively
      "Ti" 'markdown-toggle-inline-images
      "Tu" 'markdown-toggle-url-hiding
      "Tm" 'markdown-toggle-markup-hiding
      "Tc" 'markdown-toggle-gfm-checkbox
      "Tl" 'markdown-live-preview-mode

      "nu" 'markdown-next-link
      "nU" 'markdown-previous-link
      "nb" 'markdown-forward-block
      "nB" 'markdown-backward-block
      "nh" 'markdown-up
      "nj" 'markdown-next
      "nk" 'markdown-previous
      "nl" 'markdown-outline-next-same-level
      "nL" 'markdown-outline-previous-same-level

      "Nb" 'markdown-narrow-to-block
      "Np" 'markdown-narrow-to-page
      "Ns" 'markdown-narrow-to-subtree
      "Nw" 'widen

      "ms" 'markdown-mark-subtree
      "mb" 'markdown-mark-block

      "ts" 'markdown-table-sort-lines
      "tT" 'markdown-table-transpose
      "tt" 'markdown-insert-table
      "tc" 'markdown-table-convert-region
      "tir" 'markdown-table-insert-row
      "tic" 'markdown-table-insert-column
      "tdr" 'markdown-table-delete-row
      "tdc" 'markdown-table-delete-column))
#+end_src
*** cmake
**** cmake-mode
#+begin_src emacs-lisp
  (use-package cmake-mode
    :ensure t
    :defer  t
    :commands (cmake-mode)
    ;; :mode (("CMakeLists\\.txt\\'" . cmake-mode) ("\\.cmake\\'" . cmake-mode))
    :hook (cmake-mode . flycheck-mode)
    :init
    (push (cons "CMakeLists\\.txt\\'" 'cmake-mode) auto-mode-alist)
    (push (cons "\\.cmake\\'" 'cmake-mode) auto-mode-alist)
    :config
    (mohkale/update-company-backends-for-mode cmake t
      '(company-cmake)))
#+end_src
**** company-cmake
#+begin_src emacs-lisp
  (use-package company-cmake
    ;; :ensure t
    :defer  t
    :commands (company-cmake))
#+end_src
*** C-C++
**** company-c-headers
#+begin_src emacs-lisp
  (use-package company-c-headers
    :ensure t
    :defer  t
    :commands (company-c-headers))
#+end_src
**** cc-mode
#+begin_src emacs-lisp
  (use-package cc-mode
    :ensure t
    :defer  t
    :commands (c-mode c++-mode)
    :hook (
           ;; use global-ycmd-mode manually
           ;; (c-mode   . ycmd-mode)
           ;; (c++-mode . ycmd-mode)
           (c-mode   . flycheck-mode)
           (c++-mode . flycheck-mode))
    :init
    (push (cons ".*\\.h$" 'c-mode) auto-mode-alist)
    :config
    (c-toggle-auto-newline +1)
    (setq c-default-style "stroustrup"
          c-basic-offset mohkale-preferred-indent)

    (mohkale/update-company-backends-for-mode c t
      '(company-ycmd company-c-headers))

    (mohkale/update-company-backends-for-mode c++ t
      '(company-ycmd company-c-headers)))
#+end_src
**** disaster
#+begin_src emacs-lisp
  (use-package disaster
    :ensure t
    :defer  t
    :commands (disaster)
    :init
    (dolist (mode '(c-mode c++-mode))
      (mohkale/set-leader-keys-for-major-mode mode
        "D" 'disaster)))
#+end_src
*** kotlin
#+begin_src emacs-lisp
  (use-package kotlin-mode
    :ensure t
    :defer  t
    :hook (kotlin-mode . lsp)
    :commands (kotlin-mode
               kotlin-repl)
    :config
    (setq kotlin-tab-width 4)

    (mohkale/declare-prefix-for-major-mode 'kotlin-mode
      "e" "eval")

    (mohkale/set-leader-keys-for-major-mode 'kotlin-mode
      "r" 'kotlin-repl
      "e-" 'kotlin-send-line
      "e|" 'kotlin-send-block
      "er" 'kotlin-send-region
      "eb" 'kotlin-send-buffer
      "e S--" 'kotlin-send-line-and-focus
      "e S-|" 'kotlin-send-block-and-focus
      "eR"    'kotlin-send-region-and-focus
      "eB"    'kotlin-send-buffer-and-focus))
#+end_src
** Unimplemented Languages
https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang
*** scala
*** java
#+begin_src emacs-lisp
  ;; (use-package cc-mode
  ;;   :defer t
  ;;   :commands (java-mode . ycmd-mode)
  ;;   :config
  ;;   (mohkale/update-company-backends-for-mode java t
  ;;     '(ycmd-mode))
  ;;   )

  ;; key             binding
  ;; ---             -------

  ;; C-c C-a         c-toggle-auto-newline
  ;; C-c C-b         c-submit-bug-report
  ;; C-c C-c         comment-region
  ;; C-c C-d         c-hungry-delete-forward
  ;; C-c C-k         c-toggle-comment-style
  ;; C-c C-l         c-toggle-electric-state
  ;; C-c C-n         c-forward-conditional
  ;; C-c C-o         c-set-offset
  ;; C-c C-p         c-backward-conditional
  ;; C-c C-q         c-indent-defun
  ;; C-c C-s         c-show-syntactic-information
  ;; C-c C-u         c-up-conditional
  ;; C-c C-w         c-subword-mode
  ;; C-c C-z         c-display-defun-name
  ;; C-c C-\         c-backslash-region
  ;; C-c .           c-set-style
  ;; C-c DEL         c-hungry-delete-backwards
  ;; C-c C-DEL       c-hungry-delete-backwards
  ;; C-c <C-backspace>               c-hungry-delete-backwards
  ;; C-c <C-delete>                  c-hungry-delete-forward
  ;; C-c <C-deletechar>              c-hungry-delete-forward
  ;; C-c <deletechar>                c-hungry-delete-forward

  ;; C-M-a           c-beginning-of-defun
  ;; C-M-e           c-end-of-defun
  ;; C-M-h           c-mark-function
  ;; C-M-j           c-indent-new-comment-line
  ;; C-M-q           c-indent-exp
  ;; M-a             c-beginning-of-statement
  ;; M-e             c-end-of-statement
  ;; M-q             c-fill-paragraph

  ;; (use-package company-meghanada
  ;;   :ensure t
  ;;   :defer  t
  ;;   :commands company-meghanada)

  (use-package meghanada
    :ensure t
    :defer  t
    :delight (meghanada "MEG")
    :hook (meghanda-mode . meghanada-telemetry-enable)
    :commands (meghanda-mode
               meghanada-install-server
               meghanada-update-server
               meghanada-server-start
               meghanada-restart
               meghanada-server-kill
               meghanada-client-direct-connect
               meghanada-client-connect
               meghanada-client-disconnect
               meghanada-client-ping
               meghanada-clear-cache

               meghanada-import-all
               meghanada-optimize-import
               meghanada-import-at-point
               meghanada-local-variable
               meghanada-compile-file
               meghanada-project-show
               meghanada-project-compile
               meghanada-switch-testcase
               meghanada-exec-main
               meghanada-debug-main
               meghanada-reference
               meghanada-search-everywhere
               meghanada-search-everywhere-ex
               meghanada-typeinfo
               meghanada-run-junit-class
               meghanada-run-junit-test-case
               meghanada-debug-junit-class
               meghanada-debug-junit-test-case
               meghanada-run-task
               meghanada-jump-declaration
               meghanada-back-jump
               meghanada-code-beautify)
    :config
    (mohkale/update-company-backends-for-mode meghanada nil
      '(meghanda-mode)))
#+end_src
*** latex
*** haskell
#+begin_src emacs-lisp
  ;; (use-package hindent
  ;;   :ensure t
  ;;   :defer  t
  ;;   :commands (hindent-mode
  ;;              hindent-reformat-decl
  ;;              hindent-reformat-buffer
  ;;              hindent-reformat-decl-or-fill
  ;;              hindent-reformat-region))

  ;; (use-package company-ghci
  ;;   :ensure t
  ;;   :defer  t
  ;;   :commands company-ghci)

  ;; (use-package flycheck-haskell
  ;;   :ensure t
  ;;   :defer  t
  ;;   :commands (flycheck-haskell-setup))

  ;; (use-package haskell-mode
  ;;   :ensure t
  ;;   :defer  t
  ;;   :commands (haskell-mode)
  ;;   :config
  ;;   (mohkale/update-company-backends-for-mode 'haskell-mode t
  ;;     '(company-ghci))
  ;;   )

  ;; https://github.com/ndmitchell/hlint
  ;; https://github.com/mpickering/hlint-refactor-mode
  ;; http://haskell.github.io/haskell-mode/manual/latest/Introduction.html#Introduction
  ;; https://gist.github.com/snoyberg/3807bac2cdf276fd0aecd2f26916e025
  ;; https://github.com/iquiw/company-cabal
  ;; https://github.com/emacs-lsp/lsp-haskell
  ;; https://github.com/haskell/haskell-ide-engine ;; THIS SUCKS
#+end_src
*** go
*** C#
*** assembly
*** javascript
#+begin_src emacs-lisp
  ;; NOTE no on the fly syntax checking? make sure eslint is installed
  ;;      no warning or error will be issued if it isn't :(.

  (use-package js2-mode
    :ensure t
    :defer  t
    :hook (js2-mode . flycheck-mode)
    :init
    (push (cons "\\.js$" 'js2-mode) auto-mode-alist)
    :config
    (mohkale/update-company-backends-for-mode js2-mode t
      '(company-tern))

    (setq js2-mode-show-parse-errors      nil
          js2-mode-show-strict-warnings   nil
          js2-strict-missing-semi-warning nil)

    (general-define-key
      :keymaps 'js2-mode-map
      :states  'insert
      ;; properly formets javadocs
      "<return>" 'js2-line-break)

    (mohkale/declare-prefix-for-major-mode* 'js2-mode
      "i" "insert"
      "h" "help"
      "H" "hide/show"
      "Hh" "hide"
      "Hs" "show")

    (mohkale/set-leader-keys-for-major-mode 'js2-mode
      "gg" 'js2-jump-to-definition

      ;; toggle hide-show
      "HH" 'js2-mode-show-all
      "Hw" 'js2-mode-toggle-warnings-and-errors
      "He" 'js2-mode-toggle-element
      "Hc" 'js2-mode-toggle-hide-comments
      "Hf" 'js2-mode-toggle-hide-functions

      ;; hide
      "Hhw" 'js2-mode-hide-warnings-and-errors
      "Hhe" 'js2-mode-hide-element
      "Hhc" 'js2-mode-show-comments
      "Hhf" 'js2-mode-hide-functions

      ;; show
      "Hsw" 'js2-mode-display-warnings-and-errors
      "Hse" 'js2-mode-show-element
      "Hsc" 'js2-mode-hide-comments
      "Hsf" 'js2-mode-show-functions))

  (use-package company-tern
    :ensure t
    :defer  t
    :commands company-tern
    :init
    (mohkale/update-company-backends-for-mode js2 t
      '(company-tern)))

  (use-package tern
    :ensure t
    :defer  t
    :hook (js2-mode . tern-mode)
    :commands tern-mode)

  (use-package js-doc
    :ensure t
    :defer  t
    :commands (js-doc-insert-function-doc
               js-doc-insert-function-doc-snippet
               js-doc-insert-tag
               js-doc-insert-file-doc
               js-doc-describe-tag)
    :init
    ;; (general-define-key
    ;;   :keymaps 'js2-mode-map
    ;;   :states 'insert
    ;;   "@" 'js-doc-insert-tag)

    (mohkale/set-leader-keys-for-major-mode 'js2-mode
      "i@" 'js-doc-insert-tag
                                          ; only works from within method
      "i)" 'js-doc-insert-function-doc
      "i(" 'js-doc-insert-function-doc-snippet
      "if" 'js-doc-insert-file-doc
      "h@" 'js-doc-describe-tag)

    :config
    (advice-add 'js-doc-insert-function-doc-snippet :after #'(lambda (&rest r)
                                                               (evil-insert nil))))

  ;; most of this doesn't seem to work very well...
  ;; so I'm only using a few functions with simple features.
  (use-package js2-refactor
    :ensure t
    :defer  t
    :diminish
    :hook (js2-mode . js2-refactor-mode)
    :config
    (defun js2r-exit-visual-mode-after-func-call (&rest args)
      (when (evil-visual-state-p)
        (evil-exit-visual-state)))

    (advice-add 'js2r-extract-method   :after #'js2r-exit-visual-mode-after-func-call)
    (advice-add 'js2r-extract-function :after #'js2r-exit-visual-mode-after-func-call)

    (mohkale/declare-prefix-for-major-mode 'js2-mode
      "e" "extract")

    (mohkale/set-leader-keys-for-major-mode 'js2-mode
      "[" 'js2r-expand-node-at-point
      "]" 'js2r-contract-node-at-point

      ; doesn't work unless executed from within a function
      "ef" 'js2r-extract-function
      "em" 'js2r-extract-method
      "ev" 'js2r-extract-var
      "el" 'js2r-extract-let
      "ec" 'js2r-extract-const

      "l" 'js2r-log-this
      "L" 'js2r-debug-this

      "v" 'js2r-var-to-this

      "s" 'js2r-forward-slurp
      "b" 'js2r-forward-barf))

  (use-package xref-js2
    :ensure t
    :defer  t
    :commands (xref-js2-xref-backend)
    :init
    (with-eval-after-load 'js2-mode
      (add-hook 'xref-backend-functions #'xref-js2-xref-backend)))

  ;; https://github.com/NicolasPetton/Indium
#+end_src
**** skewer-mode
#+begin_src emacs-lisp
  ;; (use-package skewer-mode
  ;;   :ensure t
  ;;   :defer  t
  ;;   :delight
  ;;   (skewer-css-mode "skewerC")
  ;;   (skewer-html-mode "skewerH")
  ;;   :commands (skewer-mode
  ;;              skewer-css-mode
  ;;              skewer-html-mode)
  ;;   :config
  ;;   ;; once required, enable skewer in all
  ;;   ;; compatible buffers
  ;;   (add-hook 'js2-mode-hook 'skewer-mode)
  ;;   (add-hook 'css-mode-hook 'skewer-css-mode)
  ;;   (add-hook 'html-mode-hook 'skewer-html-mode)

  ;;   (run-skewer) ;; and begin server

  ;;   (with-eval-after-load 'html
  ;;     (mohkale/set-leader-keys-for-major-mode 'html-mode
  ;;       "e" 'skewer-html-eval-tag)))
#+end_src
* Themes
** an old hope
#+NAME: an-old-hope-theme-description
#+BEGIN_EXAMPLE
emacs theme inspired by a galaxy far far away...
this theme is largely just a shot for shot copy of jesseleite/an-old-hope-syntax-atom
ported to emacs because I refuse to live with an IDE that doesn't look like it XD.
This theme isn't compatible with emacs in the terminal yet, when I find an easy way
to approximate true-color colors to non-true-color colors, then I'll add support for
it.
#+END_EXAMPLE

#+NAME: an-old-hope-theme-color-associations
| color-name        | new-name   | hue | sat | light | description                       |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| very-light-grey   |            | 228 |   7 |    81 | shades of the millenium falcon    |
| light-grey        |            | 228 |   7 |    55 | shades of the millenium falcon    |
| grey              |            | 228 |   7 |    44 | shades of the millenium falcon    |
| dark-grey         |            | 228 |   7 |    29 | shades of the millenium falcon    |
| very-dark-grey    |            | 228 |   7 |    12 | shades of the millenium falcon    |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| vader             | red        | 352 |  81 |    58 | Vader's lightsaber                |
| vader-dim         | red-dim    | 352 |  60 |    58 |                                   |
| vader-int         | red-int    | 360 |  90 |    58 |                                   |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| luke              | orange     |  25 |  86 |    55 | Luke's pilot uniform              |
| luke-dim          | orange-dim |  25 |  60 |    60 |                                   |
| luke-int          | orange-int |  25 |  86 |    65 |                                   |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| threepio          | yellow     |  50 |  74 |    61 | Human cyborg relations            |
| threepio-dim      | yellow-dim |  50 |  74 |    31 |                                   |
| threepio-int      | yellow-int |  50 | 100 |    61 |                                   |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| yoda              | green      | 107 |  40 |    57 | Fear is the path to the dark side |
| yoda-dim          | green-dim  | 100 |  30 |    57 |                                   |
| yoda-int          | green-int  | 120 |  50 |    57 |                                   |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| artoo             | blue       | 196 |  64 |    58 | Whistle. Beep. Bloop.             |
| artoo-dim         | blue-dim   | 200 |  44 |    58 |                                   |
| artoo-int         | blue-int   | 220 |  84 |    64 |                                   |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| purple            |            | 313 |  32 |    60 |                                   |
| purple-dim        |            | 313 |  32 |    70 |                                   |
| purple-int        |            | 313 |  40 |    60 |                                   |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| turquoise         |            | 165 |  70 |    65 |                                   |
| turquoise-dim     |            | 165 |  80 |    50 |                                   |
| turquoise-int     |            | 165 |  60 |    85 |                                   |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| black             |            | 240 |   6 |    14 |                                   |
| black-dim         |            | 240 |  10 |    20 |                                   |
| black-int         |            | 240 |   6 |    00 |                                   |
|-------------------+------------+-----+-----+-------+-----------------------------------|
| line-highlight-bg |            | 228 |   7 |    21 |                                   |
| debug             |            | 239 | 100 |    20 | bright blue                       |

#+NAME: rainbow-delimeter-shades
- #E6B422
- #C70067
- #00A960
- #FC7482
- #E6B422
- #C70067
- #00A960
- #FC7482

colors taken from [[https://github.com/gastrodia/rainbow-brackets][here.]] colors 5-8 just recycle 1-4, maybe come up with more.

#+NAME: color-assoc-to-rgb-strings
#+HEADER: :var associations=an-old-hope-theme-color-associations
#+begin_src emacs-lisp :results value table :tangle no :exports none
  (require 'color)
  (require 'subr-x)

  (let (result)
    (dolist (row (cdr associations))
      (message "%s" row)
      (let* ((color-name (nth 0 row))
             (dest-name  (progn
                           (let ((dest-name (nth 1 row)))
                             (if (string-empty-p dest-name)
                                 color-name
                               dest-name))))
             (hue   (/ (nth 2 row) 360.0))
             (sat   (/ (nth 3 row) 100.0))
             (light (/ (nth 4 row) 100.0))

             (rgb (color-hsl-to-rgb hue sat light))
             (red   (nth 0 rgb))
             (green (nth 1 rgb))
             (blue  (nth 2 rgb)))
        (push (list (intern dest-name)
                    (color-rgb-to-hex red green blue 2))
              result)))
    (reverse result))
#+end_src

#+HEADER: :shebang ";; -*- lexical-binding: t -*-"
#+HEADER: :var desc=an-old-hope-theme-description colors=color-assoc-to-rgb-strings() cls=(eval t) rainbow-delims=rainbow-delimeter-shades
#+begin_src emacs-lisp :tangle "~/.emacs.d/etc/themes/an-old-hope-theme.el"
  (require 'dash)

  (deftheme an-old-hope
    desc)

  (dolist (color colors)
    (set (car color) (nth 1 color)))

  (setq rainbow-delims (-flatten rainbow-delims))

  (custom-theme-set-faces
   'an-old-hope

   ;;; basic
   `(cursor ((,cls (:background ,red))))
   `(custom-button ((,cls (:background ,very-dark-grey :foreground ,very-light-grey :box (:line-width 2 :style released-button)))))

   ;; sets the general foreground and background colors
   `(default ((,cls (:background ,very-dark-grey :foreground ,very-light-grey))))
   `(default-italic ((,cls (:italic t :inherit default))))
   `(hl-line ((,cls (:background ,line-highlight-bg)))) ; NOTE current line
   `(fringe ((,cls (:background ,black)))) ; NOTE: defines bars to the left and right, after line number when applicable
   `(vi-tilde-fringe-face ((,cls ((:inherit default)))))
   `(vertical-border ((,cls (:foreground ,very-light-grey)))) ; NOTE seperator between windows

   ;; errors, successes and warnings and other highlights
   `(error   ((,cls (:background ,red    :distant-foreground ,red    :foreground ,very-dark-grey :inherit bold))))
   `(success ((,cls (:background ,green  :distant-foreground ,green  :foreground ,very-dark-grey :inherit bold))))
   `(warning ((,cls (:background ,yellow :distant-foreground ,yellow :foreground ,very-dark-grey :inherit bold))))
   `(highlight ((,cls (:foreground ,very-dark-grey :background ,turquoise :distant-foreground ,turquoise :inherit bold))))
   `(region ((,cls (:background ,dark-grey :weight bold)))) ; NOTE visual mode selection
   `(secondary-selection ((,cls (:inherit region)))) ; TODO no idea what this is for, document it
   `(lazy-highlight ((,cls (:background ,orange :foreground ,black-dim)))) ; color for matches for in process searches
   `(isearch ((t (:inherit lazy-highlight :weight bold)))) ; NOTE inherited by evil-ex-search
   `(shadow ((,cls (:foreground ,light-grey)))) ; shadowed text, undermines actual text
   `(header-line ((,cls (:background ,very-dark-grey :foreground ,blue)))) ; shown at the top of some buffers, including in HEXL mode and helm
   `(match ((,cls (:foreground ,green-dim)))) ; TODO no idea what this is for, document it

   ;; line numbers
   `(line-number ((,cls (:background ,black :foreground ,very-light-grey :weight normal :underline nil))))
   `(line-number-current-line ((,cls (:foreground ,blue :inherit line-number))))

   ;; font locks and syntax highlighting
   `(font-lock-builtin-face ((,cls (:foreground ,blue))))
   `(font-lock-comment-face ((,cls (:foreground ,grey  :slant ,(if (and nil spacemacs-theme-comment-italic) 'italic 'normal)))))
   `(font-lock-keyword-face ((,cls (:foreground ,green :slant ,(if (and nil spacemacs-theme-keyword-italic) 'italic 'normal)))))
   `(font-lock-constant-face ((,cls (:foreground ,red :inherit bold))))
   `(font-lock-function-name-face ((,cls (:foreground ,yellow-int))))
   `(font-lock-negation-char-face ((,cls (:foreground ,red))))
   `(font-lock-preprocessor-face ((,cls (:foreground ,green-dim))))
   `(font-lock-string-face ((,cls (:foreground ,blue))))
   `(font-lock-doc-face ((,cls (:inherit font-lock-string-face)))) ; TODO optional bg
   `(font-lock-type-face ((,cls (:foreground ,red))))
   `(font-lock-warning-face ((,cls (:background ,yellow-int :distant-foreground ,yellow-int :foreground ,very-dark-grey :underline nil :inherit bold))))
   `(font-lock-variable-name-face ((,cls (:foreground ,yellow-int))))

   ;; rainbow delimeters are pretty
   `(rainbow-delimiters-depth-1-face ((,cls (:foreground ,(nth 0 rainbow-delims)))))
   `(rainbow-delimiters-depth-2-face ((,cls (:foreground ,(nth 1 rainbow-delims)))))
   `(rainbow-delimiters-depth-3-face ((,cls (:foreground ,(nth 2 rainbow-delims)))))
   `(rainbow-delimiters-depth-4-face ((,cls (:foreground ,(nth 3 rainbow-delims)))))
   `(rainbow-delimiters-depth-5-face ((,cls (:foreground ,(nth 4 rainbow-delims)))))
   `(rainbow-delimiters-depth-6-face ((,cls (:foreground ,(nth 5 rainbow-delims)))))
   `(rainbow-delimiters-depth-7-face ((,cls (:foreground ,(nth 6 rainbow-delims)))))
   `(rainbow-delimiters-depth-8-face ((,cls (:foreground ,(nth 7 rainbow-delims)))))

   ;; hyperlinks and path links
   `(link ((,cls (:foreground ,blue))))   ; hyperlink
   `(link-visited ((,cls (:foreground ,turquoise))))

   ;;; modeline/spaceline
   ;; NOTE mode-line faces below only affect some portions of the mode line
   ;;      these include the buffer name, the mode list & buffer percentage.
   `(mode-line ((,cls (:box (:line-width 1 :color ,very-light-grey :style none)
                            :background ,very-light-grey ; also winum color
                            :foreground ,very-dark-grey))))
   ;; TODO configure mode-line-inactive as well
                                          ; NOTE powerline-active-0 and powerline-inactive-0 also exist, but I have no idea what they do
   `(powerline-active1 ((,cls (:background ,black :foreground ,very-light-grey :inherit mode-line)))) ; major mode indicator
   `(powerline-active2 ((,cls (:background ,black :foreground ,very-light-grey :inherit mode-line)))) ; file-format + cursor-pos

   ;;; evil
   ;; permenent color of highlighted search results. Can be hidden using :nohlsearc
   `(evil-search-highlight-persist-highlight-face ((,cls (:background ,line-highlight-bg :foreground ,orange :inherit bold))))
   `(vimish-fold-overlay ((,cls (:background ,line-highlight-bg))))

   ;;; minibuffer & helm
   `(minibuffer-prompt ((,cls (:foreground ,yellow :weight bold)))) ; NOTE optional read only text preceding minibuffer input
   `(helm-M-x-key ((,cls (:foreground ,blue :inherit bold))))
   `(helm-source-header ((,cls (:foreground "#220833" :background ,yellow :family "sans serif" :weight bold :height 1.3)))) ; TODO use real color
   `(helm-selection ((,cls (:background ,red :distant-foreground ,black)))) ; active row
   `(helm-visible-mark ((,cls (:background ,blue-int))))
   ;;  helm buffer select
   `(helm-buffer-process ((,cls (:foreground ,turquoise-int)))) ; NOTE source for buffer
   `(helm-buffer-size ((,cls (:foreground ,orange :inherit bold))))
                                          ; file type based highlightings
   `(helm-buffer-directory ((,cls (:foreground ,yellow-int))))
   `(helm-buffer-archive ((,cls (:inherit helm-buffer-directory))))
   `(helm-buffer-file ((,cls (:foreground ,turquoise-int :inherit helm-buffer-directory))))
   `(helm-buffer-modified ((,cls (:foreground ,turquoise-int :inherit (bold helm-buffer-directory)))))
   `(helm-buffer-not-saved ((,cls (:foreground ,orange :inherit helm-buffer-directory))))
   `(helm-buffer-saved-out ((,cls (:foreground ,red :inherit helm-buffer-directory)))) ; NOTE saved outside of emacs
   ;; helm find file
   `(helm-ff-prefix ((,cls (:foreground ,black :background ,yellow-int)))) ; prefix for helm new file
   `(helm-ff-directory ((,cls (:inherit helm-buffer-directory))))
   `(helm-ff-dirs ((,cls (:inherit helm-ff-directory))))
   `(helm-ff-dotted-directory ((,cls (:foreground ,yellow-dim :inherit helm-ff-directory))))
   `(helm-ff-symlink ((,cls (:foreground ,grey))))
   `(helm-ff-dotted-symlink-directory ((,cls (:inherit helm-ff-symlink))))
   `(helm-ff-invalid-symlink ((,cls (:strike-through ,red-int :inherit helm-ff-symlink))))
   `(helm-ff-truename ((,cls (:foreground ,green-int :inherit helm-ff-file)))) ; NOTE shown alongside symlinks, is symlink dest
   `(helm-ff-file ((,cls (:inherit helm-buffer-file))))
   `(helm-ff-denied ((,cls (:foreground ,very-dark-grey :background ,red-int :strike-through ,red-int :inherit (bold helm-buffer-file)))))
   `(helm-ff-executable ((,cls (:inherit (bold helm-buffer-file)))))
   `(helm-ff-socket ((,cls (:foreground ,purple-int :inherit helm-buffer-file))))
   `(helm-ff-socket ((,cls (:foreground ,orange-int :inherit helm-buffer-file))))
   `(helm-ff-suid ((,cls (:foreground ,blue :inherit helm-ff-directory))))
   ;; helm grep
   `(helm-grep-cmd-line ((,cls (:inherit font-lock-type-face)))) ; NOTE grep failed cl message
   `(helm-grep-file ((,cls (:foreground ,turquoise-int :inherit bold)))) ; NOTE file in which grep matched
   `(helm-grep-finish ((,cls (:foreground ,red-int)))) ; NOTE grep info in mode line
   `(helm-grep-lineno ((,cls (:foreground ,orange-int :inherit bold))))
   `(helm-grep-match ((,cls (:foreground ,red-int :inherit bold)))) ; NOTE no affect when color=always
   ;; bookmarks
   `(helm-bookmark-addressbook ((,cls (:foreground ,orange-int))))
   `(helm-bookmark-directory ((,cls (:foreground ,yellow-int))))
   `(helm-bookmark-file ((,cls (:foreground ,turquoise-int))))
   `(helm-bookmark-file-not-found ((,cls (:foreground ,very-light-grey :strike-through ,red))))
   `(helm-bookmark-gnus ((,cls (:foreground ,purple-int))))
   `(helm-bookmark-info ((,cls (:foreground ,green-int))))
   `(helm-bookmark-man ((,cls (:foreground ,orange-dim))))
   `(helm-bookmark-w3m ((,cls (:foreground ,yellow-dim))))

   ;;; flycheck
   `(flycheck-info ((,cls (:underline (:style wave :color ,green)))))
   `(flycheck-warning ((,cls (:underline (:style wave :color ,yellow)))))
   `(flycheck-duplicate ((,cls (:underline (:style wave :color ,orange)))))
   `(flycheck-incorrect ((,cls (:underline (:style wave :color ,red)))))
   `(flycheck-fringe-info ((,cls (:foreground ,green-int :inherit fringe))))
   `(flycheck-fringe-warning ((,cls (:foreground ,yellow-int :inherit fringe))))
   `(flycheck-fringe-error ((,cls (:foreground ,red-int :inherit fringe))))

   ;;; frog jump buffer and avy
   `(avy-background-face ((,cls (:foreground ,grey))))
   `(avy-lead-face ((,cls (:background ,red-int :foreground "white"))))
   `(avy-lead-face-0 ((,cls (:background ,blue-int :foreground "white"))))
   `(avy-lead-face-1 ((,cls (:background ,very-light-grey :foreground ,very-dark-grey))))
   `(avy-lead-face-2 ((,cls (:background ,purple-int :foreground "white"))))
   `(frog-menu-border ((,cls (:background ,very-light-grey :foreground ,very-light-grey))))
   `(frog-menu-posframe-background-face ((,cls (:background ,very-light-grey))))

   ;;; company - intellisense
   ;; NOTE foreground-color  very-dark-grey
   ;;      background-color  very-light-grey
   ;;      active-foreground very-light-grey
   ;;      active-background blue
   ;;      sp-color          turquoise-int
   `(company-tooltip-mouse ((,cls (:foreground ,turquoise-int))))
   `(company-template-field ((,cls (:foreground ,turquoise-int))))

   ;; scrollbar
   `(company-scrollbar-bg ((,cls (:background ,very-light-grey :foreground ,very-light-grey))))
   `(company-scrollbar-fg ((,cls (:background ,dark-grey       :foreground ,dark-grey))))

   ;; NOTE preview is for the leading text for a the sole match on a line
   `(company-preview ((,cls (:foreground ,blue-int :weight bold :inherit hl-line))))
   `(company-preview-common ((,cls (:inherit company-preview))))
   `(company-preview-search ((,cls (:foreground ,orange-int :weight normal :inherit company-preview))))

   ;; NOTE tooltip is the drop down menu which shows up when multiple results exist
   `(company-tooltip ((,cls (:background ,very-light-grey :foreground ,very-dark-grey :inherit bold))))
   `(company-tooltip-common ((,cls (:foreground ,blue-int :inherit company-tooltip))))
   `(company-tooltip-selection ((,cls (:foreground ,very-light-grey :background ,blue-int))))
   `(company-tooltip-common-selection ((,cls (:foreground ,very-dark-grey :background ,blue-int :inherit company-tooltip-common))))
   `(company-tooltip-search ((,cls (:foreground ,orange :inherit company-tooltip))))
   `(company-tooltip-search-common ((,cls (:inherit company-tooltip-search))))
   `(company-tooltip-search-selection ((,cls (:background ,blue-int :inherit company-tooltip-search))))

   ;; NOTE annotations are extra information in stdout
   `(company-tooltip-annotation ((,cls (:weight bold :foreground ,grey))))
   `(company-tooltip-annotation-selection ((,cls (:foreground ,turquoise-int :background ,blue-int :inherit company-tooltip-annotation))))

   ;;; set spacemacs evil state fac  `(spacemacs-emacs-face ((,cls (:background ,(color-hsl-to-css-rgb-hex yoda)))))
   `(spacemacs-evilified-face ((,cls (:foreground ,very-dark-grey :background ,red))))
   `(spacemacs-hybrid-face ((,cls (:foreground ,very-dark-grey :background ,orange-dim))))
   `(spacemacs-iedit-face ((,cls (:foreground ,very-dark-grey :background ,orange))))
   `(spacemacs-iedit-insert-face ((,cls (:foreground ,very-dark-grey :background ,orange))))
   `(spacemacs-lisp-face ((,cls (:foreground ,very-dark-grey :background ,green))))
   `(spacemacs-visual-face ((,cls (:foreground ,very-dark-grey :background ,turquoise))))
   `(spacemacs-normal-face ((,cls (:foreground ,very-dark-grey :background ,yellow))))
   `(spacemacs-insert-face ((,cls (:foreground ,very-dark-grey :background ,blue))))
   `(spacemacs-motion-face ((,cls (:foreground ,very-dark-grey :background ,purple))))
   `(spacemacs-replace-face ((,cls (:foreground ,very-dark-grey :background ,very-light-grey))))

   ;;;; custom mode variants
   ;;; whitespace-mode
   ;; `(whitespace-trailing ((,cls (:foreground "yellow" :background ,red))))
   `(whitespace-space ((,cls (:foreground ,dark-grey))))
   `(trailing-whitespace ((,cls (:background ,dark-grey))))

   ;;; auto-highlight-symbol mode
   ;; Note: distant foreground is meaningless here because the faces are always given pririty
   `(ahs-definition-face ((,cls (:background ,blue-dim :distant-foreground ,blue-dim :foreground ,dark-grey))))
   `(ahs-edit-mode-face ((,cls (:background ,red-dim :distant-foreground ,red-dim :foreground ,very-light-grey))))
   `(ahs-face ((,cls (:background ,very-light-grey :foreground ,black :inherit bold)))) ; NOTE matching selections
   `(ahs-plugin-whole-buffer-face ((,cls (:background ,blue :distant-foreground ,green :foreground ,black))))
   `(ahs-plugin-bod-face ((,cls (:background ,blue-int :distant-foreground ,blue-int :foreground ,black))))
   `(ahs-plugin-defalt-face ((,cls (:background ,orange-dim :distant-foreground ,orange-dim :foreground ,black))))
   `(ahs-warning-face ((,cls (:foreground ,red-dim))))

   ;;; compilation mode
   `(compilation-line-number ((,cls (:foreground ,yellow))))
   `(compilation-column-number ((,cls (:inherit font-lock-doc-face))))
   ;; NOTE also represents value count in mode line
   ;; `(compilation-error ((,cls (:background ,red-int :distant-foreground ,red-int :foreground ,very-dark-grey))))
   ;; `(compilation-info ((,cls (:background ,green-int :distant-foreground ,green-int :foreground ,very-dark-grey))))
   ;; `(compilation-warning ((,cls (:background ,orange-int :distant-foreground ,orange-int :foreground ,very-dark-grey))))
   `(compilation-error ((,cls (:foreground ,red-int :inherit bold))))
   `(compilation-info ((,cls (:foreground ,green-int :inherit bold))))
   `(compilation-warning ((,cls (:foreground ,orange-int :inherit bold))))
   ;; NOTE theses only represent the exit status indicator
   `(compilation-mode-line-exit ((,cls (:foreground ,very-dark-grey))))
   `(compilation-mode-line-fail ((,cls (:foreground ,very-dark-grey))))
   `(compilation-mode-line-run ((,cls (:foreground ,very-dark-grey))))

   ;;; markdown-mode
   `(markdown-code-face ((,cls (:inherit default))))

   ;;; anzu
   `(anzu-mode-line ((,cls (:foreground ,very-dark-grey :inherit bold))))
   `(anzu-mode-line-no-match ((,cls (:foreground ,red-int :inherit bold))))

   ;;; org-mode
   `(org-link ((,cls (:foreground ,turquoise :inherit bold))))
   `(org-footnote ((,cls (:foreground ,blue))))
   ;; Overridden by hl-todo-keyword-faces
   `(org-todo ((,cls (:foreground ,purple-int :inherit bold))))
   `(org-done ((,cls (:foreground ,green-int :inherit bold))))
   ;; `(org-warning ((,cls (:foreground ))))
   `(org-upcoming-deadline ((,cls (:foreground ,red-dim))))
   `(org-warning ((,cls (:foreground ,orange :inherit bold))))
   `(org-scheduled-today ((,cls (:foreground ,green-int))))

   ;;; ivy
   ;; `(ivy-current-match ((,cls :backgrouns ,blue-dim :foreground ,black))) ;; hl-line
   ;; `(ivy-confirm-face ((,cls :foreground ,green-dim :inherit bold)))
   ;; `(ivy-match-required-face ((,cls (:foreground ,red-int :inherit bold)))) ;; no candidate chosen
   )

  (custom-theme-set-variables 'an-old-hope
    `(hl-todo-keyword-faces '(("TODO"        . ,red)
                              ("NEXT"        . ,red)
                              ("THEM"        . ,purple)
                              ("PROG"        . ,blue-int)
                              ("OKAY"        . ,blue-int)
                              ("DONT"        . ,green-int)
                              ("FAIL"        . ,red)
                              ("DONE"        . ,green-int)
                              ("NOTE"        . ,yellow-int)
                              ("KLUDGE"      . ,yellow-int)
                              ("HACK"        . ,yellow-int)
                              ("TEMP"        . ,yellow-int)
                              ("FIXME"       . ,orange)
                              ("WARN"        . ,orange)
                              ("XXX+"        . ,orange)
                              ("\\?\\?\\?+"  . ,orange))))
  (put 'custom-theme-set-variables 'lisp-indent-function 'defun)

  (provide-theme 'an-old-hope)

  ;; unbind all assigned colors
  (dolist (color colors)
    (makunbound (car color)))
#+end_src
* Deprecated
:PROPERTIES:
:header-args: :tangle no
:END:
** helm
*** helm-mode
#+begin_src emacs-lisp :tangle no
  (use-package helm
    :ensure t
    :defer  10
    ;; :delight
    ;; (helm-mode " Ⓗ")
    :commands (helm-M-x
               helm-apropos
               helm-resume
               helm-all-mark-rings
               helm-register
               helm-show-kill-ring
               helm-info-at-point
               helm-filtered-bookmarks
               helm-find-files
               helm-locate
               helm-recent-file
               helm-man-woman
               helm-help
               helm-top
               helm-mini
               helm-regexp)
    :init
    (setq helm-split-window-inside-p t)

    (general-define-key
      ;; :states '(normal emacs insert motion)
      "C-M-y" 'helm-show-kill-ring
      "M-x"   'helm-M-x)

    ;; TODO move to helm map
    (bind-keys :map minibuffer-local-map
               ("C-r" . helm-minibuffer-history))

    (general-define-key
      :states 'insert
      "<tab>" 'indent-relative)

    (mohkale/declare-prefix*
      "C-?" "appropos"
      "am"  "man-woman"
      "at"  "top"
      "r" "registers/rings/resume")

    (mohkale/set-leader-keys
      "SPC" 'helm-M-x
      "C-?" 'helm-apropos

      "iu" 'helm-ucs

      "rl" 'helm-resume
      "rm" 'helm-all-mark-rings
      "rr" 'helm-register
      "ry" 'helm-show-kill-ring

      "hi" 'helm-info-at-point

      "fb" 'helm-filtered-bookmarks
      "ff" 'helm-find-files
      "fL" 'helm-locate
      "fr" 'helm-recentf

      "am" 'helm-man-woman
      "at" 'helm-top

      "bb" 'helm-mini
      "bS" 'helm-regexp)
    :config
    (require 'helm-config)
    (helm-mode 1)

    ;;; minibuffer is unecessary when input is shown at the top of helm
    (defun helm-hide-minibuffer-maybe ()
      "https://www.reddit.com/r/emacs/comments/3asbyn/new_and_very_useful_helm_feature_enter_search/"
      (when (with-helm-buffer helm-echo-input-in-header-line)
        (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
          (overlay-put ov 'window (selected-window))
          (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
                                  `(:background ,bg-color :foreground ,bg-color)))
          (setq-local cursor-type nil))))

    (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)

    ;;; always show helm window at the bottom of the frame
    ;; source https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/
    (push `(,(rx bos "*helm" (* not-newline) "*" eos)
            (display-buffer-in-side-window)
            (inhibit-same-window . t)
            (window-height . 0.4))
          display-buffer-alist)

    ;; fuzzy match... fuzzy match EVERYTHING
    (setq-default helm-mode-fuzzy-match t
                  helm-completion-in-region-fuzzy-match t

                  helm-recentf-fuzzy-match    t
                  helm-buffers-fuzzy-matching t
                  helm-recentf-fuzzy-match    t
                  helm-buffers-fuzzy-matching t
                  helm-locate-fuzzy-match     t
                  helm-M-x-fuzzy-match        t
                  helm-semantic-fuzzy-match   t
                  helm-imenu-fuzzy-match      t
                  helm-apropos-fuzzy-match    t
                  helm-lisp-fuzzy-completion  t
                  helm-session-fuzzy-match    t
                  helm-etags-fuzzy-match      t)

    (defun helm-eol-or-confirm-and-exit-minibuffer ()
      "moves to the end of the helm minibuffer or confirm and exit
  exists as a parrallel to backward-sentence binding below"
      (interactive)
      (if (not (eolp))
          (end-of-line)
        (helm-confirm-and-exit-minibuffer)))

    :bind* (:map helm-map
            ("C-h" . nil)
            ("TAB" . helm-maybe-exit-minibuffer)
            ;; ("C-z" . helm-help)
            ;; helm-help doesn't work anyway
            ("C-z" . helm-select-action)
            ;;; movement bindings in normal mode
            ("<left>"  . evil-backward-char)
            ("<right>" . evil-forward-char)
            ;; "C-d" 'helm-buffer-run-kill-buffers
            ("C-j" . helm-next-line)
            ("C-k" . helm-previous-line)
            ("C-h" . backward-sentence)
            ;; TODO check if end of line, if not then
            ;;      exit minibuffer, else goto EOL
            ("C-l" . helm-eol-or-confirm-and-exit-minibuffer)
            ("C-w"   . backward-kill-word)
            ("M-k"   . backward-kill-sentence)
            ("C-M-k" . kill-sentence) ;; kill forward
            ("M-h" . backward-word)
            ("M-l" . forward-word)
            ("M-j"   . ace-jump-helm-line) ; Alternative = C-q
            ("C-d"   . helm-next-page)
            ("C-u"   . helm-previous-page)
            ;; NOTE C-w reads a word in from buffer at point
            ("M-("   . helm-prev-visible-mark)
            ("M-)"   . helm-next-visible-mark)

            :map helm--minor-mode-map
            ("<C-backspace>" . backward-kill-word)))

  (use-package helm-files
    ;; :ensure t
    :defer  t
    :bind (:map helm-find-files-map
           ("<C-backspace>" . nil) ;; delete override
           ("C-h" . helm-find-files-up-one-level)
           ("C-l" . helm-ff-RET)
           ("TAB" . helm-ff-RET)))

  (use-package helm-buffers
    ;; :ensure t
    :defer  t
    :bind (:map helm-buffer-map
          ("M-d" . helm-buffer-run-kill-buffers)
          ("M-D" . nil) ;; delete uppercase variant
          ("M-s" . helm-buffer-save-persistent) ; save but don't kill helm
          ("C-." . helm-buffers-toggle-show-hidden-buffers)))

  (use-package helm-company
    :ensure t
    :defer  t
    :commands helm-company)

  (add-hook 'eshell-mode-hook (lambda ()
                                (require 'helm-eshell)
                                (eshell-cmpl-initialize)
                                ))

  (use-package helm-eshell
    :defer t
    :config
    (eshell-cmpl-initialize)
    :bind* (:map eshell-mode-map
            ([remap eshell-pcomplete] . helm-esh-pcomplete)
            ;; helm-eshell-prompts-all
            ;; helm-eshell-history
            ))

  (with-eval-after-load 'helm
    (defun persp-helm-mini ()
      "helm-mini, but using only the perspectives buffers"
      (interactive)
      (with-persp-buffer-list ()
        (helm-mini)))
    (mohkale/set-leader-keys-for-minor-mode 'persp-mode
      "bb" 'persp-helm-mini))



  ;; (general-define-key
  ;;  :keymaps mohkale-search-map
  ;;  "`" 'helm-ag-pop-stack
  ;;  "B" 'helm-buffers-smart-do-search
  ;;  "c" 'evil-search-clear-highlight
  ;;  "e" 'evil-iedit-state/iedit-mode
  ;;  "F" 'helm-files-smart-do-search-region
  ;;  "f" 'helm-files-smart-do-search
  ;;  "H" 'goto-last-searched-ahs-symbol
  ;;  "h" 'symbol-highlight
  ;;  "j" 'helm-jump-in-buffer
  ;;  "S" 'helm-swoop-region-or-symbol
  ;;  "s" 'helm-swoop
  ;;  "C-s" 'helm-multi-swoop-all)

  ;; (general-define-key
  ;;  :keymaps mohkale-search-ag-map
  ;;  "A" 'helm-file-do-ag-region-or-symbol
  ;;  "a" 'helm-ag-this-file
  ;;  "B" 'helm-buffers-do-ag-region-or-symbol
  ;;  "b" 'helm-do-ag-buffers
  ;;  "F" 'helm-files-do-ag-region-or-symbol
  ;;  "f" 'helm-do-ag
  ;;  "P" 'helm-project-do-ag-region-or-symbol
  ;;  "p" 'helm-project-do-ag)

  ;; (general-define-key
  ;;  :keymaps mohkale-search-ack-map
  ;;  "B" 'helm-buffers-do-ack-region-or-symbol
  ;;  "b" 'helm-buffers-do-ack
  ;;  "F" 'helm-files-do-ack-region-or-symbol
  ;;  "f" 'helm-files-do-ack
  ;;  "P" 'helm-project-do-ack-region-or-symbol
  ;;  "p" 'helm-project-do-ack)

  ;; (general-define-key
  ;;  :keymaps mohkale-search-ack-map
  ;;  "B" 'helm-buffers-do-grep-region-or-symbol
  ;;  "b" 'helm-buffers-do-grep
  ;;  "F" 'helm-files-do-grep-region-or-symbol
  ;;  "f" 'helm-files-do-grep
  ;;  "G" 'helm-file-do-grep-region-or-symbol
  ;;  "g" 'helm-file-do-grep
  ;;  "P" 'helm-projectile-grep)

  ;; (general-define-key
  ;;  :keymaps mohkale-search-pt-map
  ;;  "B" 'helm-buffers-do-pt-region-or-symbol
  ;;  "b" 'helm-buffers-do-pt
  ;;  "F" 'helm-files-do-apt-region-or-symbol
  ;;  "f" 'helm-files-do-apt
  ;;  "P" 'helm-project-do-pt-region-or-symbol
  ;;  "p" 'helm-project-do-pt)

  ;; (general-define-key
  ;;  :keymaps mohkale-search-pt-map
  ;;  "g" 'helm-google-suggest
  ;;  "w" 'helm-wikipedia-suggest)

  ;; (general-define-key
  ;;  :keymaps mohkale-help-map
  ;;  "T" 'evil-tutor-start
  ;;  )

  ;; (general-define-key
  ;;   ;; depends on dired-x
  ;;   :keymaps emacs-leader-keys-files-map
  ;;   "d" 'dired-jump
  ;;  )

  ;; (general-define-key
  ;;   :keymaps 'mohkale-buffers-map
  ;;   "A" 'persp-add-buffer
  ;;   "a" 'persp-add-current-buffer
  ;;   "R" 'persp-remove-buffer
  ;;   "r" 'persp-remove-current-buffer
  ;;  )
#+end_src
*** helm-descbinds
#+begin_src emacs-lisp :tangle no
  (use-package helm-descbinds
    :ensure t
    :defer  t
    :commands helm-descbinds
    :init
    ;; (mohkale/declare-prefix*
    ;;   "hdB" "describe-bindings-buffer"
    ;;   "hdb" "describe-bindings")
    (mohkale/set-leader-keys
      ;; "hdB" 'describe-bindings
      ;; "hdb" 'helm-descbinds

      "?" 'helm-descbinds)
    (defalias 'describe-bindings 'helm-descbinds))
#+end_src
*** helm-make
#+begin_src emacs-lisp :tangle no
  (use-package helm-make
    :ensure t
    :defer  t
    :commands (helm-make
               helm-make-projectile)
    :init
    (mohkale/set-leader-keys
      "cc" 'helm-make-projectile
      "cm" 'helm-make))
#+end_src
*** ace-jump-helm-line
#+begin_src emacs-lisp :tangle no
  (use-package ace-jump-helm-line
    :ensure t
    :defer  t
    :commands ace-jump-helm-line
    :bind (:map helm-map
           ("C-q" . ace-jump-helm-line)))
#+end_src
*** helm-projectile
#+begin_src emacs-lisp :tangle no
  (use-package helm-projectile
    :ensure t
    :defer  t
    :after (projectile helm)
    :commands (helm-projectile-on
               helm-projectile-switch-project
               helm-projectile-find-file
               helm-projectile-find-file-in-known-projects
               helm-projectile-find-file-dwim
               helm-projectile-find-dir
               helm-projectile-recentf
               helm-projectile-switch-to-buffer
               helm-projectile-grep
               helm-projectile-ag
               helm-projectile-rg)
    :init
    (mohkale/declare-prefix*
      "ps" '("search" . "project-search"))

    (mohkale/set-leader-keys
      "pb" 'helm-projectile-switch-to-buffer
      "pd" 'helm-projectile-find-dir
      "pf" 'helm-projectile-find-file
      "ph" 'helm-projectile
      ;; "pl" 'helm-persp-switch-project
      "pP" 'helm-projectile-switch-project
      "pr" 'helm-projectile-recentf
      "psg" 'helm-projectile-grep
      "psa" 'helm-projectile-ag
      "psr" 'helm-projectile-rg)
    :config
    (helm-projectile-on))
#+end_src
*** helm-yasnippet
    access snippets from helm... really cool tbh
#+begin_src emacs-lisp :tangle no
  (use-package helm-c-yasnippet
    :ensure t
    :defer  t
    :commands helm-yas-complete
    :init
    (mohkale/set-leader-keys
      "is" 'helm-yas-complete)
    (general-define-key
      :states 'insert
      "C-M-i" 'helm-yas-complete))
#+end_src
*** helm-pydoc
#+begin_src emacs-lisp :tangle no
  (use-package helm-pydoc
    :ensure t
    :defer  t
    :commands helm-pydoc
    :init
    (with-eval-after-load 'helm
      (mohkale/set-leader-keys-for-major-mode 'python-mode
        "hd" 'helm-pydoc)))
#+end_src
